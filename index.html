<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <meta name="author" content="Ng Jun Wei">
  <meta name="copyright" content="¬© 2025 Ng Jun Wei. All rights reserved.">
  <title>Sport Performance Analyzer (iOS) ‚Ä¢ Multi-skill (Throw/Pitch/Kick/Jump) ‚Ä¢ Contact-aware</title>

  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.11.0"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@2.1.0"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.3"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

  <style>
    * { margin:0; padding:0; box-sizing:border-box; }
    body{
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 14px;
      padding-bottom: 80px;
    }
    .container{
      max-width: 1400px;
      margin: 0 auto;
      background:#fff;
      border-radius: 18px;
      padding: 16px;
      box-shadow: 0 18px 55px rgba(0,0,0,0.22);
    }
    h1 { text-align:center; color:#667eea; margin-bottom:6px; font-size:2.05em; }
    .subtitle{ text-align:center; color:#666; margin-bottom:14px; font-size:1.02em; }

    .layout{
      display:grid;
      grid-template-columns: 1.08fr 0.92fr;
      gap: 14px;
      align-items:start;
    }
    @media (max-width: 980px){ .layout{ grid-template-columns: 1fr; } }

    .card{ background:#f8f9fa; border-radius: 14px; padding: 14px; }
    .form-grid{
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(190px, 1fr));
      gap: 10px;
      margin-top: 10px;
    }
    label{ font-weight: 850; margin-bottom: 6px; color:#333; display:block; }
    input, select{
      width:100%;
      padding: 10px;
      border: 2px solid #ddd;
      border-radius: 12px;
      font-size: 14px;
      background:#fff;
    }
    input:focus, select:focus{ outline:none; border-color:#667eea; }

    .btn{
      padding: 11px 14px;
      border: none;
      border-radius: 12px;
      font-size: 14px;
      font-weight: 900;
      cursor:pointer;
      margin: 8px 8px 0 0;
      transition: transform .15s, opacity .15s;
    }
    .btn:hover{ transform: translateY(-1px); }
    .btn:disabled{ background:#cfcfcf !important; cursor:not-allowed; opacity:.85; transform:none; }
    .btn-primary{ background:#667eea; color:#fff; }
    .btn-success{ background:#10b981; color:#fff; }
    .btn-danger { background:#ef4444; color:#fff; }
    .btn-ghost { background: rgba(102,126,234,0.12); color:#3b4bd6; }

    .status-message{
      display:none;
      text-align:center;
      padding: 10px 12px;
      border-radius: 12px;
      font-weight: 950;
      margin: 10px 0 14px 0;
    }
    .status-success{ background:#d1fae5; color:#065f46; }
    .status-error{ background:#fee2e2; color:#991b1b; }
    .status-info{ background:#dbeafe; color:#1e40af; }

    .sticky{ position: sticky; top: 8px; }
    @media (max-width: 980px){ .sticky{ top: 0; z-index: 50; position: static; } }

    .video-wrap{ position:relative; background:#000; border-radius: 14px; overflow:hidden; min-height: 200px; }
    video{ width:100%; height:auto; display:block; position:relative; z-index:1; }
    canvas#overlay{
      width:100%; height:100%; display:block;
      position:absolute; left:0; top:0;
      z-index:5; pointer-events:none;
    }
    .hud{
      position:absolute; top: 10px; right: 10px;
      z-index: 10;
      background: rgba(0,0,0,0.72);
      color:#fff;
      padding: 6px 10px;
      border-radius: 12px;
      font-size: 13px;
      font-weight: 950;
      display:flex;
      flex-direction: column;
      gap:6px;
      align-items:flex-end;
      max-width: 95%;
      white-space: pre-line;
    }
    .divider{ height:1px; background:#e9e9e9; margin: 12px 0; }
    .mini{ color:#666; font-size: .88em; line-height: 1.35; margin-top: 8px; }

    .metrics-grid{
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 10px;
      margin-top: 10px;
    }
    .metric{
      background:#fff;
      border-radius: 14px;
      padding: 12px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.06);
    }
    .metric .t{ color:#666; font-weight:850; font-size:.92em; margin-bottom: 6px; }
    .metric .v{ color:#667eea; font-weight: 1000; font-size: 1.55em; }
    .metric .s{ color:#666; font-weight: 850; font-size: .88em; margin-top: 6px; line-height: 1.25; }

    .chiplist{ margin-top: 10px; display:flex; flex-wrap:wrap; gap: 8px; }
    .chip{
      background:#fff;
      border-radius: 999px;
      padding: 6px 10px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.06);
      display:flex;
      align-items:center;
      gap: 10px;
      font-weight: 900;
      color:#333;
      font-size: 13px;
    }
    .chip button{
      border:none;
      background: rgba(239,68,68,0.12);
      color:#ef4444;
      font-weight: 1000;
      border-radius: 999px;
      padding: 4px 8px;
      cursor:pointer;
    }

    .charts-grid{ display:grid; grid-template-columns: 1fr; gap: 12px; margin-top: 10px; }
    .chart-card{
      background:#fff;
      border-radius: 14px;
      padding: 12px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.06);
    }
    .chart-title{
      display:flex;
      justify-content: space-between;
      align-items:center;
      gap: 10px;
      margin-bottom: 8px;
    }
    .chart-title b{ color:#222; }
    .chart-title span{ color:#666; font-weight: 850; font-size: .9em; }
    canvas.chart{
      width: 100%;
      height: 180px;
      display:block;
      border-radius: 12px;
      background: #fafafa;
    }

    .card-head{
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 6px;
    }
    .collapse-btn{
      display:inline-flex;
      align-items:center;
      gap: 8px;
      border:none;
      cursor:pointer;
      border-radius: 12px;
      padding: 10px 12px;
      font-weight: 1000;
      background: rgba(102,126,234,0.12);
      color:#3b4bd6;
    }
    .collapse-icon{
      width: 10px;
      height: 10px;
      border-right: 3px solid currentColor;
      border-bottom: 3px solid currentColor;
      transform: rotate(45deg);
      transition: transform .18s ease;
      margin-left: 2px;
    }
    .collapsed .collapse-icon{ transform: rotate(-45deg); }
    .collapsible{
      overflow: hidden;
      transition: max-height .22s ease, opacity .22s ease;
      max-height: 2800px;
      opacity: 1;
    }
    .collapsed .collapsible{
      max-height: 0px;
      opacity: 0;
      pointer-events: none;
    }

    footer{ margin-top: 14px; text-align:center; color:#666; font-weight: 850; font-size: 0.92em; }

    .pip-toggle{ display:none; margin-top: 10px; }
    @media (max-width: 980px) {
      .pip-toggle{ display:inline-block; }
      body.pip-on .sticky .card{
        position: fixed;
        left: 12px; right: 12px; bottom: 12px;
        z-index: 9999;
        padding: 10px;
        box-shadow: 0 18px 55px rgba(0,0,0,0.35);
        max-width: 520px;
        margin: 0 auto;
      }
      body.pip-on .container{ padding-bottom: 270px; }
    }
  </style>
</head>

<body>
<div class="container">
  <h1>üèÉ‚Äç‚ôÇÔ∏è Movement Kinetics Lab</h1>
  <p class="subtitle">Multi-skill classifier + <b>contact-aware events</b> (Throw/Pitch: proj+œâ ‚Ä¢ Kick: ankle speed+impact ‚Ä¢ Jump: takeoff+landing) ‚Ä¢ Kalman kinematics ‚Ä¢ low-pass kinetics</p>

  <div id="statusMessage" class="status-message"></div>

  <div class="layout">
    <div>
      <div class="card">
        <h3>Participant</h3>
        <div class="form-grid">
          <div><label>Name *</label><input id="participantName" placeholder="Enter name"></div>
          <div>
            <label>Sex *</label>
            <select id="participantSex"><option value="male">Male</option><option value="female">Female</option></select>
          </div>
          <div><label>Age *</label><input id="participantAge" type="number" value="25"></div>
          <div><label>Mass (kg) *</label><input id="participantMass" type="number" value="70"></div>
          <div><label>Height (cm) *</label><input id="participantHeight" type="number" value="175"></div>
        </div>
        <button class="btn btn-success" onclick="addParticipant(true)">Add / Update Participant</button>

        <div class="divider"></div>

        <div class="form-grid">
          <div>
            <label>Select Participant</label>
            <select id="selectedParticipant" onchange="onParticipantChange()"></select>
          </div>
          <div>
            <label>Motion Plane</label>
            <select id="motionPlane">
              <option value="sagittal" selected>Sagittal (side view)</option>
              <option value="frontal">Frontal (front view)</option>
            </select>
          </div>
        </div>

        <div class="divider"></div>

        <h3>Input Source</h3>
        <div class="form-grid">
          <div>
            <label>Source</label>
            <select id="inputSource">
              <option value="camera" selected>Live Camera</option>
              <option value="upload">Video Upload</option>
            </select>
          </div>
          <div>
            <label>FPS (Requested)</label>
            <select id="fpsSelection">
              <option value="30">30</option>
              <option value="60" selected>60</option>
              <option value="120">120 (best effort)</option>
              <option value="240">240 (best effort)</option>
            </select>
          </div>
          <div>
            <label>Camera</label>
            <select id="cameraFacing"><option value="environment">Back</option><option value="user">Front</option></select>
          </div>
          <div>
            <label>Kinetics low-pass cutoff (Hz)</label>
            <select id="cutoffHz">
              <option value="2">2</option>
              <option value="3">3</option>
              <option value="4">4</option>
              <option value="6" selected>6</option>
              <option value="10">10</option>
            </select>
          </div>
        </div>

        <div class="form-grid" style="margin-top:10px;">
          <div><label>Video File (Upload)</label><input id="videoUpload" type="file" accept="video/*"></div>
        </div>

        <button class="btn btn-primary" onclick="startInput()">Start (Camera / Upload)</button>
        <button class="btn btn-danger" onclick="stopInput()">Stop</button>
        <button class="btn btn-success" id="recordBtn" onclick="toggleRecording()" disabled>Start Recording</button>
        <button class="btn btn-ghost" onclick="snapshotPNG()" id="snapBtn" disabled>üì∏ Snapshot PNG</button>
        <button class="btn btn-primary pip-toggle" onclick="togglePiP()">üìå Pin Video (PiP)</button>

        <div class="divider"></div>

        <h3>Projectile Tracking</h3>
        <div class="form-grid">
          <div>
            <label>Mode</label>
            <select id="projMode"><option value="off" selected>Off</option><option value="coco">COCO-SSD Detect</option></select>
          </div>
          <div>
            <label>Class</label>
            <select id="projClassHint">
              <option value="sports ball" selected>Sports ball</option>
              <option value="frisbee">Frisbee</option>
              <option value="kite">Kite</option>
              <option value="bottle">Bottle</option>
              <option value="cup">Cup</option>
            </select>
          </div>
          <div>
            <label>Confidence</label>
            <select id="projMinScore">
              <option value="0.30">0.30</option>
              <option value="0.40" selected>0.40</option>
              <option value="0.50">0.50</option>
              <option value="0.60">0.60</option>
            </select>
          </div>
          <div>
            <label>Detect Rate</label>
            <select id="projEveryN">
              <option value="1">Every frame</option>
              <option value="2" selected>Every 2 frames</option>
              <option value="3">Every 3 frames</option>
              <option value="4">Every 4 frames</option>
            </select>
          </div>
        </div>

        <div class="divider"></div>

        <h3>Kinetics Driver</h3>
        <div class="form-grid">
          <div>
            <label>Driver Joint</label>
            <select id="kinJoint">
              <option value="hip">Hip</option>
              <option value="knee">Knee</option>
              <option value="ankle">Ankle (segment œâ)</option>
              <option value="shoulder">Shoulder</option>
              <option value="elbow">Elbow</option>
              <option value="wrist">Wrist (segment œâ)</option>
            </select>
          </div>
          <div>
            <label>Side</label>
            <select id="kinSide"><option value="R">Right</option><option value="L">Left</option></select>
          </div>
        </div>
        <p class="mini">
          œâ is computed from <b>filtered angle [rad]</b> over time ‚Üí <b>œâ [rad/s]</b>. Angles exported in <b>[rad]</b>.
          Event markers are <b>skill-aware</b>: Throw/Pitch uses peak projectile speed + peak œâ; Kick uses peak ankle speed + impact proxy;
          Jump uses takeoff (peak upward COM velocity) + landing (impact proxy).
        </p>
      </div>

      <div class="card collapsible-card" id="kinSelCard" style="margin-top:12px;">
        <div class="card-head">
          <h3 style="margin:0;">Kinematics Selector (Export + Live cards)</h3>
          <button class="collapse-btn" onclick="toggleCollapse('kinSelCard')">
            <span id="kinSelCard_lbl">Collapse</span><span class="collapse-icon"></span>
          </button>
        </div>
        <div class="collapsible">
          <div class="form-grid">
            <div>
              <label>Metric</label>
              <select id="metricType">
                <option value="angle">Angle [rad]</option>
                <option value="angVel">Ang. Vel [rad/s]</option>
                <option value="linVel">Lin. Vel [m/s]</option>
              </select>
            </div>
            <div>
              <label>Joint / Segment</label>
              <select id="metricJoint">
                <option value="shoulder">Shoulder</option>
                <option value="elbow">Elbow</option>
                <option value="wrist">Wrist (segment)</option>
                <option value="hip">Hip</option>
                <option value="knee">Knee</option>
                <option value="ankle">Ankle (segment)</option>
              </select>
            </div>
            <div>
              <label>Side</label>
              <select id="metricSide"><option value="R">Right</option><option value="L">Left</option></select>
            </div>
          </div>
          <button class="btn btn-primary" onclick="addMetric()">Add</button>
          <button class="btn btn-danger" onclick="clearMetrics()">Clear</button>
          <div class="chiplist" id="metricChips"></div>

          <div class="divider"></div>
          <div class="metrics-grid" id="selectedMetricsPanel"></div>

          <div class="divider"></div>
          <div class="metric">
            <div class="t">Live overview (filtered)</div>
            <div class="s" id="liveInterpretation">‚Äî</div>
          </div>
        </div>
      </div>

      <div class="card" style="margin-top:12px;">
        <h3>Charts</h3>
        <div class="charts-grid">
          <div class="chart-card">
            <div class="chart-title">
              <b>Kinetics: Force‚ÄìTime [N] + Moment‚ÄìTime [Nm]</b>
              <span id="lblKinetics">F: 0 N | M: 0 Nm</span>
            </div>
            <canvas id="chartDual" class="chart"></canvas>
          </div>
        </div>
        <p class="mini">
          Force and moment are <b>cascaded low-pass filtered</b> for smooth 2-axis visualization. Kinematics are Kalman-filtered and exported as discrete time series.
        </p>
      </div>

      <div class="card" style="margin-top:12px;">
        <button class="btn btn-primary" onclick="downloadData()">üìä Download XLSX (Profile ‚Ä¢ Phase Summary ‚Ä¢ TimeSeries ‚Ä¢ Technical Model)</button>
      </div>
    </div>

    <div class="sticky" id="stickyVideo">
      <div class="card">
        <h3>Live View</h3>
        <div class="video-wrap">
          <video id="video" playsinline muted></video>
          <canvas id="overlay"></canvas>
          <div class="hud">
            <div id="fpsIndicator">FPS: 0</div>
            <small id="statusText">Ready</small>
            <small id="sourceText">Source: ‚Äî</small>
          </div>
        </div>
        <p class="mini">
          Tip: For contact detection (kick/jump), keep feet visible and avoid cropping the ankles.
        </p>
      </div>
    </div>
  </div>

  <footer>¬© 2025 Ng Jun Wei. All rights reserved.</footer>
</div>

<script>
/* =========================
   Globals
========================= */
let detector=null, cocoModel=null;
let video=null, overlay=null, ctx=null;
let streamRef=null, animationId=null;

let participants=[], currentParticipant=null;
let isRecording=false;

let prevKeypoints=null;
let frameIndex=0;

let detectedFPS=0, framesInSecond=0;
let lastFPSUpdate=performance.now();

let selectedMetrics=[];
let lastProjectiles=[];
let prevProjState=null;

const FILTER_ORDER = 4;
let forceStages = new Array(FILTER_ORDER).fill(0);
let momentStages = new Array(FILTER_ORDER).fill(0);

const rolling = { t: [], force: [], moment: [] };
let chartLastDraw=0;

// keypoint map (MoveNet)
const KP = {
  shoulder_L:5, shoulder_R:6, elbow_L:7, elbow_R:8, wrist_L:9, wrist_R:10,
  hip_L:11, hip_R:12, knee_L:13, knee_R:14, ankle_L:15, ankle_R:16
};

// anthropometry proxies
const SEG_MASS = { thigh:0.10, shank:0.0465, foot:0.0145, upperArm:0.028, forearm:0.016, hand:0.006, trunk:0.50 };
const SEG_K    = { thigh:0.323, shank:0.302, foot:0.475, upperArm:0.322, forearm:0.303, hand:0.628 };

// Kalman cache
const kf = new Map();       // key -> {x, P, Q, R}
const angleState = new Map();// key -> {prevRad, prevFiltRad}

// recording store
let rec = resetRec();
let sessionMeta = {};
let driverDisp=0;

function resetRec(){
  return {
    fpsUsed: 60,
    n: 0,
    driver: "",
    plane: "sagittal",
    t: [],
    forceN: [],
    momentNm: [],
    driver_linVel: [],
    driver_angVel: [],
    driver_angle: [],
    driver_disp: [],
    proj_speed: [],

    // contact/jump features
    ankleR_y_m: [],
    ankleL_y_m: [],
    ankleR_vy_up_mps: [],
    ankleL_vy_up_mps: [],
    ankle_peakSpeed_mps: [],   // max of L/R ankle speed (filtered)
    ankle_impact_proxy: [],    // proxy score for "impact" event

    // COM proxy
    midHipY_m: [],
    midHipVy_mps: [],

    // selected metrics
    metricsDefs: [],
    metrics: {},

    // extra angles (rad) and segment orientations
    shoulderAng_R: [],
    shoulderAng_L: [],
    elbowAng_R: [],
    elbowAng_L: [],
    hipAng_R: [],
    hipAng_L: [],
    kneeAng_R: [],
    kneeAng_L: [],
    ankleOri_R: [],
    ankleOri_L: [],
    wristOri_R: [],
    wristOri_L: []
  };
}

/* =========================
   Init
========================= */
window.onload = async () => {
  video=document.getElementById('video');
  overlay=document.getElementById('overlay');
  ctx=overlay.getContext('2d');

  document.getElementById('participantName').value="Athlete 1";
  addParticipant(false);

  showStatus("Loading Neural Networks...", "info");
  try{
    await tf.ready();
    try { await tf.setBackend('webgl'); await tf.ready(); } catch(_) {}

    detector = await poseDetection.createDetector(
      poseDetection.SupportedModels.MoveNet,
      { modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING }
    );
    cocoModel = await cocoSsd.load();

    showStatus("Models Ready. Start Camera or Upload.", "success");
    setStatusText("Models ready");
  }catch(e){
    console.error(e);
    showStatus("Error loading models. Try reloading.", "error");
    setStatusText("Model load error");
  }
};

/* =========================
   Participant
========================= */
function addParticipant(showToast=true){
  const name=(document.getElementById('participantName').value||"").trim();
  const sex=document.getElementById('participantSex').value;
  const age=parseInt(document.getElementById('participantAge').value||"0");
  const mass=parseFloat(document.getElementById('participantMass').value||"0");
  const height=parseFloat(document.getElementById('participantHeight').value||"0");
  if(!name||!mass||!height||!age){ if(showToast) showStatus("Fill Name, Age, Mass, Height.", "error"); return; }

  const existing=participants.find(p=>p.name===name);
  const profile={name,sex,age,mass,height};
  if(existing) Object.assign(existing, profile);
  else participants.push(profile);

  const sel=document.getElementById('selectedParticipant');
  sel.innerHTML="";
  participants.forEach(p=>{
    const opt=document.createElement('option');
    opt.value=p.name; opt.textContent=p.name;
    sel.appendChild(opt);
  });
  sel.value=name;
  currentParticipant=profile;
  if(showToast) showStatus(`Participant set: ${name}`, "success");
}
function onParticipantChange(){
  const sel=document.getElementById('selectedParticipant');
  const p=participants.find(x=>x.name===sel.value);
  if(p) currentParticipant=p;
}

/* =========================
   Input
========================= */
async function startInput(){
  if(!detector) return showStatus("Wait for models to load.", "error");
  stopActive();
  resetSessionState();

  const src=document.getElementById('inputSource').value;
  const fpsReq=parseInt(document.getElementById('fpsSelection').value);
  const facing=document.getElementById('cameraFacing').value;

  sessionMeta={ source:src, fpsRequested:fpsReq, facing, startedAt:new Date().toISOString() };

  if(src==="camera") await startCameraInternal(fpsReq, facing);
  else await startUploadInternal();
}
async function startCameraInternal(fpsReq, facing){
  setStatusText("Starting camera...");
  setSourceText(`Source: Camera (${facing}, req ${fpsReq}fps)`);

  const constraints={
    video:{
      facingMode:facing,
      width:{ideal:1280},
      height:{ideal:720},
      frameRate:{ideal:fpsReq, max:fpsReq}
    },
    audio:false
  };

  try{
    streamRef=await navigator.mediaDevices.getUserMedia(constraints);
    video.srcObject=streamRef;
    video.onloadedmetadata=async()=>{
      await video.play();
      overlay.width=video.videoWidth||1280;
      overlay.height=video.videoHeight||720;

      if(facing==='user'){ video.style.transform="scaleX(-1)"; overlay.style.transform="scaleX(-1)"; }
      else { video.style.transform="none"; overlay.style.transform="none"; }

      enableRunButtons(true);
      setStatusText("Running");
      animationId=requestAnimationFrame(renderLoop);
      showStatus("Camera Active", "success");
    };
  }catch(err){
    console.error(err);
    showStatus("Camera Error: "+err.message, "error");
    setStatusText("Camera error");
  }
}
async function startUploadInternal(){
  const fileInput=document.getElementById('videoUpload');
  if(!fileInput.files.length) return showStatus("Select a video file first.", "error");
  const file=fileInput.files[0];
  const url=URL.createObjectURL(file);

  setStatusText("Loading video...");
  setSourceText(`Source: Upload (${file.name})`);

  video.srcObject=null;
  video.src=url;
  video.loop=true;
  video.muted=true;
  video.playsInline=true;

  video.onloadedmetadata=async()=>{
    try{
      await video.play();
      overlay.width=video.videoWidth||1280;
      overlay.height=video.videoHeight||720;

      video.style.transform="none";
      overlay.style.transform="none";

      enableRunButtons(true);
      setStatusText("Running");
      animationId=requestAnimationFrame(renderLoop);
      showStatus("Playing Upload", "success");
    }catch(e){
      console.error(e);
      showStatus("Upload playback error: "+e.message, "error");
      setStatusText("Upload error");
    }
  };
}
function stopInput(){
  stopActive();
  enableRunButtons(false);
  showStatus("Stopped", "info");
  setStatusText("Stopped");
  setSourceText("Source: ‚Äî");
}
function stopActive(){
  if(animationId) cancelAnimationFrame(animationId);
  animationId=null;

  if(streamRef){ try{ streamRef.getTracks().forEach(t=>t.stop()); }catch(_){} }
  streamRef=null;

  try{ video.pause(); }catch(_){}
  video.srcObject=null;

  if(ctx) ctx.clearRect(0,0,overlay.width,overlay.height);
}
function enableRunButtons(running){
  document.getElementById('recordBtn').disabled=!running;
  document.getElementById('snapBtn').disabled=!running;
}
function resetSessionState(){
  isRecording=false;
  rec=resetRec();
  prevKeypoints=null;
  frameIndex=0;

  prevProjState=null;
  lastProjectiles=[];

  forceStages=new Array(FILTER_ORDER).fill(0);
  momentStages=new Array(FILTER_ORDER).fill(0);

  kf.clear();
  angleState.clear();

  driverDisp=0;

  rolling.t=[]; rolling.force=[]; rolling.moment=[];

  document.getElementById('lblKinetics').innerText="F: 0 N | M: 0 Nm";
  document.getElementById('liveInterpretation').innerText="‚Äî";
}

/* =========================
   Kalman (1D)
========================= */
function kalman1D(key, z, Q, R){
  if(!isFinite(z)) return 0;
  let s = kf.get(key);
  if(!s){
    s = { x: z, P: 1, Q, R };
    kf.set(key, s);
    return s.x;
  }
  s.P = s.P + s.Q;
  const K = s.P / (s.P + s.R);
  s.x = s.x + K * (z - s.x);
  s.P = (1 - K) * s.P;
  return s.x;
}
function kalmanParamsFor(type){
  if(type==="angle")  return {Q: 1e-3, R: 5e-3};      // rad
  if(type==="angVel") return {Q: 5e-2, R: 2e-1};      // rad/s
  if(type==="linVel") return {Q: 2e-2, R: 1e-1};      // m/s
  if(type==="proj")   return {Q: 3e-2, R: 1.5e-1};    // m/s
  if(type==="foot")   return {Q: 2e-2, R: 2e-1};      // m/s for ankle vy
  return {Q: 1e-3, R: 1e-2};
}

/* =========================
   Main loop
========================= */
async function renderLoop(){
  animationId=requestAnimationFrame(renderLoop);
  if(!video||video.paused||video.ended) return;

  framesInSecond++;
  const nowPerf=performance.now();
  if(nowPerf-lastFPSUpdate>=1000){
    detectedFPS=framesInSecond;
    framesInSecond=0;
    lastFPSUpdate=nowPerf;
    document.getElementById('fpsIndicator').innerText="FPS: "+detectedFPS;
  }

  frameIndex++;

  let kp=null;
  try{
    const poses=await detector.estimatePoses(video,{flipHorizontal:false});
    if(poses&&poses.length&&poses[0].keypoints) kp=poses[0].keypoints;
  }catch(_){}

  // projectile
  const projMode=document.getElementById('projMode').value;
  if(projMode==="coco" && cocoModel){
    const everyN=parseInt(document.getElementById('projEveryN').value);
    if(frameIndex%everyN===0){
      try{
        const preds=await cocoModel.detect(video);
        const cls=document.getElementById('projClassHint').value;
        const minScore=parseFloat(document.getElementById('projMinScore').value);
        lastProjectiles=preds.filter(p => p.class===cls && p.score>=minScore).sort((a,b)=>b.score-a.score).slice(0,1);
      }catch(_){}
    }
  }else lastProjectiles=[];

  // draw
  ctx.clearRect(0,0,overlay.width,overlay.height);
  if(kp) drawSkeleton(kp);
  drawProjectile(lastProjectiles);

  if(kp){
    const plane=document.getElementById('motionPlane').value;

    const proj = computeProjectileSpeed(lastProjectiles);
    const kin  = computeDriverKinematics(kp, plane);
    const kinets = computeDriverKinetics(kin);

    const feet = computeFootContactSignals(kp, kin.fpsUsed, kinets);

    processSelectedMetrics(kp);

    document.getElementById('lblKinetics').innerText =
      `F: ${(kinets.forceN||0).toFixed(0)} N | M: ${(kinets.momentNm||0).toFixed(6)} Nm`;

    const skillLive = inferSkillLive(kp, proj, feet);
    const liveText = [
      `Plane: ${plane}`,
      `Skill guess: ${skillLive.skill} (conf ${skillLive.conf.toFixed(2)})`,
      `Driver: ${kin.driver}`,
      `v [m/s]: ${kin.linVel.toFixed(3)} | œâ [rad/s]: ${kin.angVel.toFixed(3)} | Œ∏ [rad]: ${kin.angleRad.toFixed(3)} | disp [m]: ${kin.disp.toFixed(3)}`,
      `Projectile speed [m/s]: ${proj.speed.toFixed(3)}`,
      `Contact proxy: impact=${feet.impactProxy.toFixed(3)} | anklePeakSpeed=${feet.anklePeakSpeed.toFixed(3)}`
    ].join("\n");
    document.getElementById('liveInterpretation').innerText = liveText;

    pushRollingKinetics(kinets, kin.fpsUsed);

    if(isRecording){
      recordSample(kp, kin, kinets, proj, plane, feet);
    }

    prevKeypoints=kp;
    setStatusText(isRecording ? "Recording..." : "Running");
  } else {
    setStatusText("No pose detected");
  }

  drawChartsThrottled();
}

/* =========================
   Drawing
========================= */
function drawSkeleton(kp){
  const minScore=0.30;
  ctx.lineWidth=3;
  ctx.strokeStyle="#00ff66";

  const skeleton=[
    [KP.shoulder_L, KP.shoulder_R],
    [KP.shoulder_L, KP.elbow_L], [KP.elbow_L, KP.wrist_L],
    [KP.shoulder_R, KP.elbow_R], [KP.elbow_R, KP.wrist_R],
    [KP.shoulder_L, KP.hip_L], [KP.shoulder_R, KP.hip_R],
    [KP.hip_L, KP.hip_R],
    [KP.hip_L, KP.knee_L], [KP.knee_L, KP.ankle_L],
    [KP.hip_R, KP.knee_R], [KP.knee_R, KP.ankle_R]
  ];

  skeleton.forEach(([i,j])=>{
    if(kp[i]?.score>minScore && kp[j]?.score>minScore){
      ctx.beginPath(); ctx.moveTo(kp[i].x,kp[i].y); ctx.lineTo(kp[j].x,kp[j].y); ctx.stroke();
    }
  });

  kp.forEach(p=>{
    if(p.score>minScore){
      ctx.beginPath(); ctx.arc(p.x,p.y,5,0,2*Math.PI);
      ctx.fillStyle="red"; ctx.fill();
    }
  });
}
function drawProjectile(projs){
  if(!projs||!projs.length) return;
  ctx.save();
  ctx.lineWidth=2;
  ctx.strokeStyle="orange";
  ctx.fillStyle="orange";
  ctx.font="14px system-ui, -apple-system, Segoe UI, Roboto, Arial";
  projs.forEach(p=>{
    const [x,y,w,h]=p.bbox;
    ctx.strokeRect(x,y,w,h);
    ctx.fillText(`${p.class} ${(p.score*100).toFixed(0)}%`, x, y>18?y-6:y+18);
  });
  ctx.restore();
}

/* =========================
   Helpers
========================= */
function getPxToMeter(){
  const hM=currentParticipant?(currentParticipant.height/100):1.75;
  const denom=Math.max(240, overlay.height*0.80);
  return hM/denom;
}
function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }
function round(x,dp){ if(!isFinite(x)) return 0; const p=Math.pow(10,dp); return Math.round(x*p)/p; }
function mean(arr){ if(!arr || !arr.length) return 0; return arr.reduce((s,x)=>s+(+x||0),0)/arr.length; }
function maxAbs(arr){ if(!arr || !arr.length) return 0; let m=0; arr.forEach(x=>{ const a=Math.abs(+x||0); if(a>m) m=a; }); return m; }

function lowPass(prev, curr, dt, fc){
  const rc = 1.0 / (2 * Math.PI * fc);
  const alpha = dt / (rc + dt);
  return prev + alpha * (curr - prev);
}
function cascadedLowPass(x, stages, dt, fc){
  let y=x;
  for(let i=0;i<stages.length;i++){
    stages[i]=lowPass(stages[i], y, dt, fc);
    y=stages[i];
  }
  return y;
}

function idxOf(joint, side){
  const k = `${joint}_${side}`;
  return KP[k] ?? null;
}
function unwrapAngleRad(curr, prev){
  let d = curr - prev;
  if(d > Math.PI) curr -= 2*Math.PI;
  if(d < -Math.PI) curr += 2*Math.PI;
  return curr;
}

/* =========================
   Angles / œâ (Kalman)
========================= */
function getJointAngleRad(kp, joint, side){
  const minScore=0.30;
  let a=null,b=null,c=null;

  if(joint==="elbow"){ a=idxOf("shoulder",side); b=idxOf("elbow",side); c=idxOf("wrist",side); }
  else if(joint==="knee"){ a=idxOf("hip",side); b=idxOf("knee",side); c=idxOf("ankle",side); }
  else if(joint==="hip"){ a=idxOf("shoulder",side); b=idxOf("hip",side); c=idxOf("knee",side); }
  else if(joint==="shoulder"){ a=idxOf("hip",side); b=idxOf("shoulder",side); c=idxOf("elbow",side); }
  else return NaN;

  const pA=kp[a], pB=kp[b], pC=kp[c];
  if(!pA||!pB||!pC) return NaN;
  if(pA.score<minScore||pB.score<minScore||pC.score<minScore) return NaN;

  const rad =
    Math.atan2(pC.y - pB.y, pC.x - pB.x) -
    Math.atan2(pA.y - pB.y, pA.x - pB.x);

  let ang = Math.abs(rad);
  if(ang > Math.PI) ang = 2*Math.PI - ang;
  return ang;
}
function getSegmentOrientationRad(kp, seg, side){
  const minScore=0.30;
  let a=null,b=null;
  if(seg==="forearm"){ a=idxOf("elbow",side); b=idxOf("wrist",side); }
  else if(seg==="shank"){ a=idxOf("knee",side); b=idxOf("ankle",side); }
  else return NaN;

  const pA=kp[a], pB=kp[b];
  if(!pA||!pB) return NaN;
  if(pA.score<minScore||pB.score<minScore) return NaN;

  return Math.atan2(pB.y - pA.y, pB.x - pA.x);
}
function getFilteredAngleAndOmega(key, rawRad, dt){
  if(!isFinite(rawRad) || dt<=0) return {angleFilt:0, omegaFilt:0};

  const st = angleState.get(key) || {prevRad: rawRad, prevFiltRad: rawRad};
  const rawUnwrapped = unwrapAngleRad(rawRad, st.prevRad);

  const {Q:Qa, R:Ra} = kalmanParamsFor("angle");
  const angleFilt = kalman1D(`kal_angle_${key}`, rawUnwrapped, Qa, Ra);

  const omegaRaw = (angleFilt - st.prevFiltRad) / Math.max(1e-4, dt);
  const {Q:Qw, R:Rw} = kalmanParamsFor("angVel");
  const omegaFilt = kalman1D(`kal_omega_${key}`, omegaRaw, Qw, Rw);

  st.prevRad = rawUnwrapped;
  st.prevFiltRad = angleFilt;
  angleState.set(key, st);

  return {angleFilt, omegaFilt};
}
function getLinearVelMpsRaw(kp, joint, side, dt){
  if(!prevKeypoints) return 0;
  const idx=idxOf(joint, side);
  if(idx==null) return 0;
  const curr=kp[idx], prev=prevKeypoints[idx];
  if(!curr||!prev||curr.score<0.30||prev.score<0.30) return 0;
  const s=getPxToMeter();
  const dx=(curr.x-prev.x)*s;
  const dy=(curr.y-prev.y)*s;
  return Math.hypot(dx,dy)/Math.max(1e-4, dt);
}

/* =========================
   Projectile speed (Kalman)
========================= */
function computeProjectileSpeed(projs){
  const out={speed:0, speedRaw:0, has:false};
  if(!projs||!projs.length){ prevProjState=null; return out; }
  out.has=true;

  const [x,y,w,h]=projs[0].bbox;
  const cx=x+w/2, cy=y+h/2;
  const s=getPxToMeter();
  const xM=cx*s, yM=cy*s;

  const fps = Math.max(1, detectedFPS || parseInt(document.getElementById("fpsSelection").value) || 60);
  const dt=1/fps;

  let sp=0;
  if(prevProjState){
    const vx=(xM-prevProjState.x)/dt;
    const vy=(yM-prevProjState.y)/dt;
    sp=Math.hypot(vx,vy);
  }
  prevProjState={x:xM,y:yM};
  out.speedRaw=sp;

  const {Q,R} = kalmanParamsFor("proj");
  out.speed = kalman1D("kal_proj_speed", sp, Q, R);
  return out;
}

/* =========================
   Driver kinematics (Kalman)
========================= */
function computeDriverKinematics(kp, plane){
  const jName=document.getElementById("kinJoint").value;
  const side=document.getElementById("kinSide").value;

  const fpsUsed = Math.max(1, detectedFPS || parseInt(document.getElementById("fpsSelection").value) || 60);
  const dt = 1/fpsUsed;

  let angleRadRaw=0;
  let angleKey=`driver_${jName}_${side}`;

  if(jName==="wrist"){
    const ori = getSegmentOrientationRad(kp, "forearm", side);
    angleRadRaw = isFinite(ori) ? ori : 0;
    angleKey=`driver_seg_forearm_${side}`;
  } else if(jName==="ankle"){
    const ori = getSegmentOrientationRad(kp, "shank", side);
    angleRadRaw = isFinite(ori) ? ori : 0;
    angleKey=`driver_seg_shank_${side}`;
  } else {
    const ang = getJointAngleRad(kp, jName, side);
    angleRadRaw = isFinite(ang) ? ang : 0;
    angleKey=`driver_joint_${jName}_${side}`;
  }

  const {angleFilt, omegaFilt} = getFilteredAngleAndOmega(angleKey, angleRadRaw, dt);

  const baseJoint = (jName==="wrist") ? "wrist" : (jName==="ankle" ? "ankle" : jName);
  const linRaw = getLinearVelMpsRaw(kp, baseJoint, side, dt);
  const {Q:Qv,R:Rv} = kalmanParamsFor("linVel");
  const linVel = kalman1D(`kal_driver_lin_${baseJoint}_${side}`, linRaw, Qv, Rv);

  driverDisp += Math.abs(linVel) * dt;

  return {
    driver: `${jName}_${side}`,
    linVel,
    angleRad: angleFilt,
    angVel: omegaFilt,
    disp: driverDisp,
    fpsUsed,
    plane
  };
}

/* =========================
   Driver kinetics (low-pass)
========================= */
function computeDriverKinetics(kin){
  if(!currentParticipant || !kin) return {forceN:0, momentNm:0};

  const hz=parseFloat(document.getElementById("cutoffHz").value);
  const dt=1/Math.max(1, kin.fpsUsed);

  const driverJoint = kin.driver.split("_")[0];

  let seg="thigh";
  if(driverJoint==="knee") seg="shank";
  if(driverJoint==="ankle") seg="foot";
  if(driverJoint==="shoulder") seg="upperArm";
  if(driverJoint==="elbow") seg="forearm";
  if(driverJoint==="wrist") seg="hand";

  const segMass = currentParticipant.mass * (SEG_MASS[seg] || 0.10);

  const prevV = rec.driver_linVel.length ? rec.driver_linVel[rec.driver_linVel.length-1] : kin.linVel;
  const accel = Math.abs(kin.linVel - prevV) / Math.max(1e-4, dt);
  const forceRaw = segMass * accel;

  const prevW = rec.driver_angVel.length ? rec.driver_angVel[rec.driver_angVel.length-1] : kin.angVel;
  const alpha = (kin.angVel - prevW) / Math.max(1e-4, dt);

  const L = estimateSegmentLengthM(seg);
  const k = SEG_K[seg] || 0.30;
  const I = segMass * Math.pow(k * L, 2);
  const momentRaw = I * alpha;

  const forceN = cascadedLowPass(forceRaw, forceStages, dt, hz);
  const momentNm = cascadedLowPass(momentRaw, momentStages, dt, hz);

  return { forceN, momentNm };
}
function estimateSegmentLengthM(seg){
  const h = currentParticipant ? (currentParticipant.height/100) : 1.75;
  const frac = { thigh:0.245, shank:0.246, foot:0.152, upperArm:0.186, forearm:0.146, hand:0.108, trunk:0.288 };
  return h * (frac[seg] || 0.20);
}

/* =========================
   Contact / takeoff / landing proxies
   - Uses ankle vertical velocity + ankle height + impact proxy
========================= */
function ankleY_m(kp, side){
  const idx = idxOf("ankle", side);
  if(idx==null) return 0;
  const p=kp[idx];
  if(!p || p.score<0.30) return 0;
  return p.y * getPxToMeter();
}
function ankleVy_up_mps(kp, side, fps){
  const dt=1/Math.max(1,fps);
  const y=ankleY_m(kp, side); // y down
  const nR = (side==="R") ? rec.ankleR_y_m.length : rec.ankleL_y_m.length;
  if(nR<1) return 0;
  const prev = (side==="R") ? rec.ankleR_y_m[nR-1] : rec.ankleL_y_m[nR-1];
  const vyDown = (y - prev)/Math.max(1e-4, dt);
  const vyUp = -vyDown; // up positive
  const {Q,R}=kalmanParamsFor("foot");
  return kalman1D(`kal_ankleVy_${side}`, vyUp, Q, R);
}
function ankleSpeed_mps(kp, side, fps){
  const dt=1/Math.max(1,fps);
  const raw = getLinearVelMpsRaw(kp, "ankle", side, dt);
  const {Q,R}=kalmanParamsFor("linVel");
  return kalman1D(`kal_ankleSpeed_${side}`, raw, Q, R);
}
function computeFootContactSignals(kp, fps, kinets){
  const yR = ankleY_m(kp,"R");
  const yL = ankleY_m(kp,"L");
  const vyR = ankleVy_up_mps(kp,"R",fps);
  const vyL = ankleVy_up_mps(kp,"L",fps);

  const spR = ankleSpeed_mps(kp,"R",fps);
  const spL = ankleSpeed_mps(kp,"L",fps);
  const anklePeakSpeed = Math.max(spR, spL);

  // impact proxy: force spike + ankle decel + near-ground condition (ankle y is large in image => closer to bottom)
  const yMaxApprox = Math.max(yR,yL);
  const yScale = Math.max(1e-6, maxAbs([yR,yL])); // local scaling
  const nearGround = (yMaxApprox > 0.65 * (overlay.height * getPxToMeter())); // near bottom of frame
  const prevAnkleSpeed = rec.ankle_peakSpeed_mps.length ? rec.ankle_peakSpeed_mps[rec.ankle_peakSpeed_mps.length-1] : anklePeakSpeed;
  const dt = 1/Math.max(1,fps);
  const ankleDecel = Math.max(0, (prevAnkleSpeed - anklePeakSpeed) / Math.max(1e-4, dt));

  const impactProxy = (kinets.forceN||0) * (nearGround ? 1.0 : 0.6) + ankleDecel * 10.0;

  return { yR, yL, vyR, vyL, anklePeakSpeed, impactProxy, nearGround };
}

/* =========================
   Selected metrics
========================= */
function unitsFor(def){
  if(def.type==="linVel") return "[m/s]";
  if(def.type==="angVel") return "[rad/s]";
  if(def.type==="angle") return "[rad]";
  return "";
}
function processSelectedMetrics(kp){
  selectedMetrics.forEach(m=>{
    const v = computeMetricValueFiltered(kp, m);
    const el=document.getElementById(`val_${m.id}`);
    if(el) el.innerText = isFinite(v) ? v.toFixed(3) : "--";
  });
}
function computeMetricValueFiltered(kp, m){
  const side=m.side;
  const fpsUsed = Math.max(1, detectedFPS || parseInt(document.getElementById("fpsSelection").value) || 60);
  const dt = 1/fpsUsed;

  if(m.type==="linVel"){
    const baseJoint = (m.joint==="wrist") ? "wrist" : (m.joint==="ankle" ? "ankle" : m.joint);
    const raw = getLinearVelMpsRaw(kp, baseJoint, side, dt);
    const {Q,R} = kalmanParamsFor("linVel");
    return kalman1D(`kal_m_lin_${baseJoint}_${side}`, raw, Q, R);
  }

  if(m.type==="angle" || m.type==="angVel"){
    let rawRad=0;
    let key=`m_${m.joint}_${side}`;
    if(m.joint==="wrist"){
      const ori=getSegmentOrientationRad(kp,"forearm",side);
      rawRad=isFinite(ori)?ori:0;
      key=`m_seg_forearm_${side}`;
    } else if(m.joint==="ankle"){
      const ori=getSegmentOrientationRad(kp,"shank",side);
      rawRad=isFinite(ori)?ori:0;
      key=`m_seg_shank_${side}`;
    } else {
      const ang=getJointAngleRad(kp,m.joint,side);
      rawRad=isFinite(ang)?ang:0;
      key=`m_joint_${m.joint}_${side}`;
    }

    const {angleFilt, omegaFilt} = getFilteredAngleAndOmega(key, rawRad, dt);
    return (m.type==="angle") ? angleFilt : omegaFilt;
  }

  return 0;
}

/* =========================
   Rolling kinetics + chart
========================= */
function pushRollingKinetics(kinets, fpsUsed){
  const dt=1/Math.max(1, fpsUsed);
  const t = rolling.t.length ? rolling.t[rolling.t.length-1] + dt : 0;
  rolling.t.push(t);
  rolling.force.push(kinets.forceN||0);
  rolling.moment.push(kinets.momentNm||0);

  const WIN=20;
  while(rolling.t.length && rolling.t[0] < t - WIN){
    rolling.t.shift(); rolling.force.shift(); rolling.moment.shift();
  }
}
function drawChartsThrottled(){
  const now=performance.now()/1000;
  if(now-chartLastDraw < 0.10) return;
  chartLastDraw=now;
  drawDualAxisChart("chartDual", rolling.t, rolling.force, rolling.moment);
}
function drawDualAxisChart(canvasId, tArr, fArr, mArr){
  const c=document.getElementById(canvasId);
  const g=c.getContext("2d");
  const w=c.width=c.clientWidth;
  const h=c.height=c.clientHeight;

  g.clearRect(0,0,w,h);
  g.strokeStyle="#eee";
  g.beginPath(); g.moveTo(0,h/2); g.lineTo(w,h/2); g.stroke();

  if(tArr.length<2) return;
  const tMin=tArr[0], tMax=tArr[tArr.length-1];
  const fMax=Math.max(1, maxAbs(fArr));
  const mMax=Math.max(1e-6, maxAbs(mArr));

  g.strokeStyle="#667eea"; g.lineWidth=2; g.beginPath();
  for(let i=0;i<tArr.length;i++){
    const x=((tArr[i]-tMin)/(tMax-tMin))*w;
    const y=h-((fArr[i]/(fMax*1.2))*(h/2)+h/2);
    if(i===0) g.moveTo(x,y); else g.lineTo(x,y);
  }
  g.stroke();

  g.strokeStyle="#ef4444"; g.lineWidth=2; g.beginPath();
  for(let i=0;i<tArr.length;i++){
    const x=((tArr[i]-tMin)/(tMax-tMin))*w;
    const y=h-((mArr[i]/(mMax*1.2))*(h/2)+h/2);
    if(i===0) g.moveTo(x,y); else g.lineTo(x,y);
  }
  g.stroke();

  g.fillStyle="#666";
  g.font="12px system-ui";
  g.fillText("Force [N] (blue)", 10, 14);
  const txt="Moment [Nm] (red)";
  g.fillText(txt, w - g.measureText(txt).width - 10, 14);
}

/* =========================
   Kinematics selector UI
========================= */
function addMetric(){
  const type=document.getElementById('metricType').value;
  const joint=document.getElementById('metricJoint').value;
  const side=document.getElementById('metricSide').value;
  const id=`${type}_${joint}_${side}`;
  if(!selectedMetrics.find(m=>m.id===id)){
    selectedMetrics.push({id,type,joint,side});
    renderMetricChips();
  }
}
function removeMetric(id){ selectedMetrics=selectedMetrics.filter(m=>m.id!==id); renderMetricChips(); }
function clearMetrics(){ selectedMetrics=[]; renderMetricChips(); }
function metricHint(m){
  if(m.type==="linVel") return "Kalman-filtered linear velocity [m/s].";
  if(m.type==="angVel") return "Kalman-filtered angular velocity [rad/s] derived from filtered angle.";
  if(m.type==="angle") return "Kalman-filtered angle [rad].";
  return "";
}
function renderMetricChips(){
  const chips=document.getElementById('metricChips');
  const panel=document.getElementById('selectedMetricsPanel');
  chips.innerHTML=""; panel.innerHTML="";
  selectedMetrics.forEach(m=>{
    const unit = unitsFor(m);
    const label = `${m.type} ${m.joint} ${m.side} ${unit}`;
    const chip=document.createElement('div');
    chip.className="chip";
    chip.innerHTML=`${label} <button onclick="removeMetric('${m.id}')">‚úï</button>`;
    chips.appendChild(chip);

    const card=document.createElement('div');
    card.className="metric";
    card.innerHTML=`
      <div class="t">${label}</div>
      <div class="v" id="val_${m.id}">--</div>
      <div class="s">${metricHint(m)}</div>
    `;
    panel.appendChild(card);
  });
}

/* =========================
   Recording
========================= */
function toggleRecording(){
  const btn=document.getElementById("recordBtn");
  if(!isRecording){
    if(!currentParticipant) return showStatus("Set a participant first.", "error");

    isRecording=true;
    rec=resetRec();
    rec.fpsUsed = Math.max(1, detectedFPS || parseInt(document.getElementById("fpsSelection").value) || 60);
    rec.driver = `${document.getElementById("kinJoint").value}_${document.getElementById("kinSide").value}`;
    rec.plane = document.getElementById("motionPlane").value;

    rec.metricsDefs = selectedMetrics.map(m=>({ ...m, units: unitsFor(m) }));
    rec.metrics = {};
    rec.metricsDefs.forEach(m=> rec.metrics[m.id]=[]);

    angleState.clear();
    driverDisp=0;
    prevProjState=null;
    forceStages=new Array(FILTER_ORDER).fill(0);
    momentStages=new Array(FILTER_ORDER).fill(0);
    kf.clear();

    btn.textContent="Stop Recording";
    btn.className="btn btn-danger";
    showStatus("Recording started...", "info");
    setStatusText("Recording...");
  } else {
    isRecording=false;
    btn.textContent="Start Recording";
    btn.className="btn btn-success";
    showStatus(`Recording saved. ${rec.n} samples.`, "success");
    setStatusText("Running");
  }
}
function recordSample(kp, kin, kinets, proj, plane, feet){
  const i = rec.n;
  const t = i / rec.fpsUsed;

  rec.t.push(t);
  rec.forceN.push(kinets.forceN||0);
  rec.momentNm.push(kinets.momentNm||0);

  rec.driver_linVel.push(kin.linVel||0);
  rec.driver_angVel.push(kin.angVel||0);
  rec.driver_angle.push(kin.angleRad||0);
  rec.driver_disp.push(kin.disp||0);

  rec.proj_speed.push(proj.speed||0);

  // contact series
  rec.ankleR_y_m.push(feet.yR||0);
  rec.ankleL_y_m.push(feet.yL||0);
  rec.ankleR_vy_up_mps.push(feet.vyR||0);
  rec.ankleL_vy_up_mps.push(feet.vyL||0);
  rec.ankle_peakSpeed_mps.push(feet.anklePeakSpeed||0);
  rec.ankle_impact_proxy.push(feet.impactProxy||0);

  // COM proxy (mid-hip upward velocity)
  const midHip = getMidHipY_m(kp);
  const midHipVy = computeMidHipVy(midHip, rec.fpsUsed);
  rec.midHipY_m.push(midHip);
  rec.midHipVy_mps.push(midHipVy);

  // selected metrics
  rec.metricsDefs.forEach(def=>{
    const v = computeMetricValueFiltered(kp, def);
    rec.metrics[def.id].push(isFinite(v)?v:0);
  });

  // extra angles/orientations
  rec.shoulderAng_R.push(safeAngle(kp,"shoulder","R"));
  rec.shoulderAng_L.push(safeAngle(kp,"shoulder","L"));
  rec.elbowAng_R.push(safeAngle(kp,"elbow","R"));
  rec.elbowAng_L.push(safeAngle(kp,"elbow","L"));
  rec.hipAng_R.push(safeAngle(kp,"hip","R"));
  rec.hipAng_L.push(safeAngle(kp,"hip","L"));
  rec.kneeAng_R.push(safeAngle(kp,"knee","R"));
  rec.kneeAng_L.push(safeAngle(kp,"knee","L"));

  rec.ankleOri_R.push(safeOri(kp,"shank","R"));
  rec.ankleOri_L.push(safeOri(kp,"shank","L"));
  rec.wristOri_R.push(safeOri(kp,"forearm","R"));
  rec.wristOri_L.push(safeOri(kp,"forearm","L"));

  rec.n++;
}
function safeAngle(kp,j,s){ const a=getJointAngleRad(kp,j,s); return isFinite(a)?a:0; }
function safeOri(kp,seg,s){ const o=getSegmentOrientationRad(kp,seg,s); return isFinite(o)?o:0; }

function getMidHipY_m(kp){
  const s=getPxToMeter();
  const hl=kp[KP.hip_L], hr=kp[KP.hip_R];
  if(hl?.score>0.30 && hr?.score>0.30){
    const yPx=(hl.y+hr.y)/2;
    return yPx*s;
  }
  if(hl?.score>0.30) return hl.y*s;
  if(hr?.score>0.30) return hr.y*s;
  return 0;
}
function computeMidHipVy(y, fps){
  const n=rec.midHipY_m.length;
  if(n<1) return 0;
  const dt=1/Math.max(1,fps);
  const prev=rec.midHipY_m[n-1];
  const vyRaw=(y-prev)/Math.max(1e-4,dt);
  const vyUp = -vyRaw;
  const {Q,R}=kalmanParamsFor("linVel");
  return kalman1D("kal_midHipVy", vyUp, Q, R);
}

/* =========================
   Skill inference (now contact-aware)
========================= */
function inferSkillLive(kp, proj, feet){
  const fps = Math.max(1, detectedFPS || 60);
  const dt = 1/fps;

  const vW_R = getLinearVelMpsRaw(kp,"wrist","R",dt);
  const vW_L = getLinearVelMpsRaw(kp,"wrist","L",dt);
  const vA_R = getLinearVelMpsRaw(kp,"ankle","R",dt);
  const vA_L = getLinearVelMpsRaw(kp,"ankle","L",dt);

  const armV = Math.max(vW_R, vW_L);
  const legV = Math.max(vA_R, vA_L);

  let scores = {Pitching:0, Throwing:0, Kicking:0, Jumping:0};

  if(proj?.has && proj.speed>0.5){ scores.Throwing += 1.0; scores.Pitching += 1.0; }
  if(armV > legV*1.15){ scores.Throwing += 0.7; scores.Pitching += 0.7; }
  if(legV > armV*1.15){ scores.Kicking += 1.2; }

  // jump: upward COM + impact proxy later (helps separate from kick when no projectile)
  const midHipVy = computeMidHipVy(getMidHipY_m(kp), fps);
  if(midHipVy > 0.6 && !proj?.has){ scores.Jumping += 1.1; }
  if(feet?.impactProxy > 30 && midHipVy < 0.2 && !proj?.has){ scores.Kicking += 0.3; } // impact without big COM lift

  // pitching vs throwing tweak
  const elbowR = safeAngle(kp,"elbow","R");
  const elbowL = safeAngle(kp,"elbow","L");
  const shoulderR = safeAngle(kp,"shoulder","R");
  const shoulderL = safeAngle(kp,"shoulder","L");
  const armFlex = Math.max(elbowR, elbowL);
  const shAng = Math.max(shoulderR, shoulderL);
  if(scores.Pitching>0 || scores.Throwing>0){
    if(armFlex < 1.3 && shAng > 0.9) scores.Pitching += 0.4;
    else scores.Throwing += 0.3;
  }

  let best="Throwing", bestV=-1;
  Object.entries(scores).forEach(([k,v])=>{ if(v>bestV){ bestV=v; best=k; }});
  const conf = clamp(bestV/2.6, 0, 1);
  return {skill: best, conf, scores};
}

function hasProjectile(rec){ return maxAbs(rec.proj_speed) > 0.8; }

function classifySkill(rec){
  const n=rec.n;
  if(n<20) return {skill:"Unknown", confidence:0.0, evidence:{}};

  const peakProj = maxAbs(rec.proj_speed);
  const peakVy = maxAbs(rec.midHipVy_mps);

  const peakShoulder = Math.max(maxAbs(rec.shoulderAng_R), maxAbs(rec.shoulderAng_L));
  const peakElbow = Math.max(maxAbs(rec.elbowAng_R), maxAbs(rec.elbowAng_L));
  const peakHip = Math.max(maxAbs(rec.hipAng_R), maxAbs(rec.hipAng_L));
  const peakKnee = Math.max(maxAbs(rec.kneeAng_R), maxAbs(rec.kneeAng_L));

  const peakAnkleSpeed = maxAbs(rec.ankle_peakSpeed_mps);
  const peakImpact = maxAbs(rec.ankle_impact_proxy);

  const jumpScore =
    (peakVy>0.8 ? 1.2 : 0) +
    (!hasProjectile(rec) ? 0.6 : 0) +
    ((peakKnee>0.9 && peakHip>0.7) ? 0.5 : 0) +
    ((peakImpact>25) ? 0.25 : 0);

  const kickScore =
    ((peakKnee>0.9 && peakHip>0.7) ? 1.0 : 0.3) +
    ((peakAnkleSpeed>1.5) ? 0.7 : 0.1) +
    ((peakImpact>25) ? 0.5 : 0.0) +
    ((hasProjectile(rec) && peakProj>2.0) ? 0.2 : 0);

  const throwScore =
    (hasProjectile(rec) ? 1.0 : 0.2) +
    ((peakShoulder>0.9 || peakElbow>0.9) ? 0.7 : 0.2);

  const pitchScore =
    (hasProjectile(rec) ? 1.0 : 0.0) +
    ((peakShoulder>0.9) ? 0.6 : 0.2) +
    ((peakElbow<1.2) ? 0.4 : 0.1) +
    ((peakProj>3.0) ? 0.5 : 0.1);

  const scores = {Jumping:jumpScore, Kicking:kickScore, Throwing:throwScore, Pitching:pitchScore};

  let best="Throwing", bestV=-1, total=0;
  Object.values(scores).forEach(v=> total+=v);
  Object.entries(scores).forEach(([k,v])=>{ if(v>bestV){ bestV=v; best=k; }});

  const confidence = clamp(bestV/Math.max(1e-6, total), 0, 1);
  return {
    skill: best,
    confidence,
    evidence: {peakProj, peakVy, peakShoulder, peakElbow, peakHip, peakKnee, peakAnkleSpeed, peakImpact, scores}
  };
}

/* =========================
   Event segmentation (skill-aware, with contact proxies)
========================= */
function argMax(arr){
  let best=0, bestV=-1;
  for(let i=0;i<(arr||[]).length;i++){
    const v=+arr[i]||0;
    if(v>bestV){ bestV=v; best=i; }
  }
  return best;
}
function argMaxAbs(arr){
  let best=0, bestV=-1;
  for(let i=0;i<(arr||[]).length;i++){
    const v=Math.abs(+arr[i]||0);
    if(v>bestV){ bestV=v; best=i; }
  }
  return best;
}
function clampInt(x,a,b){ return Math.max(a, Math.min(b, Math.round(x))); }

function segmentPhasesSkillAware(skill){
  const n=rec.n;
  if(n<10) return [{name:"Full", i0:0, i1:n-1, markers:"‚Äî"}];

  const w1 = Math.max(3, Math.floor(n*0.12));
  const w2 = Math.max(3, Math.floor(n*0.10));

  // Default markers (throw/pitch)
  let markerA = argMax(rec.proj_speed);        // "release/contact" for projectile
  let markerB = argMaxAbs(rec.driver_angVel);  // peak œâ

  // Kick: use peak ankle speed and impact proxy
  if(skill==="Kicking"){
    markerA = argMax(rec.ankle_peakSpeed_mps);         // contact-ish
    markerB = argMax(rec.ankle_impact_proxy);          // impact spike
    // keep them close by blending if wildly apart
    if(Math.abs(markerA-markerB) > Math.floor(n*0.15)){
      markerA = Math.round((markerA+markerB)/2);
      markerB = markerA;
    }
  }

  // Jump: use takeoff (peak upward COM velocity) and landing (impact proxy peak after takeoff)
  if(skill==="Jumping"){
    const takeoff = argMax(rec.midHipVy_mps);
    // landing: search impact peak after takeoff+10% duration
    const start = clampInt(takeoff + Math.floor(n*0.10), 0, n-1);
    let landIdx = start;
    let bestV = -1;
    for(let i=start;i<n;i++){
      const v = rec.ankle_impact_proxy[i]||0;
      if(v>bestV){ bestV=v; landIdx=i; }
    }
    markerB = takeoff;  // acceleration marker
    markerA = landIdx;  // contact marker
  }

  const accel0 = clampInt(Math.min(markerA, markerB) - w1, 0, n-1);
  const accel1 = clampInt(Math.min(markerA, markerB) + w1, 0, n-1);

  const contact0 = clampInt(markerA - w2, 0, n-1);
  const contact1 = clampInt(markerA + w2, 0, n-1);

  const markerLabel =
    (skill==="Pitching"||skill==="Throwing")
      ? `peakœâ@${markerB}, peakVproj@${markerA}`
      : (skill==="Kicking")
        ? `peakAnkleSpeed@${markerA}, peakImpact@${markerB}`
        : (skill==="Jumping")
          ? `takeoff(peakCOMVy)@${markerB}, landing(impact)@${markerA}`
          : `markerA@${markerA}, markerB@${markerB}`;

  return [
    {name:"Preparation", i0:0, i1:Math.max(0, accel0-1), markers: markerLabel},
    {name:"Acceleration", i0:accel0, i1:accel1, markers: markerLabel},
    {name:(skill==="Jumping" ? "Takeoff/Landing Window" : "Release/Contact"), i0:contact0, i1:contact1, markers: markerLabel},
    {name:"Follow-through", i0:Math.min(n-1, contact1+1), i1:n-1, markers:"‚Äî"},
  ];
}

/* =========================
   Push-like vs Throw-like pattern (unchanged)
========================= */
function classifyPattern(globalStats){
  const peakW = globalStats.peakW;
  const peakProj = globalStats.peakProj;
  const peakV = globalStats.peakV;
  const peakF = globalStats.peakF;

  const wIndex = (peakW>1e-6) ? (peakProj/peakW) : 0;
  const vIndex = (peakV>1e-6) ? (peakProj/peakV) : 0;
  const fIndex = (peakF>1e-6) ? (peakProj/peakF) : 0;

  let pattern="Throw-like";
  let rationale=[];
  if(peakW < 2.0 && peakV > 1.2){
    pattern="Push-like";
    rationale.push("Low rotational speed (œâ) with higher translational velocity suggests push-dominant strategy.");
  } else {
    rationale.push("Meaningful œâ suggests rotational/whip contribution (throw-like).");
  }
  rationale.push(`Transfer indices: proj/œâ=${wIndex.toFixed(3)}, proj/v=${vIndex.toFixed(3)}, proj/F=${fIndex.toFixed(6)}.`);
  return {pattern, rationale: rationale.join(" ")};
}

/* =========================
   Recommendations (skill-aware)
========================= */
function skillTemplates(skill){
  const base = {
    sequencing: "Aim for proximal-to-distal sequencing: load (hips/trunk) ‚Üí accelerate ‚Üí transfer to distal segment ‚Üí release/contact ‚Üí controlled deceleration.",
    stiffness: "Maintain trunk control and stiffness at transfer to reduce energy leaks.",
    ecc: "Include eccentric deceleration work (posterior chain / scapular / hip) to reduce joint loading in follow-through."
  };
  if(skill==="Pitching"){
    return {
      focus: "Pitching model: trunk rotation + shoulder arc timing + late whip into release.",
      cues: [
        "Avoid early arm-dominant spin-up.",
        "Time peak œâ closer to release while keeping trunk stable.",
        "Use stride/hip-shoulder separation before rapid arm acceleration."
      ],
      training: [
        "Med-ball rotational throws, step-behind throws.",
        "Scapular stability + rotator cuff endurance.",
        "Eccentric posterior shoulder + trunk anti-rotation."
      ],
      base
    };
  }
  if(skill==="Throwing"){
    return {
      focus: "Throwing model: coordinated trunk + arm whip, efficient energy transfer to projectile.",
      cues: [
        "Load with trunk/hips before arm acceleration.",
        "Keep trunk stable; avoid collapsing/side-bending at release.",
        "Follow-through to dissipate energy safely."
      ],
      training: [
        "Med-ball chest/overhead/rotational throws.",
        "Plyometric push-ups / banded punches.",
        "Eccentric decel + trunk control."
      ],
      base
    };
  }
  if(skill==="Kicking"){
    return {
      focus: "Kicking model: hip drive + late knee extension whip + stiff ankle at contact.",
      cues: [
        "Avoid early knee extension (reduces whip).",
        "Stabilize pelvis/trunk to reduce energy loss.",
        "Contact: stiff ankle and align COM for clean transfer."
      ],
      training: [
        "Hip power (step-ups, split squats, hip drives).",
        "Technique: late snap drills (light band).",
        "Core + single-leg stability (lateral hip strength)."
      ],
      base
    };
  }
  if(skill==="Jumping"){
    return {
      focus: "Jumping model: rapid eccentric ‚Üí concentric SSC with triple extension; controlled landing.",
      cues: [
        "Avoid knee collapse and trunk drop in countermovement.",
        "Explode through triple extension; maintain stiffness on takeoff.",
        "Land softly with controlled eccentric absorption."
      ],
      training: [
        "CMJ / pogo hops (progressive).",
        "Squat jumps / trap-bar jumps.",
        "Eccentric strength + landing mechanics."
      ],
      base
    };
  }
  return {
    focus: "General model: load ‚Üí accelerate ‚Üí transfer ‚Üí release/contact ‚Üí decelerate.",
    cues: [base.sequencing, base.stiffness, base.ecc],
    training: ["Technique reps", "Strength base + power progressions", "Eccentric decel + trunk control"],
    base
  };
}

function buildPhaseRecommendation(skill, phaseName, stats, global){
  const recs=[];
  const flags=[];

  const LOW_ANG = 0.6;      // rad
  const LOW_W = 2.0;        // rad/s
  const LOW_PROJ = 2.0;     // m/s

  const isThrowFamily = (skill==="Pitching" || skill==="Throwing");
  const isKick = (skill==="Kicking");
  const isJump = (skill==="Jumping");

  if(phaseName==="Preparation"){
    if(stats.peakAngle < LOW_ANG){
      flags.push("Low ROM");
      recs.push(isJump ? "Increase countermovement ROM with alignment." : "Increase controlled wind-up ROM (load smoothly).");
    }
  }

  if(phaseName==="Acceleration"){
    if(isThrowFamily){
      if(stats.peakW < LOW_W && stats.peakProj > LOW_PROJ){
        flags.push("Push-like transfer");
        recs.push("Train rotational sequencing (hips/trunk ‚Üí arm) to increase œâ transfer.");
      }
    }
    if(isKick){
      if(stats.peakAnkleSpeed < 1.5){
        flags.push("Low distal speed");
        recs.push("Improve whip: hip drive then late knee extension; add technique reps + hip power.");
      }
    }
    if(isJump){
      if(stats.peakCOMVy < 0.8){
        flags.push("Low takeoff velocity");
        recs.push("Increase SSC efficiency: stiffness + rapid reversal; build strength-power base.");
      }
    }
  }

  if(phaseName.includes("Release") || phaseName.includes("Contact") || phaseName.includes("Takeoff")){
    if(isKick){
      if(stats.peakImpact > global.peakImpactAll*0.85 && stats.peakAnkleSpeed < global.peakAnkleSpeedAll*0.85){
        flags.push("High impact, low speed");
        recs.push("Contact inefficiency: check alignment and reduce braking before impact; improve ankle stiffness timing.");
      }
    }
    if(isJump){
      if(stats.peakImpact > global.peakImpactAll*0.90){
        flags.push("High landing load proxy");
        recs.push("Landing: add eccentric strength and cue softer absorption; avoid stiff/locked landing.");
      }
    }
    if(isThrowFamily){
      if(stats.peakF > global.peakFAll*0.85 && stats.peakProj < global.peakProjAll*0.85){
        flags.push("High force, low output");
        recs.push("Inefficiency near release: improve timing, trunk stiffness, and release mechanics.");
      }
    }
  }

  if(phaseName==="Follow-through"){
    if(stats.peakM > global.peakMAll*0.90){
      flags.push("High decel moment");
      recs.push("Add eccentric deceleration training + smooth follow-through to reduce joint stress.");
    }
  }

  if(global.plane==="frontal"){
    recs.push("Frontal view: monitor lateral sway and pelvic stability.");
  } else {
    recs.push("Sagittal view: monitor trunk collapse and braking; keep posture stacked.");
  }

  if(!recs.length){
    flags.push("No major flags");
    recs.push("Maintain current pattern; aim for smooth load ‚Üí acceleration ‚Üí clean transfer ‚Üí controlled follow-through.");
  }

  return { flags: flags.join("; "), recommendation: recs.join(" ") };
}

/* =========================
   XLSX Export (now uses contact-aware phases)
========================= */
function downloadData(){
  if(!rec.n) return showStatus("No recorded data.", "error");

  const skillRes = classifySkill(rec);
  const skill = skillRes.skill;

  const phases = segmentPhasesSkillAware(skill);

  const peakProjIdx = argMax(rec.proj_speed);
  const peakWIdx = argMaxAbs(rec.driver_angVel);
  const peakAnkleSpeedIdx = argMax(rec.ankle_peakSpeed_mps);
  const peakImpactIdx = argMax(rec.ankle_impact_proxy);
  const peakCOMVyIdx = argMax(rec.midHipVy_mps);

  const peakFAll = maxAbs(rec.forceN);
  const peakMAll = maxAbs(rec.momentNm);
  const peakProjAll = maxAbs(rec.proj_speed);
  const peakImpactAll = maxAbs(rec.ankle_impact_proxy);
  const peakAnkleSpeedAll = maxAbs(rec.ankle_peakSpeed_mps);

  const globalCtx = {
    plane: rec.plane,
    fps: rec.fpsUsed,
    peakFAll, peakMAll, peakProjAll,
    peakImpactAll, peakAnkleSpeedAll,
    markers: {peakProjIdx, peakWIdx, peakAnkleSpeedIdx, peakImpactIdx, peakCOMVyIdx}
  };

  const templates = skillTemplates(skill);

  const globalStats = {
    peakProj: peakProjAll,
    peakW: maxAbs(rec.driver_angVel),
    peakV: maxAbs(rec.driver_linVel),
    peakF: peakFAll
  };
  const patternRes = classifyPattern(globalStats);

  // Profile sheet
  const p=currentParticipant||{};
  const profileRows=[
    {field:"name", value:p.name||""},
    {field:"sex", value:p.sex||""},
    {field:"age", value:p.age||""},
    {field:"mass_kg", value:p.mass||""},
    {field:"height_cm", value:p.height||""},
    {field:"plane", value:rec.plane},
    {field:"driver", value:rec.driver},
    {field:"fps_used", value:rec.fpsUsed},
    {field:"samples", value:rec.n},
    {field:"skill_classification", value:`${skill} (conf ${skillRes.confidence.toFixed(2)})`},
    {field:"pattern", value:patternRes.pattern},
    {field:"pattern_rationale", value:patternRes.rationale},
    {field:"marker_peak_proj_speed_sample", value:peakProjIdx},
    {field:"marker_peak_driver_angVel_sample", value:peakWIdx},
    {field:"marker_peak_ankle_speed_sample", value:peakAnkleSpeedIdx},
    {field:"marker_peak_impact_proxy_sample", value:peakImpactIdx},
    {field:"marker_peak_COMVy_takeoff_sample", value:peakCOMVyIdx},
    {field:"notes", value:"Contact-aware segmentation: Throw/Pitch uses proj+œâ; Kick uses ankle speed+impact; Jump uses COMVy (takeoff)+impact (landing). Kinetics are proxy (camera-based)."}
  ];

  // Phase summary
  const rows=[];
  phases.forEach(ph=>{
    const sl = (arr)=> (arr||[]).slice(ph.i0, ph.i1+1);

    const driverV = sl(rec.driver_linVel);
    const driverW = sl(rec.driver_angVel);
    const driverA = sl(rec.driver_angle);
    const driverD = sl(rec.driver_disp);
    const projSp  = sl(rec.proj_speed);
    const fArr    = sl(rec.forceN);
    const mArr    = sl(rec.momentNm);

    const ankleSp = sl(rec.ankle_peakSpeed_mps);
    const impact  = sl(rec.ankle_impact_proxy);
    const comVy   = sl(rec.midHipVy_mps);

    const stats = {
      peakProj: maxAbs(projSp), avgProj: mean(projSp),
      peakW: maxAbs(driverW),   avgW: mean(driverW),
      peakAngle: maxAbs(driverA), avgAngle: mean(driverA),
      peakV: maxAbs(driverV),   avgV: mean(driverV),
      peakF: maxAbs(fArr),      avgF: mean(fArr),
      peakM: maxAbs(mArr),      avgM: mean(mArr),
      peakAnkleSpeed: maxAbs(ankleSp), avgAnkleSpeed: mean(ankleSp),
      peakImpact: maxAbs(impact), avgImpact: mean(impact),
      peakCOMVy: maxAbs(comVy), avgCOMVy: mean(comVy)
    };

    const recText = buildPhaseRecommendation(skill, ph.name, stats, globalCtx);

    const pushRow = (metric, avg, peak, flags="", recommendation="") => rows.push({
      phase: ph.name,
      markers: ph.markers || "",
      skill,
      metric,
      avg: round(avg, 6),
      peak: round(peak, 6),
      flags,
      recommendation
    });

    pushRow("driver_linVel [m/s]", mean(driverV), maxAbs(driverV));
    pushRow("driver_angVel [rad/s]", mean(driverW), maxAbs(driverW));
    pushRow("driver_angle [rad]", mean(driverA), maxAbs(driverA));
    pushRow("driver_disp [m]", mean(driverD), maxAbs(driverD));

    pushRow("projectile_speed [m/s]", mean(projSp), maxAbs(projSp));
    pushRow("ankle_peakSpeed [m/s]", mean(ankleSp), maxAbs(ankleSp));
    pushRow("impact_proxy [a.u.]", mean(impact), maxAbs(impact));
    pushRow("COMVy_up [m/s]", mean(comVy), maxAbs(comVy), recText.flags, recText.recommendation);

    pushRow("Force [N] (filtered)", mean(fArr), maxAbs(fArr));
    pushRow("Moment [Nm] (filtered)", mean(mArr), maxAbs(mArr));

    // selected metrics summary (all)
    rec.metricsDefs.forEach(def=>{
      const arr = sl(rec.metrics[def.id] || []);
      const unit = unitsFor(def);
      pushRow(`${def.type}_${def.joint}_${def.side} ${unit}`, mean(arr), maxAbs(arr));
    });
  });

  // TimeSeries
  const ts=[];
  for(let i=0;i<rec.n;i++){
    const r={
      sample: i,
      time_s: round(rec.t[i], 6),
      "Force[N](filt)": round(rec.forceN[i]||0, 6),
      "Moment[Nm](filt)": round(rec.momentNm[i]||0, 8),
      "driver_linVel[m/s](kal)": round(rec.driver_linVel[i]||0, 6),
      "driver_angVel[rad/s](kal)": round(rec.driver_angVel[i]||0, 6),
      "driver_angle[rad](kal)": round(rec.driver_angle[i]||0, 6),
      "driver_disp[m](int)": round(rec.driver_disp[i]||0, 6),
      "proj_speed[m/s](kal)": round(rec.proj_speed[i]||0, 6),
      "ankle_peakSpeed[m/s](kal)": round(rec.ankle_peakSpeed_mps[i]||0, 6),
      "impact_proxy[a.u.]": round(rec.ankle_impact_proxy[i]||0, 6),
      "COMVy_up[m/s](kal)": round(rec.midHipVy_mps[i]||0, 6),
      "ankleR_vy_up[m/s](kal)": round(rec.ankleR_vy_up_mps[i]||0, 6),
      "ankleL_vy_up[m/s](kal)": round(rec.ankleL_vy_up_mps[i]||0, 6),
    };

    rec.metricsDefs.forEach(def=>{
      const val = (rec.metrics[def.id] && rec.metrics[def.id][i]!=null) ? rec.metrics[def.id][i] : 0;
      if(def.type==="angle") r[`${def.id}[rad]`] = round(val, 6);
      else if(def.type==="angVel") r[`${def.id}[rad/s]`] = round(val, 6);
      else r[`${def.id}[m/s]`] = round(val, 6);
    });

    ts.push(r);
  }

  // Technical model
  const modelRows = buildTechnicalModelSheet(skillRes, templates, patternRes, phases, globalCtx);

  const wb=XLSX.utils.book_new();
  XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet(profileRows), "1_Profile");
  XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet(rows), "2_Phase_Summary");
  XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet(ts), "3_TimeSeries");
  XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet(modelRows), "4_Technical_Model");

  XLSX.writeFile(wb, `analysis_${(p.name||"participant").replace(/\s+/g,"_")}_${Date.now()}.xlsx`);
  showStatus("Exported XLSX (contact-aware phases + skill model).", "success");
}

function buildTechnicalModelSheet(skillRes, templates, patternRes, phases, globalCtx){
  const ev = skillRes.evidence || {};
  const m = globalCtx.markers || {};
  const rows = [];
  rows.push({section:"Skill Classification", item:"Skill", value:`${skillRes.skill}`});
  rows.push({section:"Skill Classification", item:"Confidence", value:`${skillRes.confidence.toFixed(2)}`});
  rows.push({section:"Skill Classification", item:"Evidence (peaks)", value:
    `proj=${(ev.peakProj||0).toFixed(3)} m/s, COMVy=${(ev.peakVy||0).toFixed(3)} m/s, ankleSpeed=${(ev.peakAnkleSpeed||0).toFixed(3)} m/s, impact=${(ev.peakImpact||0).toFixed(3)} a.u.`});
  rows.push({section:"Markers", item:"peak proj speed sample", value: `${m.peakProjIdx}`});
  rows.push({section:"Markers", item:"peak driver œâ sample", value: `${m.peakWIdx}`});
  rows.push({section:"Markers", item:"peak ankle speed sample", value: `${m.peakAnkleSpeedIdx}`});
  rows.push({section:"Markers", item:"peak impact proxy sample", value: `${m.peakImpactIdx}`});
  rows.push({section:"Markers", item:"takeoff (peak COMVy) sample", value: `${m.peakCOMVyIdx}`});

  rows.push({section:"Pattern", item:"Push vs Throw pattern", value:patternRes.pattern});
  rows.push({section:"Pattern", item:"Rationale", value:patternRes.rationale});

  rows.push({section:"Model", item:"Technical model focus", value:templates.focus});
  rows.push({section:"Model", item:"General sequencing", value:templates.base.sequencing});
  rows.push({section:"Model", item:"Stiffness & energy transfer", value:templates.base.stiffness});
  rows.push({section:"Model", item:"Deceleration", value:templates.base.ecc});

  rows.push({section:"Coaching Cues", item:"Key cues", value:templates.cues.join(" ")});
  rows.push({section:"Training", item:"Training recommendations", value:templates.training.join(" | ")});

  rows.push({section:"Phases", item:"Phase definition", value:"Contact-aware phases based on the classified skill. Throw/Pitch: peak projectile speed + peak œâ. Kick: peak ankle speed + impact proxy. Jump: takeoff via peak COMVy and landing via impact proxy."});
  phases.forEach(ph=>{
    rows.push({section:"Phases", item:ph.name, value:`Samples ${ph.i0}‚Äì${ph.i1} | markers: ${ph.markers || ""}`});
  });

  rows.push({section:"Warnings", item:"Measurement limits", value:"2D camera-based estimates depend on visibility, plane alignment, and pixel-to-meter scaling. Treat absolute kinetics as proxy; use trends + phase comparisons for decisions."});
  rows.push({section:"Warnings", item:"Plane", value:`Selected plane: ${globalCtx.plane}. Use sagittal for flex/extend patterns; frontal for lateral deviations.`});
  return rows;
}

/* =========================
   UI helpers
========================= */
function snapshotPNG(){
  if(!video || video.paused) return showStatus("Start Camera/Upload first.", "error");
  const c=document.createElement('canvas');
  const w=overlay.width, h=overlay.height;
  c.width=w; c.height=h;
  const g=c.getContext('2d');
  try{ g.drawImage(video,0,0,w,h); }catch(_){}
  try{ g.drawImage(overlay,0,0,w,h); }catch(_){}
  const a=document.createElement('a');
  a.href=c.toDataURL("image/png");
  a.download=`snapshot_${Date.now()}.png`;
  a.click();
}
function toggleCollapse(id){
  const el=document.getElementById(id);
  el.classList.toggle('collapsed');
  document.getElementById(id+'_lbl').innerText = el.classList.contains('collapsed') ? "Expand" : "Collapse";
}
function togglePiP(){ document.body.classList.toggle('pip-on'); }

function showStatus(msg,type){
  const el=document.getElementById('statusMessage');
  el.innerText=msg;
  el.className=`status-message status-${type}`;
  el.style.display='block';
  setTimeout(()=>el.style.display='none', 3000);
}
function setStatusText(t){ document.getElementById('statusText').innerText=t; }
function setSourceText(t){ document.getElementById('sourceText').innerText=t; }
</script>
</body>
</html>
