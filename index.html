<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <meta name="author" content="Ng Jun Wei">
  <meta name="copyright" content="¬© 2025 Ng Jun Wei. All rights reserved.">
  <title>Sport Performance Analyzer (iOS) + Joint-Driven Kinetics</title>

  <!-- TFJS + Pose -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.11.0"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@2.1.0"></script>

  <!-- Projectile (COCO-SSD) -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.3"></script>

  <!-- XLSX -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

  <style>
    * { margin:0; padding:0; box-sizing:border-box; }
    body{
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 14px;
      padding-bottom: 80px;
    }
    .container{
      max-width: 1400px;
      margin: 0 auto;
      background:#fff;
      border-radius: 18px;
      padding: 16px;
      box-shadow: 0 18px 55px rgba(0,0,0,0.22);
    }
    h1 { text-align:center; color:#667eea; margin-bottom:6px; font-size:2.05em; }
    .subtitle{ text-align:center; color:#666; margin-bottom:14px; font-size:1.02em; }

    .layout{
      display:grid;
      grid-template-columns: 1.08fr 0.92fr;
      gap: 14px;
      align-items:start;
    }
    @media (max-width: 980px){ .layout{ grid-template-columns: 1fr; } }

    .card{ background:#f8f9fa; border-radius: 14px; padding: 14px; }
    .form-grid{
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(190px, 1fr));
      gap: 10px;
      margin-top: 10px;
    }
    label{ font-weight: 850; margin-bottom: 6px; color:#333; display:block; }
    input, select{
      width:100%;
      padding: 10px;
      border: 2px solid #ddd;
      border-radius: 12px;
      font-size: 14px;
      background:#fff;
    }
    input:focus, select:focus{ outline:none; border-color:#667eea; }

    .btn{
      padding: 11px 14px;
      border: none;
      border-radius: 12px;
      font-size: 14px;
      font-weight: 900;
      cursor:pointer;
      margin: 8px 8px 0 0;
      transition: transform .15s, opacity .15s;
    }
    .btn:hover{ transform: translateY(-1px); }
    .btn:disabled{ background:#cfcfcf !important; cursor:not-allowed; opacity:.85; transform:none; }
    .btn-primary{ background:#667eea; color:#fff; }
    .btn-success{ background:#10b981; color:#fff; }
    .btn-danger { background:#ef4444; color:#fff; }
    .btn-ghost { background: rgba(102,126,234,0.12); color:#3b4bd6; }

    .status-message{
      display:none;
      text-align:center;
      padding: 10px 12px;
      border-radius: 12px;
      font-weight: 950;
      margin: 10px 0 14px 0;
    }
    .status-success{ background:#d1fae5; color:#065f46; }
    .status-error{ background:#fee2e2; color:#991b1b; }
    .status-info{ background:#dbeafe; color:#1e40af; }

    .sticky{ position: sticky; top: 8px; }
    @media (max-width: 980px){ .sticky{ top: 0; z-index: 50; position: static; } }

    .video-wrap{ position:relative; background:#000; border-radius: 14px; overflow:hidden; min-height: 200px; }
    video{
      width:100%;
      height:auto;
      display:block;
      position:relative;
      z-index:1;
    }
    canvas#overlay{
      width:100%;
      height:100%;
      display:block;
      position:absolute;
      left:0; top:0;
      z-index:5;
      pointer-events:none;
    }
    .hud{
      position:absolute;
      top: 10px; right: 10px;
      z-index: 10;
      background: rgba(0,0,0,0.72);
      color:#fff;
      padding: 6px 10px;
      border-radius: 12px;
      font-size: 13px;
      font-weight: 950;
      display:flex;
      flex-direction: column;
      gap:6px;
      align-items:flex-end;
      max-width: 95%;
      white-space: pre-line;
    }
    .hud small{ font-weight: 850; opacity: .92; }
    .divider{ height:1px; background:#e9e9e9; margin: 12px 0; }
    .mini{ color:#666; font-size: .88em; line-height: 1.35; margin-top: 8px; }

    .metrics-grid{
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 10px;
      margin-top: 10px;
    }
    .metric{
      background:#fff;
      border-radius: 14px;
      padding: 12px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.06);
    }
    .metric .t{ color:#666; font-weight:850; font-size:.92em; margin-bottom: 6px; }
    .metric .v{ color:#667eea; font-weight: 1000; font-size: 1.55em; }
    .metric .s{ color:#666; font-weight: 850; font-size: .88em; margin-top: 6px; line-height: 1.25; }

    .chiplist{ margin-top: 10px; display:flex; flex-wrap:wrap; gap: 8px; }
    .chip{
      background:#fff;
      border-radius: 999px;
      padding: 6px 10px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.06);
      display:flex;
      align-items:center;
      gap: 10px;
      font-weight: 900;
      color:#333;
      font-size: 13px;
    }
    .chip button{
      border:none;
      background: rgba(239,68,68,0.12);
      color:#ef4444;
      font-weight: 1000;
      border-radius: 999px;
      padding: 4px 8px;
      cursor:pointer;
    }

    .charts-grid{ display:grid; grid-template-columns: 1fr; gap: 12px; margin-top: 10px; }
    .chart-card{
      background:#fff;
      border-radius: 14px;
      padding: 12px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.06);
    }
    .chart-title{
      display:flex;
      justify-content: space-between;
      align-items:center;
      gap: 10px;
      margin-bottom: 8px;
    }
    .chart-title b{ color:#222; }
    .chart-title span{ color:#666; font-weight: 850; font-size: .9em; }
    canvas.chart{
      width: 100%;
      height: 150px;
      display:block;
      border-radius: 12px;
      background: #fafafa;
    }

    .card-head{
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 6px;
    }
    .collapse-btn{
      display:inline-flex;
      align-items:center;
      gap: 8px;
      border:none;
      cursor:pointer;
      border-radius: 12px;
      padding: 10px 12px;
      font-weight: 1000;
      background: rgba(102,126,234,0.12);
      color:#3b4bd6;
    }
    .collapse-icon{
      width: 10px;
      height: 10px;
      border-right: 3px solid currentColor;
      border-bottom: 3px solid currentColor;
      transform: rotate(45deg);
      transition: transform .18s ease;
      margin-left: 2px;
    }
    .collapsed .collapse-icon{ transform: rotate(-45deg); }
    .collapsible{
      overflow: hidden;
      transition: max-height .22s ease, opacity .22s ease;
      max-height: 2000px;
      opacity: 1;
    }
    .collapsed .collapsible{
      max-height: 0px;
      opacity: 0;
      pointer-events: none;
    }

    footer{ margin-top: 14px; text-align:center; color:#666; font-weight: 850; font-size: 0.92em; }

    .pip-toggle{ display:none; margin-top: 10px; }
    @media (max-width: 980px) {
      .pip-toggle{ display:inline-block; }
      body.pip-on .sticky .card{
        position: fixed;
        left: 12px; right: 12px; bottom: 12px;
        z-index: 9999;
        padding: 10px;
        box-shadow: 0 18px 55px rgba(0,0,0,0.35);
        max-width: 520px;
        margin: 0 auto;
      }
      body.pip-on .container{ padding-bottom: 270px; }
    }
  </style>
</head>

<body>
<div class="container">
  <h1>üèÉ‚Äç‚ôÇÔ∏è Movement Kinetics Lab</h1>
  <p class="subtitle">iOS-safe overlay ‚Ä¢ selectable kinematics ‚Ä¢ low-pass Force‚ÄìTime & Moment‚ÄìTime ‚Ä¢ projectile tracking ‚Ä¢ simplified XLSX (phases + summary)</p>

  <div id="statusMessage" class="status-message"></div>

  <div class="layout">
    <div>
      <div class="card">
        <h3>Participant</h3>
        <div class="form-grid">
          <div><label>Name *</label><input id="participantName" placeholder="Enter name"></div>
          <div>
            <label>Sex *</label>
            <select id="participantSex">
              <option value="male">Male</option><option value="female">Female</option>
            </select>
          </div>
          <div><label>Age *</label><input id="participantAge" type="number" value="25"></div>
          <div><label>Mass (kg) *</label><input id="participantMass" type="number" value="70"></div>
          <div><label>Height (cm) *</label><input id="participantHeight" type="number" value="175"></div>
        </div>
        <button class="btn btn-success" onclick="addParticipant()">Add / Update Participant</button>

        <div class="divider"></div>

        <label>Select Participant</label>
        <select id="selectedParticipant" onchange="onParticipantChange()"></select>

        <div class="divider"></div>

        <h3>Input Source</h3>
        <div class="form-grid">
          <div>
            <label>Source</label>
            <select id="inputSource">
              <option value="camera" selected>Live Camera</option>
              <option value="upload">Video Upload</option>
            </select>
          </div>
          <div>
             <label>FPS (Requested)</label>
             <select id="fpsSelection">
               <option value="30">30</option>
               <option value="60" selected>60</option>
               <option value="120">120 (best effort)</option>
               <option value="240">240 (best effort)</option>
             </select>
          </div>
          <div>
             <label>Camera</label>
             <select id="cameraFacing"><option value="environment">Back</option><option value="user">Front</option></select>
          </div>
          <div>
            <label>Window (s)</label>
            <select id="windowSeconds"><option value="5">5s</option><option value="10" selected>10s</option></select>
          </div>
          <div>
             <label>Low-pass cutoff (Hz)</label>
             <select id="cutoffHz"><option value="3">3</option><option value="4">4</option><option value="6" selected>6</option><option value="10">10</option><option value="12">12</option></select>
          </div>
        </div>

        <div class="form-grid" style="margin-top:10px;">
          <div>
            <label>Video File (Upload)</label>
            <input id="videoUpload" type="file" accept="video/*">
          </div>
        </div>

        <button class="btn btn-primary" onclick="startInput()">Start (Camera / Upload)</button>
        <button class="btn btn-danger" onclick="stopInput()">Stop</button>
        <button class="btn btn-success" id="recordBtn" onclick="toggleRecording()" disabled>Start Recording</button>
        <button class="btn btn-ghost" onclick="snapshotPNG()" id="snapBtn" disabled>üì∏ Snapshot PNG</button>
        <button class="btn btn-primary pip-toggle" onclick="togglePiP()">üìå Pin Video (PiP)</button>

        <div class="divider"></div>

        <h3>Projectile Tracking</h3>
        <div class="form-grid">
          <div>
            <label>Mode</label>
            <select id="projMode">
              <option value="off" selected>Off</option>
              <option value="coco">COCO-SSD Detect</option>
            </select>
          </div>
          <div>
            <label>Class</label>
            <select id="projClassHint">
              <option value="sports ball" selected>Sports ball</option>
              <option value="frisbee">Frisbee</option>
              <option value="kite">Kite</option>
              <option value="bottle">Bottle</option>
              <option value="cup">Cup</option>
              <option value="person">Person</option>
            </select>
          </div>
          <div>
            <label>Confidence</label>
            <select id="projMinScore">
              <option value="0.30">0.30</option>
              <option value="0.40" selected>0.40</option>
              <option value="0.50">0.50</option>
              <option value="0.60">0.60</option>
            </select>
          </div>
          <div>
            <label>Detect Rate</label>
            <select id="projEveryN">
              <option value="1">Every frame</option>
              <option value="2" selected>Every 2 frames</option>
              <option value="3">Every 3 frames</option>
              <option value="4">Every 4 frames</option>
            </select>
          </div>
        </div>
        <p class="mini">
          COCO-SSD uses generic classes (e.g., ‚Äúsports ball‚Äù). For small/fast balls, use bright lighting and keep the ball large in frame.
        </p>

        <div class="divider"></div>

        <h3>Kinetics Driver</h3>
        <div class="form-grid">
          <div>
            <label>Driver Joint</label>
            <select id="kinJoint">
              <option value="hip">Hip</option><option value="knee">Knee</option>
              <option value="shoulder">Shoulder</option><option value="elbow">Elbow</option>
              <option value="ankle">Ankle</option><option value="wrist">Wrist</option>
            </select>
          </div>
          <div>
            <label>Side</label>
            <select id="kinSide"><option value="R">Right</option><option value="L">Left</option></select>
          </div>
        </div>
        <p class="mini">
          Force‚ÄìTime uses low-pass filtered output for a clean graph. Moment‚ÄìTime = ‚Äúangular force‚Äù proxy (œÑ = IŒ±, simplified).
          Use for trends, not lab-grade force plates.
        </p>
      </div>

      <div class="card collapsible-card" id="displaySelectorCard" style="margin-top:12px;">
        <div class="card-head">
          <h3 style="margin:0;">Display Selector</h3>
          <button class="collapse-btn" onclick="toggleCollapse('displaySelectorCard')">
            <span id="displaySelectorCard_lbl">Collapse</span><span class="collapse-icon"></span>
          </button>
        </div>
        <div class="collapsible">
          <div class="form-grid">
            <div>
              <label>Metric</label>
              <select id="metricType">
                <option value="angle">Angle (¬∞)</option>
                <option value="angVel">Ang. Vel (¬∞/s)</option>
                <option value="linVel">Lin. Vel (m/s)</option>
              </select>
            </div>
            <div>
              <label>Joint</label>
              <select id="metricJoint">
                <option value="shoulder">Shoulder</option>
                <option value="elbow">Elbow</option>
                <option value="wrist">Wrist</option>
                <option value="hip">Hip</option>
                <option value="knee">Knee</option>
                <option value="ankle">Ankle</option>
              </select>
            </div>
            <div>
              <label>Side</label>
              <select id="metricSide"><option value="R">Right</option><option value="L">Left</option></select>
            </div>
          </div>
          <button class="btn btn-primary" onclick="addMetric()">Add</button>
          <button class="btn btn-danger" onclick="clearMetrics()">Clear</button>
          <div class="chiplist" id="metricChips"></div>
          <div class="divider"></div>
          <div class="metrics-grid" id="selectedMetricsPanel"></div>

          <div class="divider"></div>
          <div class="metric">
            <div class="t">Quick interpretation (live)</div>
            <div class="s" id="liveInterpretation">‚Äî</div>
          </div>
        </div>
      </div>

      <div class="card" style="margin-top:12px;">
        <h3>Real-time Charts</h3>
        <div class="charts-grid">
          <div class="chart-card">
            <div class="chart-title"><b>Force‚ÄìTime (filtered, N)</b><span id="lblForce">0 N</span></div>
            <canvas id="chartForce" class="chart"></canvas>
          </div>
          <div class="chart-card">
            <div class="chart-title"><b>Moment‚ÄìTime (filtered, Nm)</b><span id="lblMoment">0 Nm</span></div>
            <canvas id="chartMoment" class="chart"></canvas>
          </div>
        </div>
      </div>

      <div class="card" style="margin-top:12px;">
        <button class="btn btn-primary" onclick="downloadData()">üìä Download XLSX (Profile ‚Ä¢ Kinematics Summary by Phase ‚Ä¢ Kinetics Force/Moment Time ‚Ä¢ Technical Model)</button>
      </div>
    </div>

    <div class="sticky" id="stickyVideo">
      <div class="card">
        <h3>Live View</h3>
        <div class="video-wrap">
          <video id="video" playsinline muted></video>
          <canvas id="overlay"></canvas>
          <div class="hud">
            <div id="fpsIndicator">FPS: 0</div>
            <small id="statusText">Ready</small>
            <small id="sourceText">Source: ‚Äî</small>
          </div>
        </div>
        <p class="mini">
          Warnings: 2D pose has depth ambiguity; fast motion blur reduces keypoint confidence; ankle/wrist can drop under occlusion.
          For best results: tripod, stable framing, strong lighting, minimal clutter.
        </p>
      </div>
    </div>
  </div>

  <footer>¬© 2025 Ng Jun Wei. All rights reserved.</footer>
</div>

<script>
/* =========================================================
   Globals
========================================================= */
let detector = null, cocoModel = null;
let video = null, overlay = null, ctx = null;
let streamRef = null;
let animationId = null;

let participants = [];
let currentParticipant = null;

let isRecording = false;

// Store ONLY what we need (simplified export requirement):
// - Kinematics series: driver joint linear velocity, driver joint angular velocity, driver joint angle, driver joint displacement
// - Also keep selected metrics live display (optional) but export is simplified.
let rec = {
  t: [],                // seconds
  driverLinVel: [],     // m/s
  driverAngVel: [],     // deg/s
  driverAngle: [],      // deg
  driverDisp: [],       // m (cumulative displacement magnitude) OR net displacement? We'll do cumulative path length.
  forceFilt: [],        // N
  momentFilt: [],       // Nm ("angular force")
  projSpeed: [],        // m/s (optional)
  projValid: []         // 0/1
};

let sessionMeta = {};
let prevFrameTS = 0;
let prevKeypoints = null;
let frameIndex = 0;

// For stable angles/velocities
let prevAngleDriver = null;
let prevDriverPos = null;
let cumDisp = 0;

// Projectile tracking state
let prevProj = null;
let lastProjectiles = [];

// FPS estimate
let detectedFPS = 0;
let framesInSecond = 0;
let lastFPSUpdate = performance.now();

// Selected metrics (UI display only; export is simplified by requirement)
let selectedMetrics = [];
let prevAngleMap = new Map(); // metricId -> prev angle

// Charts time windowed
const chartSeries = { forceFilt:[], momentFilt:[] };
let lastChartDraw = 0;

// Pose keypoints indices (MoveNet)
const KP = {
  nose:0, left_eye:1, right_eye:2, left_ear:3, right_ear:4,
  shoulder_L:5, shoulder_R:6, elbow_L:7, elbow_R:8, wrist_L:9, wrist_R:10,
  hip_L:11, hip_R:12, knee_L:13, knee_R:14, ankle_L:15, ankle_R:16
};

const SKELETON = [
  [5,6],[5,7],[7,9],[6,8],[8,10],[5,11],[6,12],[11,12],[11,13],[13,15],[12,14],[14,16]
];

// Simplified segment mass fractions (for proxy kinetics)
const SEG_MASS = {
  thigh: 0.10, shank: 0.0465, foot: 0.0145,
  upperArm: 0.028, forearm: 0.016, hand: 0.006,
  trunk: 0.50
};

// Simplified radii of gyration fraction for I ~ m*(kL)^2
const SEG_K = { thigh:0.323, shank:0.302, foot:0.475, upperArm:0.322, forearm:0.303, hand:0.628 };

/* =========================================================
   Init
========================================================= */
window.onload = async () => {
  video = document.getElementById('video');
  overlay = document.getElementById('overlay');
  ctx = overlay.getContext('2d');

  // default participant
  document.getElementById('participantName').value = "Athlete 1";
  addParticipant(true);

  showStatus("Loading Neural Networks...", "info");
  try {
    await tf.ready();
    // iOS Safari: prefer webgl
    try { await tf.setBackend('webgl'); await tf.ready(); } catch(_) {}

    detector = await poseDetection.createDetector(
      poseDetection.SupportedModels.MoveNet,
      { modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING }
    );
    cocoModel = await cocoSsd.load();

    showStatus("Models Ready. Start Camera or Upload.", "success");
    setStatusText("Models ready");
  } catch(e) {
    console.error(e);
    showStatus("Error loading models. Try reloading.", "error");
    setStatusText("Model load error");
  }
};

/* =========================================================
   Participant
========================================================= */
function addParticipant(silent=false) {
  const name = (document.getElementById('participantName').value || "").trim();
  const sex = document.getElementById('participantSex').value;
  const age = parseInt(document.getElementById('participantAge').value || "0");
  const mass = parseFloat(document.getElementById('participantMass').value || "0");
  const height = parseFloat(document.getElementById('participantHeight').value || "0");

  if(!name || !mass || !height || !age) {
    if(!silent) showStatus("Please fill Name, Age, Mass, Height.", "error");
    return;
  }

  const existing = participants.find(p => p.name === name);
  const profile = { name, sex, age, mass, height };

  if(existing) Object.assign(existing, profile);
  else participants.push(profile);

  const sel = document.getElementById('selectedParticipant');
  sel.innerHTML = "";
  participants.forEach(p => {
    const opt = document.createElement('option');
    opt.value = p.name; opt.textContent = p.name;
    sel.appendChild(opt);
  });
  sel.value = name;

  currentParticipant = profile;

  if(!silent) showStatus(`Participant set: ${name}`, "success");
}

function onParticipantChange() {
  const sel = document.getElementById('selectedParticipant');
  const p = participants.find(x => x.name === sel.value);
  if(p) currentParticipant = p;
}

/* =========================================================
   Input Source
========================================================= */
async function startInput() {
  if(!detector) return showStatus("Wait for models to load.", "error");

  stopActive();
  resetSessionState();

  const src = document.getElementById('inputSource').value;
  const fpsReq = parseInt(document.getElementById('fpsSelection').value);
  const facing = document.getElementById('cameraFacing').value;

  sessionMeta = {
    source: src,
    fpsRequested: fpsReq,
    facing,
    startedAt: new Date().toISOString()
  };

  if(src === "camera") await startCameraInternal(fpsReq, facing);
  else await startUploadInternal();
}

async function startCameraInternal(fpsReq, facing) {
  setStatusText("Starting camera...");
  setSourceText(`Source: Camera (${facing}, req ${fpsReq}fps)`);

  const constraints = {
    video: {
      facingMode: facing,
      width: { ideal: 1280 },
      height: { ideal: 720 },
      frameRate: { ideal: fpsReq, max: fpsReq }
    },
    audio: false
  };

  try {
    streamRef = await navigator.mediaDevices.getUserMedia(constraints);
    video.srcObject = streamRef;

    video.onloadedmetadata = async () => {
      await video.play();

      overlay.width = video.videoWidth || 1280;
      overlay.height = video.videoHeight || 720;

      if(facing === 'user') {
        video.style.transform = "scaleX(-1)";
        overlay.style.transform = "scaleX(-1)";
      } else {
        video.style.transform = "none";
        overlay.style.transform = "none";
      }

      enableRunButtons(true);
      setStatusText("Running");
      animationId = requestAnimationFrame(renderLoop);
      showStatus("Camera Active", "success");
    };
  } catch(err) {
    console.error(err);
    showStatus("Camera Error: " + err.message, "error");
    setStatusText("Camera error");
  }
}

async function startUploadInternal() {
  const fileInput = document.getElementById('videoUpload');
  if(!fileInput.files.length) return showStatus("Select a video file first.", "error");

  const file = fileInput.files[0];
  const url = URL.createObjectURL(file);

  setStatusText("Loading video...");
  setSourceText(`Source: Upload (${file.name})`);

  video.srcObject = null;
  video.src = url;
  video.loop = true;
  video.muted = true;
  video.playsInline = true;

  video.onloadedmetadata = async () => {
    try {
      await video.play();

      overlay.width = video.videoWidth || 1280;
      overlay.height = video.videoHeight || 720;

      video.style.transform = "none";
      overlay.style.transform = "none";

      enableRunButtons(true);
      setStatusText("Running");
      animationId = requestAnimationFrame(renderLoop);
      showStatus("Playing Upload", "success");
    } catch(e) {
      console.error(e);
      showStatus("Upload playback error: " + e.message, "error");
      setStatusText("Upload error");
    }
  };
}

function stopInput() {
  stopActive();
  enableRunButtons(false);
  showStatus("Stopped", "info");
  setStatusText("Stopped");
  setSourceText("Source: ‚Äî");
}

function stopActive() {
  if(animationId) cancelAnimationFrame(animationId);
  animationId = null;

  if(streamRef) {
    try { streamRef.getTracks().forEach(t => t.stop()); } catch(_) {}
  }
  streamRef = null;

  try { video.pause(); } catch(_) {}
  video.srcObject = null;

  if(ctx) ctx.clearRect(0,0,overlay.width,overlay.height);
}

function enableRunButtons(running) {
  document.getElementById('recordBtn').disabled = !running;
  document.getElementById('snapBtn').disabled = !running;
}

function resetSessionState() {
  isRecording = false;

  rec = { t:[], driverLinVel:[], driverAngVel:[], driverAngle:[], driverDisp:[], forceFilt:[], momentFilt:[], projSpeed:[], projValid:[] };

  prevFrameTS = 0;
  prevKeypoints = null;
  frameIndex = 0;

  prevAngleDriver = null;
  prevDriverPos = null;
  cumDisp = 0;

  prevAngleMap.clear();

  prevProj = null;
  lastProjectiles = [];

  chartSeries.forceFilt = [];
  chartSeries.momentFilt = [];
  lastChartDraw = 0;

  document.getElementById('lblForce').innerText = "0 N";
  document.getElementById('lblMoment').innerText = "0 Nm";
  document.getElementById('liveInterpretation').innerText = "‚Äî";
}

/* =========================================================
   Main Loop
========================================================= */
async function renderLoop(ts) {
  animationId = requestAnimationFrame(renderLoop);
  if(!video || video.paused || video.ended) return;

  // FPS
  framesInSecond++;
  const nowPerf = performance.now();
  if(nowPerf - lastFPSUpdate >= 1000) {
    detectedFPS = framesInSecond;
    framesInSecond = 0;
    lastFPSUpdate = nowPerf;
    document.getElementById('fpsIndicator').innerText = "FPS: " + detectedFPS;
  }

  frameIndex++;

  const tSec = (ts || performance.now()) / 1000;
  const dt = prevFrameTS ? clamp(tSec - prevFrameTS, 1/240, 0.2) : (1/60);
  prevFrameTS = tSec;

  // Pose
  let kp = null;
  try {
    const poses = await detector.estimatePoses(video, { flipHorizontal: false });
    if(poses && poses.length && poses[0].keypoints) kp = poses[0].keypoints;
  } catch(_) {}

  // Projectile
  const projMode = document.getElementById('projMode').value;
  if(projMode === "coco" && cocoModel) {
    const everyN = parseInt(document.getElementById('projEveryN').value);
    if(frameIndex % everyN === 0) {
      try {
        const preds = await cocoModel.detect(video);
        const cls = document.getElementById('projClassHint').value;
        const minScore = parseFloat(document.getElementById('projMinScore').value);
        lastProjectiles = preds.filter(p => p.class === cls && p.score >= minScore).sort((a,b)=>b.score-a.score).slice(0, 2);
      } catch(_) {}
    }
  } else {
    lastProjectiles = [];
  }

  // Draw
  ctx.clearRect(0,0,overlay.width, overlay.height);
  if(kp) drawSkeleton(kp);
  drawProjectile(lastProjectiles, dt);

  // Kinematics display (selected metrics)
  if(kp) {
    processSelectedMetrics(kp, dt);
    const kin = processDriverKinematics(kp, dt);       // <- used for export + interpretation
    const kinets = processDriverKinetics(kp, dt, tSec, kin); // <- low-pass filtered force/moment (clean graph)

    // Live interpretation
    document.getElementById('liveInterpretation').innerText = buildLiveInterpretation(kin, kinets);

    // Recording (simplified)
    if(isRecording) recordSimplified(tSec, kin, kinets);

    prevKeypoints = kp;
  } else {
    setStatusText("No pose detected (framing/lighting)");
  }

  throttleChartDraw(tSec);
}

/* =========================================================
   Drawing
========================================================= */
function drawSkeleton(kp) {
  const minScore = 0.30;
  ctx.lineWidth = 3;
  ctx.strokeStyle = "#00ff66";

  const skeleton = [
    [KP.shoulder_L, KP.shoulder_R],
    [KP.shoulder_L, KP.elbow_L], [KP.elbow_L, KP.wrist_L],
    [KP.shoulder_R, KP.elbow_R], [KP.elbow_R, KP.wrist_R],
    [KP.shoulder_L, KP.hip_L], [KP.shoulder_R, KP.hip_R],
    [KP.hip_L, KP.hip_R],
    [KP.hip_L, KP.knee_L], [KP.knee_L, KP.ankle_L],
    [KP.hip_R, KP.knee_R], [KP.knee_R, KP.ankle_R]
  ];

  skeleton.forEach(([i, j]) => {
    if(kp[i]?.score > minScore && kp[j]?.score > minScore) {
      ctx.beginPath();
      ctx.moveTo(kp[i].x, kp[i].y);
      ctx.lineTo(kp[j].x, kp[j].y);
      ctx.stroke();
    }
  });

  kp.forEach(p => {
    if(p.score > minScore) {
      ctx.beginPath();
      ctx.arc(p.x, p.y, 5, 0, 2*Math.PI);
      ctx.fillStyle = "red";
      ctx.fill();
    }
  });
}

function drawProjectile(projs, dt) {
  if(!projs || !projs.length) { prevProj = null; return; }

  ctx.save();
  ctx.lineWidth = 2;
  ctx.strokeStyle = "orange";
  ctx.fillStyle = "orange";
  ctx.font = "14px system-ui, -apple-system, Segoe UI, Roboto, Arial";

  projs.forEach(p => {
    const [x,y,w,h] = p.bbox;
    ctx.strokeRect(x,y,w,h);
    const label = `${p.class} ${(p.score*100).toFixed(0)}%`;
    ctx.fillText(label, x, y > 18 ? y-6 : y+18);
  });

  // tracked center + velocity arrow
  const s = computeProjectileState(projs, dt);
  if(s.valid) {
    ctx.beginPath();
    ctx.arc(s.cx, s.cy, 6, 0, 2*Math.PI);
    ctx.fill();

    // velocity vector (scaled for visuals)
    const pxScale = 0.15; // smaller -> longer arrow
    ctx.beginPath();
    ctx.moveTo(s.cx, s.cy);
    ctx.lineTo(s.cx + (s.vx_mps/pxScale), s.cy + (s.vy_mps/pxScale));
    ctx.stroke();
  }

  ctx.restore();
}

/* =========================================================
   Helpers: scale / indices
========================================================= */
function getPxToMeter() {
  const hM = currentParticipant ? (currentParticipant.height / 100) : 1.75;
  const denom = Math.max(240, overlay.height * 0.80);
  return hM / denom;
}

function getJointIndex(joint, side) {
  const map = {
    shoulder_R: KP.shoulder_R, shoulder_L: KP.shoulder_L,
    elbow_R: KP.elbow_R, elbow_L: KP.elbow_L,
    wrist_R: KP.wrist_R, wrist_L: KP.wrist_L,
    hip_R: KP.hip_R, hip_L: KP.hip_L,
    knee_R: KP.knee_R, knee_L: KP.knee_L,
    ankle_R: KP.ankle_R, ankle_L: KP.ankle_L
  };
  const key = `${joint}_${side}`;
  return (key in map) ? map[key] : null;
}

/* =========================================================
   Selected metrics: UI display only
========================================================= */
function processSelectedMetrics(kp, dt) {
  selectedMetrics.forEach(m => {
    const v = computeMetricValue(kp, m, dt);
    const el = document.getElementById(`val_${m.id}`);
    if(el) el.innerText = isFinite(v) ? v.toFixed(1) : "--";
  });
}

function computeMetricValue(kp, m, dt) {
  if(m.type === "angle") return getJointAngleDeg(kp, m.joint, m.side);
  if(m.type === "linVel") {
    const idx = getJointIndex(m.joint, m.side);
    return idx == null ? NaN : getLinearVelMps(kp, idx, dt);
  }
  if(m.type === "angVel") {
    const ang = getJointAngleDeg(kp, m.joint, m.side);
    const prev = prevAngleMap.get(m.id);
    prevAngleMap.set(m.id, ang);
    if(prev == null || !isFinite(prev) || !isFinite(ang)) return 0;
    let d = ang - prev;
    if(d > 180) d -= 360;
    if(d < -180) d += 360;
    return d / Math.max(1e-4, dt);
  }
  return NaN;
}

function getJointAngleDeg(kp, joint, side) {
  const minScore = 0.30;
  let a=null,b=null,c=null;

  if(joint === "elbow")      { a=`shoulder_${side}`; b=`elbow_${side}`; c=`wrist_${side}`; }
  else if(joint === "knee")  { a=`hip_${side}`;      b=`knee_${side}`;  c=`ankle_${side}`; }
  else if(joint === "hip")   { a=`shoulder_${side}`; b=`hip_${side}`;   c=`knee_${side}`; }
  else if(joint === "shoulder"){ a=`hip_${side}`;    b=`shoulder_${side}`; c=`elbow_${side}`; }
  else if(joint === "wrist") { // proxy: elbow->wrist orientation
    const e = kp[getJointIndex("elbow", side)];
    const w = kp[getJointIndex("wrist", side)];
    if(!e || !w || e.score < minScore || w.score < minScore) return NaN;
    const ang = Math.atan2(w.y - e.y, w.x - e.x) * 180/Math.PI;
    return Math.abs(normalizeDeg(ang));
  }
  else if(joint === "ankle") { // proxy: knee->ankle orientation vs vertical
    const k = kp[getJointIndex("knee", side)];
    const a2 = kp[getJointIndex("ankle", side)];
    if(!k || !a2 || k.score < minScore || a2.score < minScore) return NaN;
    const ang = Math.atan2(a2.x - k.x, a2.y - k.y) * 180/Math.PI;
    return Math.abs(normalizeDeg(ang));
  }
  else return NaN;

  const pA = kp[getJointIndex(a.split("_")[0], a.split("_")[1])];
  const pB = kp[getJointIndex(b.split("_")[0], b.split("_")[1])];
  const pC = kp[getJointIndex(c.split("_")[0], c.split("_")[1])];
  if(!pA || !pB || !pC) return NaN;
  if(pA.score < minScore || pB.score < minScore || pC.score < minScore) return NaN;

  const rad =
    Math.atan2(pC.y - pB.y, pC.x - pB.x) -
    Math.atan2(pA.y - pB.y, pA.x - pB.x);

  let deg = Math.abs(rad * 180.0 / Math.PI);
  if(deg > 180) deg = 360 - deg;
  return deg;
}

function normalizeDeg(d) {
  let x = d % 360;
  if(x < 0) x += 360;
  return x;
}

function getLinearVelMps(kp, idx, dt) {
  if(!prevKeypoints || !kp[idx] || !prevKeypoints[idx]) return 0;
  const curr = kp[idx], prev = prevKeypoints[idx];
  if(curr.score < 0.30 || prev.score < 0.30) return 0;
  const scale = getPxToMeter();
  const dx = (curr.x - prev.x) * scale;
  const dy = (curr.y - prev.y) * scale;
  return Math.hypot(dx, dy) / Math.max(1e-4, dt);
}

/* =========================================================
   Driver kinematics (for simplified export + model)
========================================================= */
function processDriverKinematics(kp, dt) {
  const jName = document.getElementById('kinJoint').value;
  const side = document.getElementById('kinSide').value;
  const idx = getJointIndex(jName, side);
  if(idx == null) return null;

  const p = kp[idx];
  if(!p || p.score < 0.30) return null;

  // driver linear velocity
  const v = getLinearVelMps(kp, idx, dt);

  // driver angle + angular velocity
  const ang = getJointAngleDeg(kp, jName, side);
  let w = 0;
  if(prevAngleDriver != null && isFinite(prevAngleDriver) && isFinite(ang)) {
    let d = ang - prevAngleDriver;
    if(d > 180) d -= 360;
    if(d < -180) d += 360;
    w = d / Math.max(1e-4, dt);
  }
  prevAngleDriver = ang;

  // driver displacement (cumulative path length in meters)
  const scale = getPxToMeter();
  if(prevDriverPos && prevDriverPos.ok) {
    const dx = (p.x - prevDriverPos.x) * scale;
    const dy = (p.y - prevDriverPos.y) * scale;
    cumDisp += Math.hypot(dx, dy);
  }
  prevDriverPos = { x:p.x, y:p.y, ok:true };

  // projectile
  const proj = computeProjectileState(lastProjectiles, dt);

  return {
    driver: `${jName}_${side}`,
    v_mps: v,
    angle_deg: isFinite(ang) ? ang : 0,
    angVel_dps: w,
    disp_m: cumDisp,
    projValid: proj.valid ? 1 : 0,
    projSpeed_mps: proj.valid ? proj.speed_mps : 0
  };
}

/* =========================================================
   Kinetics Driver (TROUBLESHOOTED + CLEAN LOW-PASS)
   - Ensures dt sanity
   - Uses forceRaw and momentRaw then low-pass to forceFilt/momentFilt
   - Plots filtered series only
========================================================= */
let prevForceFilt = 0;
let prevMomentFilt = 0;

function processDriverKinetics(kp, dt, tSec, kin) {
  if(!currentParticipant || !prevKeypoints || !kin) return null;

  // choose segment based on driver joint
  const driverJoint = kin.driver.split("_")[0];
  let seg = "thigh";
  if(driverJoint === "knee") seg = "shank";
  if(driverJoint === "ankle") seg = "foot";
  if(driverJoint === "shoulder") seg = "upperArm";
  if(driverJoint === "elbow") seg = "forearm";
  if(driverJoint === "wrist") seg = "hand";

  const segMass = currentParticipant.mass * (SEG_MASS[seg] || 0.10);

  // Acceleration proxy: a ‚âà Œîv / dt (we approximate Œîv using current v and previous v from series)
  const prevV = rec.driverLinVel.length ? rec.driverLinVel[rec.driverLinVel.length - 1] : kin.v_mps;
  const accel = Math.abs(kin.v_mps - prevV) / Math.max(1e-4, dt);
  const forceRaw = segMass * accel;

  // Moment proxy: œÑ = IŒ±, Œ± from angular velocity derivative
  const prevW = rec.driverAngVel.length ? rec.driverAngVel[rec.driverAngVel.length - 1] : kin.angVel_dps;
  const angAccel_dps2 = (kin.angVel_dps - prevW) / Math.max(1e-4, dt);
  const alpha = angAccel_dps2 * Math.PI / 180;

  const L = estimateSegmentLengthM(seg);
  const k = SEG_K[seg] || 0.30;
  const I = segMass * Math.pow(k * L, 2);

  const momentRaw = I * alpha;

  // Low-pass filter (clean graph)
  const hz = parseFloat(document.getElementById('cutoffHz').value);
  const forceFilt = lowPass(prevForceFilt, forceRaw, dt, hz);
  const momentFilt = lowPass(prevMomentFilt, momentRaw, dt, hz);

  // extra smoothing for display stability (2nd pass, optional but helpful visually)
  const forceFilt2 = lowPass(prevForceFilt, forceFilt, dt, hz);
  const momentFilt2 = lowPass(prevMomentFilt, momentFilt, dt, hz);

  prevForceFilt = forceFilt2;
  prevMomentFilt = momentFilt2;

  // UI labels
  document.getElementById('lblForce').innerText = forceFilt2.toFixed(0) + " N";
  document.getElementById('lblMoment').innerText = momentFilt2.toFixed(2) + " Nm";

  // chart buffers (filtered only)
  pushChart('forceFilt', tSec, forceFilt2);
  pushChart('momentFilt', tSec, momentFilt2);

  return { forceFilt_N: forceFilt2, momentFilt_Nm: momentFilt2 };
}

function estimateSegmentLengthM(seg) {
  const h = currentParticipant ? (currentParticipant.height/100) : 1.75;
  const frac = {
    thigh:0.245, shank:0.246, foot:0.152,
    upperArm:0.186, forearm:0.146, hand:0.108,
    trunk:0.288
  };
  return h * (frac[seg] || 0.20);
}

function lowPass(prev, curr, dt, fc) {
  const rc = 1.0 / (2 * Math.PI * fc);
  const alpha = dt / (rc + dt);
  return prev + alpha * (curr - prev);
}

/* =========================================================
   Charts (filtered-only)
========================================================= */
function pushChart(key, t, v) {
  const win = parseInt(document.getElementById('windowSeconds').value);
  chartSeries[key].push({t, v});
  while(chartSeries[key].length && chartSeries[key][0].t < t - win) chartSeries[key].shift();
}

function throttleChartDraw(t) {
  if(t - lastChartDraw < 0.1) return;
  lastChartDraw = t;
  drawChart('chartForce', 'forceFilt');
  drawChart('chartMoment', 'momentFilt');
}

function drawChart(id, key) {
  const c = document.getElementById(id);
  const g = c.getContext('2d');
  const w = c.width = c.clientWidth;
  const h = c.height = c.clientHeight;
  g.clearRect(0,0,w,h);

  g.strokeStyle="#eee";
  g.beginPath(); g.moveTo(0,h/2); g.lineTo(w,h/2); g.stroke();

  const data = chartSeries[key];
  if(!data || data.length < 2) return;

  let max = 1;
  data.forEach(d => { max = Math.max(max, Math.abs(d.v)); });

  const win = parseInt(document.getElementById('windowSeconds').value);
  const now = data[data.length-1].t;

  g.strokeStyle = "#667eea";
  g.lineWidth = 2;
  g.beginPath();

  data.forEach((pt, i) => {
    const x = ((win - (now - pt.t)) / win) * w;
    const y = h - ((pt.v / (max*1.2)) * (h/2) + h/2);
    if(i===0) g.moveTo(x,y); else g.lineTo(x,y);
  });
  g.stroke();
}

/* =========================================================
   Projectile state (center + velocity)
========================================================= */
function computeProjectileState(projs, dt) {
  const state = { valid:false, cx:0, cy:0, vx_mps:0, vy_mps:0, speed_mps:0, angle_deg:0, class:"", score:0 };
  if(!projs || !projs.length) { prevProj = null; return state; }

  const best = projs[0];
  const [x,y,w,h] = best.bbox;
  const cx = x + w/2;
  const cy = y + h/2;

  state.valid = true;
  state.class = best.class;
  state.score = best.score;
  state.cx = cx; state.cy = cy;

  const scale = getPxToMeter();
  if(prevProj && prevProj.valid) {
    const vx = ((cx - prevProj.cx) * scale) / Math.max(1e-4, dt);
    const vy = ((cy - prevProj.cy) * scale) / Math.max(1e-4, dt);
    const a = 0.35;
    state.vx_mps = a*vx + (1-a)*(prevProj.vx_mps || 0);
    state.vy_mps = a*vy + (1-a)*(prevProj.vy_mps || 0);
  }

  state.speed_mps = Math.hypot(state.vx_mps, state.vy_mps);
  state.angle_deg = Math.atan2(-state.vy_mps, state.vx_mps) * 180/Math.PI;

  prevProj = {...state};
  return state;
}

/* =========================================================
   Recording (simplified by requirement)
========================================================= */
function toggleRecording() {
  const btn = document.getElementById('recordBtn');
  if(!isRecording) {
    if(!currentParticipant) return showStatus("Set a participant first.", "error");
    isRecording = true;

    // clear existing series
    rec = { t:[], driverLinVel:[], driverAngVel:[], driverAngle:[], driverDisp:[], forceFilt:[], momentFilt:[], projSpeed:[], projValid:[] };
    prevForceFilt = 0;
    prevMomentFilt = 0;
    prevAngleDriver = null;
    prevDriverPos = null;
    cumDisp = 0;

    btn.textContent = "Stop Recording";
    btn.className = "btn btn-danger";
    showStatus("Recording started...", "info");
    setStatusText("Recording...");
  } else {
    isRecording = false;
    btn.textContent = "Start Recording";
    btn.className = "btn btn-success";
    showStatus(`Recording saved. ${rec.t.length} samples.`, "success");
    setStatusText("Running");
  }
}

function recordSimplified(tSec, kin, kinets) {
  if(!kin) return;
  rec.t.push(tSec);
  rec.driverLinVel.push(kin.v_mps || 0);
  rec.driverAngVel.push(kin.angVel_dps || 0);
  rec.driverAngle.push(kin.angle_deg || 0);
  rec.driverDisp.push(kin.disp_m || 0);

  rec.forceFilt.push(kinets?.forceFilt_N || 0);
  rec.momentFilt.push(kinets?.momentFilt_Nm || 0);

  rec.projValid.push(kin.projValid || 0);
  rec.projSpeed.push(kin.projSpeed_mps || 0);
}

function snapshotPNG() {
  if(!video || video.paused) return showStatus("Start Camera/Upload first.", "error");
  const c = document.createElement('canvas');
  const w = overlay.width, h = overlay.height;
  c.width = w; c.height = h;
  const g = c.getContext('2d');
  try { g.drawImage(video, 0, 0, w, h); } catch(_) {}
  try { g.drawImage(overlay, 0, 0, w, h); } catch(_) {}

  const a = document.createElement('a');
  a.href = c.toDataURL("image/png");
  a.download = `snapshot_${Date.now()}.png`;
  a.click();
}

/* =========================================================
   XLSX Export (simplified + phases)
   Tabs:
   1_Profile
   2_Kinematics_Summary (overall + Preparation/Acceleration/FollowThrough)
   3_Kinetics_ForceMoment_Time (time, forceFilt, momentFilt)
   4_Technical_Model (push-like vs throw-like + biomech + training rec)
========================================================= */
function downloadData() {
  if(!rec.t.length) return showStatus("No recorded data. Press Start Recording first.", "error");

  const profile = currentParticipant || participants[0] || {name:"",sex:"",age:"",mass:"",height:""};
  const driver = `${document.getElementById('kinJoint').value}_${document.getElementById('kinSide').value}`;

  // Build phases using a robust, simple temporal split around peak linear velocity
  const phases = segmentPhases(rec.t, rec.driverLinVel, rec.driverAngVel);

  // Kinematics summary overall + by phase
  const kinSummaryRows = [];
  kinSummaryRows.push(...makeKinSummaryBlock("Overall", profile, driver, rangeAll(phases), rec));
  phases.forEach(ph => {
    kinSummaryRows.push(...makeKinSummaryBlock(ph.name, profile, driver, ph, rec));
  });

  // Kinetics series (clean)
  const kineticsRows = rec.t.map((t, i) => ({
    time_s: round(t, 4),
    forceFilt_N: round(rec.forceFilt[i] || 0, 3),
    momentFilt_Nm: round(rec.momentFilt[i] || 0, 4)
  }));

  // Technical model
  const modelRows = buildTechnicalModel(profile, driver, phases, rec);

  // Profile tab
  const profileRows = [
    { field:"name", value: profile.name },
    { field:"sex", value: profile.sex },
    { field:"age", value: profile.age },
    { field:"mass_kg", value: profile.mass },
    { field:"height_cm", value: profile.height },
    { field:"driver_joint", value: driver },
    { field:"source", value: sessionMeta.source || "" },
    { field:"camera_facing", value: sessionMeta.facing || "" },
    { field:"fps_requested", value: sessionMeta.fpsRequested || "" },
    { field:"fps_detected_est", value: detectedFPS || "" },
    { field:"started_at", value: sessionMeta.startedAt || "" },
    { field:"notes", value: "Kinetics are proxies (F‚âàmŒîv/Œît; œÑ‚âàIŒ±). Use for trends and coaching feedback, not lab-grade ground truth." }
  ];

  const wb = XLSX.utils.book_new();
  XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet(profileRows), "1_Profile");
  XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet(kinSummaryRows), "2_Kinematics_Summary");
  XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet(kineticsRows), "3_Kinetics_ForceMoment_Time");
  XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet(modelRows), "4_Technical_Model");

  const fname = `sport_analysis_${(profile.name||"participant").replace(/\s+/g,"_")}_${Date.now()}.xlsx`;
  XLSX.writeFile(wb, fname);
  showStatus("XLSX exported (simplified + phases).", "success");
}

/* =========================================================
   Phase segmentation (temporal phases)
   - Preparation: start -> peak linear velocity index
   - Acceleration/Propulsion: peak linear velocity ¬± 15% window (centered)
   - Follow-through: after acceleration window -> end
   This gives stable phases without needing foot-strike detection.
========================================================= */
function segmentPhases(t, v, w) {
  const n = t.length;
  if(n < 10) return [
    { name:"Preparation", i0:0, i1:Math.max(0,n-1) },
    { name:"Acceleration", i0:0, i1:Math.max(0,n-1) },
    { name:"FollowThrough", i0:0, i1:Math.max(0,n-1) }
  ];

  const peakIdx = argMaxAbs(v);
  const win = Math.max(3, Math.floor(n * 0.15));
  const iA0 = clampInt(peakIdx - win, 0, n-1);
  const iA1 = clampInt(peakIdx + win, 0, n-1);

  return [
    { name:"Preparation", i0:0, i1:Math.max(0, iA0) },
    { name:"Acceleration", i0:iA0, i1:iA1 },
    { name:"FollowThrough", i0:Math.min(n-1, iA1), i1:n-1 }
  ];
}

function rangeAll(phases) {
  return { i0: phases[0].i0, i1: phases[phases.length-1].i1 };
}

/* =========================================================
   Kinematics summary block
   Provide ONLY:
   - peak linear velocity + average
   - peak angular velocity + average
   - peak angular displacement (ROM) + average angle
   - displacement (path length) + average displacement rate
   and projectile peak speed if present
========================================================= */
function makeKinSummaryBlock(label, profile, driver, ph, rec) {
  const i0 = ph.i0, i1 = ph.i1;
  const tt = slice(rec.t, i0, i1);
  const v = slice(rec.driverLinVel, i0, i1);
  const w = slice(rec.driverAngVel, i0, i1);
  const ang = slice(rec.driverAngle, i0, i1);
  const disp = slice(rec.driverDisp, i0, i1);
  const projV = slice(rec.projSpeed, i0, i1);
  const projOk = slice(rec.projValid, i0, i1);

  const dur = tt.length ? (tt[tt.length-1] - tt[0]) : 0;

  const peakV = maxAbs(v);
  const avgV = mean(v);

  const peakW = maxAbs(w);
  const avgW = mean(w);

  const rom = (ang.length ? (Math.max(...ang) - Math.min(...ang)) : 0);
  const avgAng = mean(ang);

  const dispNet = disp.length ? (disp[disp.length-1] - disp[0]) : 0; // cumulative path increase during phase
  const avgDispRate = dur > 0 ? dispNet / dur : 0;

  let peakProj = 0;
  for(let i=0;i<projV.length;i++){
    if((projOk[i]||0)===1) peakProj = Math.max(peakProj, projV[i]||0);
  }

  return [{
    phase: label,
    driver_joint: driver,
    duration_s: round(dur, 3),
    peak_linVel_mps: round(peakV, 3),
    avg_linVel_mps: round(avgV, 3),
    peak_angVel_dps: round(peakW, 2),
    avg_angVel_dps: round(avgW, 2),
    peak_angDisplacement_deg: round(rom, 2),
    avg_angle_deg: round(avgAng, 2),
    displacement_m: round(dispNet, 3),
    avg_dispRate_mps: round(avgDispRate, 3),
    peak_projectile_speed_mps: round(peakProj, 3)
  }];
}

/* =========================================================
   Technical model: push-like vs throw-like + recommendations
========================================================= */
function buildTechnicalModel(profile, driver, phases, rec) {
  const overall = rangeAll(phases);

  const vAll = slice(rec.driverLinVel, overall.i0, overall.i1);
  const wAll = slice(rec.driverAngVel, overall.i0, overall.i1);
  const angAll = slice(rec.driverAngle, overall.i0, overall.i1);
  const dispAll = slice(rec.driverDisp, overall.i0, overall.i1);
  const forceAll = slice(rec.forceFilt, overall.i0, overall.i1);
  const momAll = slice(rec.momentFilt, overall.i0, overall.i1);

  const peakV = maxAbs(vAll);
  const peakW = maxAbs(wAll);
  const rom = angAll.length ? (Math.max(...angAll)-Math.min(...angAll)) : 0;
  const dispNet = dispAll.length ? (dispAll[dispAll.length-1]-dispAll[0]) : 0;
  const peakF = maxAbs(forceAll);
  const peakM = maxAbs(momAll);

  // Heuristic index:
  // - Push-like: higher translational dominance (peakV, displacement, force) relative to rotational metrics
  // - Throw-like: higher rotational dominance (peakW, moment) relative to translational
  const transScore = safeDiv(peakV, 1) + safeDiv(dispNet, 0.5) + safeDiv(peakF, 200);
  const rotScore = safeDiv(peakW, 200) + safeDiv(rom, 60) + safeDiv(peakM, 10);

  const pattern = (rotScore > transScore) ? "Throw-like (rotational dominant)" : "Push-like (translational dominant)";
  const rationale = (rotScore > transScore)
    ? "Rotational metrics (peak angular velocity / moment) dominate relative to translation."
    : "Translational metrics (displacement / linear velocity / force) dominate relative to rotation.";

  // Recommendations (biomech + training)
  const recos = [];

  // Kinematic cues based on pattern
  if(pattern.startsWith("Push-like")) {
    recos.push("Biomechanics: Consider improving proximal-to-distal sequencing (increase rotational contribution) to reduce ‚Äòpushing‚Äô late with distal segments.");
    recos.push("Kinematics: Aim for earlier build-up of angular velocity (hip/shoulder rotation) before peak distal linear velocity; avoid ‚Äòall at once‚Äô surge.");
    recos.push("Kinetics: Reduce excessively spiky Force‚ÄìTime by smoothing acceleration (better braking control); target a more gradual rise and cleaner peak.");
    recos.push("Training: rotational med-ball throws (hip-to-shoulder separation), cable chops/lifts, landmine rotations; add deceleration work (catch-and-stick, anti-rotation holds).");
  } else {
    recos.push("Biomechanics: Throw-like pattern suggests strong rotation; ensure stability and efficient transfer to translation at release/impact.");
    recos.push("Kinematics: Check if peak angular velocity occurs too early (energy leak) or too late (late whip). Target peak proximal angular velocity slightly before peak linear velocity.");
    recos.push("Kinetics: If Moment‚ÄìTime is sharp/spiky, add eccentric control and braking capacity to protect joints while maintaining speed.");
    recos.push("Training: plyometric med-ball (scoop toss, shot-put toss), band-assisted speed rotations + controlled decel reps, eccentric elbow/shoulder/hip braking drills, technique reps with reduced load for timing.");
  }

  // Value-based flags
  if(peakF > 600) recos.push("Flag: Very high peak Force proxy. Confirm technique and consider reducing impact stiffness (softer deceleration, better joint flexion strategy).");
  if(Math.abs(peakM) > 20) recos.push("Flag: High peak Moment proxy. Emphasize trunk/hip stability + eccentric strength to manage rotational loads safely.");
  if(peakW > 700) recos.push("Flag: Very high peak angular velocity. Verify keypoint confidence (motion blur) and prioritize timing + smoothness to avoid erratic spikes.");

  const rows = [];
  rows.push({ section:"Pattern classification", item:"Pattern", value: pattern });
  rows.push({ section:"Pattern classification", item:"Rationale", value: rationale });

  rows.push({ section:"Key values (overall)", item:"Peak linear velocity (m/s)", value: round(peakV,3) });
  rows.push({ section:"Key values (overall)", item:"Peak angular velocity (deg/s)", value: round(peakW,2) });
  rows.push({ section:"Key values (overall)", item:"Peak angular displacement ROM (deg)", value: round(rom,2) });
  rows.push({ section:"Key values (overall)", item:"Displacement (m)", value: round(dispNet,3) });
  rows.push({ section:"Key values (overall)", item:"Peak Force‚ÄìTime (N, filtered)", value: round(peakF,0) });
  rows.push({ section:"Key values (overall)", item:"Peak Moment‚ÄìTime (Nm, filtered)", value: round(peakM,3) });

  phases.forEach(ph => {
    const blk = makeKinSummaryBlock(ph.name, profile, driver, ph, rec)[0];
    rows.push({ section:"Phase summary", item:`${ph.name} duration (s)`, value: blk.duration_s });
    rows.push({ section:"Phase summary", item:`${ph.name} peak linVel (m/s)`, value: blk.peak_linVel_mps });
    rows.push({ section:"Phase summary", item:`${ph.name} peak angVel (deg/s)`, value: blk.peak_angVel_dps });
    rows.push({ section:"Phase summary", item:`${ph.name} ROM (deg)`, value: blk.peak_angDisplacement_deg });
    rows.push({ section:"Phase summary", item:`${ph.name} displacement (m)`, value: blk.displacement_m });
  });

  recos.forEach((t, i) => rows.push({ section:"Recommendations", item:`R${i+1}`, value: t }));

  rows.push({ section:"Notes", item:"Method", value:"Phases are segmented around peak linear velocity (Preparation ‚Üí Acceleration window ‚Üí Follow-through). Kinetics are simplified proxies; interpret trends and relative change." });

  return rows;
}

/* =========================================================
   Live interpretation string
========================================================= */
function buildLiveInterpretation(kin, kinets) {
  if(!kin) return "‚Äî";
  const parts = [];
  parts.push(`Driver: ${kin.driver}`);
  parts.push(`v: ${kin.v_mps.toFixed(2)} m/s | œâ: ${kin.angVel_dps.toFixed(0)} ¬∞/s | Œ∏: ${kin.angle_deg.toFixed(1)}¬∞ | disp: ${kin.disp_m.toFixed(2)} m`);
  if(kinets) parts.push(`Force: ${kinets.forceFilt_N.toFixed(0)} N | Moment: ${kinets.momentFilt_Nm.toFixed(2)} Nm`);
  if(kin.projValid) parts.push(`Projectile speed: ${kin.projSpeed_mps.toFixed(2)} m/s`);
  return parts.join("\n");
}

/* =========================================================
   UI: Metrics selection
========================================================= */
function addMetric() {
  const type = document.getElementById('metricType').value;
  const joint = document.getElementById('metricJoint').value;
  const side = document.getElementById('metricSide').value;
  const id = `${type}_${joint}_${side}`;
  if(!selectedMetrics.find(m => m.id === id)) {
    selectedMetrics.push({id, type, joint, side});
    renderMetricChips();
  }
}
function removeMetric(id) { selectedMetrics = selectedMetrics.filter(m => m.id !== id); renderMetricChips(); }
function clearMetrics() { selectedMetrics = []; renderMetricChips(); }

function renderMetricChips() {
  const chips = document.getElementById('metricChips');
  const panel = document.getElementById('selectedMetricsPanel');
  chips.innerHTML = "";
  panel.innerHTML = "";
  selectedMetrics.forEach(m => {
    const label = `${m.type} ${m.joint} ${m.side}`;
    const chip = document.createElement('div');
    chip.className = "chip";
    chip.innerHTML = `${label} <button onclick="removeMetric('${m.id}')">‚úï</button>`;
    chips.appendChild(chip);

    const card = document.createElement('div');
    card.className = "metric";
    card.innerHTML = `
      <div class="t">${label}</div>
      <div class="v" id="val_${m.id}">--</div>
      <div class="s">${metricHint(m)}</div>
    `;
    panel.appendChild(card);
  });
}
function metricHint(m) {
  if(m.type === "linVel") return "Linear velocity (m/s) of the joint point in 2D.";
  if(m.type === "angVel") return "Angular velocity (¬∞/s) from change in joint angle frame-to-frame.";
  if(m.type === "angle") return (m.joint === "wrist" || m.joint === "ankle")
    ? "Proxy angle in 2D (limited without hand/foot keypoints). Trend only."
    : "Joint angle (¬∞) in 2D.";
  return "";
}

/* =========================================================
   Collapsible + PiP + Status
========================================================= */
function toggleCollapse(id) {
  const el = document.getElementById(id);
  el.classList.toggle('collapsed');
  document.getElementById(id+'_lbl').innerText = el.classList.contains('collapsed') ? "Expand" : "Collapse";
}
function togglePiP() { document.body.classList.toggle('pip-on'); }

function showStatus(msg, type) {
  const el = document.getElementById('statusMessage');
  el.innerText = msg;
  el.className = `status-message status-${type}`;
  el.style.display = 'block';
  setTimeout(() => el.style.display='none', 3000);
}
function setStatusText(t) { document.getElementById('statusText').innerText = t; }
function setSourceText(t) { document.getElementById('sourceText').innerText = t; }

/* =========================================================
   Utility
========================================================= */
function clamp(x, a, b){ return Math.max(a, Math.min(b, x)); }
function clampInt(x, a, b){ return Math.max(a, Math.min(b, Math.round(x))); }
function round(x, dp){ if(!isFinite(x)) return 0; const p = Math.pow(10,dp); return Math.round(x*p)/p; }
function slice(arr, i0, i1){ return arr.slice(i0, i1+1); }
function mean(arr){ if(!arr.length) return 0; return arr.reduce((s,x)=>s+(+x||0),0)/arr.length; }
function maxAbs(arr){ if(!arr.length) return 0; let m=0; arr.forEach(x=>{ const a=Math.abs(+x||0); if(a>m) m=a; }); return m; }
function argMaxAbs(arr){ let best=0, bestV=-1; for(let i=0;i<arr.length;i++){ const a=Math.abs(+arr[i]||0); if(a>bestV){ bestV=a; best=i; } } return best; }
function safeDiv(x, d){ return (d===0)?0:(x/d); }
</script>
</body>
</html>
