<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <title>Sport Performance Analyzer (iOS)</title>

  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.11.0"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@2.1.0"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

  <style>
    * { margin:0; padding:0; box-sizing:border-box; }
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 16px;
    }
    .container {
      max-width: 1400px;
      margin: 0 auto;
      background: #fff;
      border-radius: 18px;
      padding: 18px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.25);
    }
    h1 { text-align:center; color:#667eea; margin-bottom:6px; font-size:2.1em; }
    .subtitle { text-align:center; color:#666; margin-bottom:16px; font-size:1.02em; }

    /* Layout: left scroll content + right sticky video panel */
    .layout {
      display: grid;
      grid-template-columns: 1.05fr 0.95fr;
      gap: 16px;
      align-items: start;
    }
    @media (max-width: 980px) { .layout { grid-template-columns: 1fr; } }

    .card {
      background: #f8f9fa;
      border-radius: 14px;
      padding: 14px;
    }

    .form-grid {
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(190px, 1fr));
      gap: 10px;
      margin-top: 10px;
    }
    label { font-weight: 800; margin-bottom: 6px; color:#333; display:block; }
    input, select {
      width: 100%;
      padding: 10px;
      border: 2px solid #ddd;
      border-radius: 10px;
      font-size: 14px;
    }
    input:focus, select:focus { outline:none; border-color:#667eea; }

    .btn {
      padding: 11px 14px;
      border: none;
      border-radius: 12px;
      font-size: 14px;
      font-weight: 900;
      cursor: pointer;
      margin: 8px 8px 0 0;
    }
    .btn-primary { background:#667eea; color:#fff; }
    .btn-success { background:#10b981; color:#fff; }
    .btn-danger  { background:#ef4444; color:#fff; }
    .btn:disabled { background:#cfcfcf; cursor:not-allowed; }

    .status-message{
      display:none;
      text-align:center;
      padding: 10px 12px;
      border-radius: 12px;
      font-weight: 900;
      margin: 10px 0 14px 0;
    }
    .status-success { background:#d1fae5; color:#065f46; }
    .status-error { background:#fee2e2; color:#991b1b; }
    .status-info { background:#dbeafe; color:#1e40af; }

    /* Sticky video panel */
    .sticky {
      position: sticky;
      top: 10px;
    }
    @media (max-width: 980px) {
      .sticky { position: sticky; top: 0; z-index: 50; }
    }

    .video-wrap {
      position: relative;
      background:#000;
      border-radius: 14px;
      overflow:hidden;
    }
    video {
      width:100%;
      height:auto;
      display:block;
      position: relative;
      z-index: 1;
      transform: translateZ(0);
      -webkit-transform: translateZ(0);
    }
    canvas#overlay {
      width:100%;
      height:auto;
      display:block;
      position:absolute;
      left:0; top:0;
      z-index: 5;
      pointer-events:none;
    }

    .hud {
      position:absolute;
      top: 10px; right: 10px;
      z-index: 10;
      background: rgba(0,0,0,0.72);
      color:#fff;
      padding: 6px 10px;
      border-radius: 10px;
      font-size: 13px;
      font-weight: 900;
      display:flex;
      gap:10px;
      align-items:center;
      max-width: 95%;
    }
    .hud small { font-weight: 800; opacity: 0.9; }

    .divider { height: 1px; background:#e9e9e9; margin: 12px 0; }

    .toggle-grid{
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 8px 12px;
      margin-top: 10px;
    }
    .toggle{
      display:flex;
      gap:10px;
      align-items:center;
      background:#fff;
      border-radius: 12px;
      padding: 10px 12px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.06);
      user-select:none;
    }
    .toggle input{ width:auto; transform: scale(1.15); }

    .metrics-grid{
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 10px;
      margin-top: 10px;
    }
    .metric{
      background:#fff;
      border-radius: 14px;
      padding: 12px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.06);
    }
    .metric .t{ color:#666; font-weight:800; font-size: .92em; margin-bottom: 6px; }
    .metric .v{ color:#667eea; font-weight: 1000; font-size: 1.55em; }
    .unit{ color:#999; font-weight: 900; font-size: .75em; margin-left: 6px; }

    /* Charts */
    .charts-grid{
      display:grid;
      grid-template-columns: 1fr;
      gap: 12px;
      margin-top: 10px;
    }
    .chart-card{
      background:#fff;
      border-radius: 14px;
      padding: 12px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.06);
    }
    .chart-title{
      display:flex;
      justify-content: space-between;
      align-items:center;
      gap: 10px;
      margin-bottom: 8px;
    }
    .chart-title b{ color:#333; }
    .chart-title span{ color:#666; font-weight: 800; font-size: .9em; }
    canvas.chart{
      width: 100%;
      height: 140px; /* CSS height; actual pixels set in JS for sharpness */
      display:block;
      border-radius: 10px;
      background: #fafafa;
    }

    .participants-list .item{
      background:#fff;
      border-radius: 14px;
      padding: 12px;
      margin-top: 10px;
      display:flex;
      justify-content: space-between;
      gap: 12px;
      align-items:center;
      box-shadow: 0 2px 10px rgba(0,0,0,0.06);
    }

    .mini { color:#666; font-size: .88em; line-height: 1.35; margin-top: 8px; }
  </style>
</head>

<body>
  <div class="container">
    <h1>üèÉ‚Äç‚ôÇÔ∏è Sport Performance Analyzer</h1>
    <p class="subtitle">Sticky video + pose overlay + angles + real-time kinetics charts (iOS Safari friendly)</p>

    <div id="statusMessage" class="status-message"></div>

    <div class="layout">
      <!-- LEFT: Scrollable content -->
      <div>
        <div class="card">
          <h3>Participant</h3>
          <div class="form-grid">
            <div>
              <label for="participantName">Name *</label>
              <input id="participantName" placeholder="Enter name">
            </div>
            <div>
              <label for="participantSex">Sex *</label>
              <select id="participantSex">
                <option value="">Select</option>
                <option value="male">Male</option>
                <option value="female">Female</option>
                <option value="other">Other</option>
              </select>
            </div>
            <div>
              <label for="participantAge">Age *</label>
              <input id="participantAge" type="number" min="5" max="120" placeholder="Age">
            </div>
            <div>
              <label for="participantMass">Mass (kg) *</label>
              <input id="participantMass" type="number" min="20" max="300" step="0.1" placeholder="kg">
            </div>
            <div>
              <label for="participantHeight">Height (cm) *</label>
              <input id="participantHeight" type="number" min="50" max="250" step="0.1" placeholder="cm">
            </div>
          </div>
          <button class="btn btn-success" onclick="addParticipant()">Add Participant</button>

          <div class="divider"></div>

          <label for="selectedParticipant">Select Participant for Recording</label>
          <select id="selectedParticipant"></select>

          <div class="form-grid">
            <div>
              <label for="fpsSelection">Requested FPS</label>
              <select id="fpsSelection">
                <option value="30">30 FPS</option>
                <option value="60">60 FPS</option>
                <option value="120">120 FPS</option>
                <option value="240">240 FPS</option>
              </select>
            </div>
            <div>
              <label for="cameraFacing">Camera</label>
              <select id="cameraFacing">
                <option value="environment">Back</option>
                <option value="user">Front</option>
              </select>
            </div>
            <div>
              <label for="planeSelection">Plane</label>
              <select id="planeSelection">
                <option value="sagittal">Sagittal</option>
                <option value="frontal">Frontal</option>
                <option value="transverse">Transverse (2D proxy)</option>
              </select>
            </div>
            <div>
              <label for="windowSeconds">Chart Window</label>
              <select id="windowSeconds">
                <option value="5">5s</option>
                <option value="10" selected>10s</option>
                <option value="15">15s</option>
                <option value="20">20s</option>
              </select>
            </div>
          </div>

          <button class="btn btn-primary" onclick="startCamera()">Start Camera</button>
          <button class="btn btn-primary" onclick="stopCamera()">Stop Camera</button>
          <button class="btn btn-success" id="recordBtn" onclick="startRecording()" disabled>Start Recording</button>
          <button class="btn btn-danger" id="stopBtn" onclick="stopRecording()" disabled>Stop Recording</button>

          <div class="mini">
            iOS note: FPS may be negotiated down. Overlay is drawn on a canvas above the video (z-index fixed).
          </div>
        </div>

        <div class="card" style="margin-top: 12px;">
          <h3>Overlay Controls</h3>
          <div class="toggle-grid">
            <div class="toggle"><input type="checkbox" id="optSkeleton" checked><label for="optSkeleton">Stick figure</label></div>
            <div class="toggle"><input type="checkbox" id="optJoints" checked><label for="optJoints">Joint dots</label></div>
            <div class="toggle"><input type="checkbox" id="optLabels" checked><label for="optLabels">Joint labels</label></div>
            <div class="toggle"><input type="checkbox" id="optAngleLabels" checked><label for="optAngleLabels">Live angle labels</label></div>
            <div class="toggle"><input type="checkbox" id="optCOM" checked><label for="optCOM">COM</label></div>
          </div>
        </div>

        <div class="card" style="margin-top: 12px;">
          <h3>Angles (Real-time)</h3>
          <div class="metrics-grid">
            <div class="metric"><div class="t">Shoulder Angle (R / L)</div><div class="v" id="shoulderAngles">0 / 0<span class="unit">¬∞</span></div></div>
            <div class="metric"><div class="t">Elbow Angle (R / L)</div><div class="v" id="elbowAngles">0 / 0<span class="unit">¬∞</span></div></div>
            <div class="metric"><div class="t">Wrist Angle (R / L)</div><div class="v" id="wristAngles">0 / 0<span class="unit">¬∞</span></div></div>
            <div class="metric"><div class="t">Hip Angle (R / L)</div><div class="v" id="hipAngles">0 / 0<span class="unit">¬∞</span></div></div>
            <div class="metric"><div class="t">Knee Angle (R / L)</div><div class="v" id="kneeAngles">0 / 0<span class="unit">¬∞</span></div></div>
            <div class="metric"><div class="t">Ankle Angle (R / L)</div><div class="v" id="ankleAngles">0 / 0<span class="unit">¬∞</span></div></div>
          </div>
        </div>

        <div class="card" style="margin-top: 12px;">
          <h3>Kinetics Charts (Real-time)</h3>
          <div class="charts-grid">
            <div class="chart-card">
              <div class="chart-title"><b>Force |F| (N)</b><span id="lblForce">0.0 N</span></div>
              <canvas id="chartForce" class="chart"></canvas>
            </div>
            <div class="chart-card">
              <div class="chart-title"><b>Moment œÑz (N¬∑m)</b><span id="lblMoment">0.00 N¬∑m</span></div>
              <canvas id="chartMoment" class="chart"></canvas>
            </div>
            <div class="chart-card">
              <div class="chart-title"><b>Impulse ‚à´|F|dt (N¬∑s)</b><span id="lblImpulse">0.00 N¬∑s</span></div>
              <canvas id="chartImpulse" class="chart"></canvas>
            </div>
            <div class="chart-card">
              <div class="chart-title"><b>Angular Impulse ‚à´œÑdt (N¬∑m¬∑s)</b><span id="lblAngImpulse">0.00 N¬∑m¬∑s</span></div>
              <canvas id="chartAngImpulse" class="chart"></canvas>
            </div>
            <div class="chart-card">
              <div class="chart-title"><b>Angular Momentum Lz (kg¬∑m¬≤/s)</b><span id="lblAngMom">0.00</span></div>
              <canvas id="chartAngMom" class="chart"></canvas>
            </div>
          </div>

          <div class="mini">
            Charts show a rolling window (5‚Äì20s). Values are pose-based estimates (2D).
          </div>
        </div>

        <div class="card participants-list" style="margin-top: 12px;">
          <h3>Participants (<span id="participantCount">0</span>/10)</h3>
          <div id="participantsList"></div>
          <button class="btn btn-primary" onclick="downloadData()">üìä Download All Data (XLSX)</button>
        </div>
      </div>

      <!-- RIGHT: Sticky video -->
      <div class="sticky">
        <div class="card">
          <h3>Sticky Video (Always Visible)</h3>
          <div class="video-wrap">
            <video id="video" playsinline muted></video>
            <canvas id="overlay"></canvas>
            <div class="hud">
              <span id="fpsIndicator">FPS: 0</span>
              <small id="negotiatedInfo">‚Äî</small>
            </div>
          </div>
          <div class="mini">
            If overlay disappears: ensure ‚ÄúStick figure‚Äù is ON and iOS permission is granted.
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
  // ======================
  // iOS Safari-safe Pose + Sticky overlay + Charts
  // ======================

  let detector = null;
  let video = null;
  let overlay = null;
  let octx = null;
  let animationId = null;
  let streamRef = null;

  let isRecording = false;
  let recordingData = [];
  let participants = [];
  let currentParticipant = null;

  let detectedFPS = 0;
  let frameCount = 0;
  let lastFPSUpdate = Date.now();

  // Kinematics state
  let prevState = null;     // { t, com_m, v_mps }
  let prevKpMap = null;
  let prevKpTime = null;

  // Impulse accumulators (for current recording session)
  let impulse_Ns = 0;
  let angImpulse_Nms = 0;
  let lastImpulseT = null;

  const KP = {
    nose: 0,
    left_eye: 1, right_eye: 2,
    left_ear: 3, right_ear: 4,
    shoulder_L: 5, shoulder_R: 6,
    elbow_L: 7, elbow_R: 8,
    wrist_L: 9, wrist_R: 10,
    hip_L: 11, hip_R: 12,
    knee_L: 13, knee_R: 14,
    ankle_L: 15, ankle_R: 16
  };

  const JOINT_LABELS = [
    "nose","left_eye","right_eye","left_ear","right_ear",
    "shoulder_L","shoulder_R","elbow_L","elbow_R","wrist_L","wrist_R",
    "hip_L","hip_R","knee_L","knee_R","ankle_L","ankle_R"
  ];

  const SKELETON = [
    [KP.shoulder_L, KP.shoulder_R],
    [KP.shoulder_L, KP.elbow_L],
    [KP.elbow_L, KP.wrist_L],
    [KP.shoulder_R, KP.elbow_R],
    [KP.elbow_R, KP.wrist_R],
    [KP.shoulder_L, KP.hip_L],
    [KP.shoulder_R, KP.hip_R],
    [KP.hip_L, KP.hip_R],
    [KP.hip_L, KP.knee_L],
    [KP.knee_L, KP.ankle_L],
    [KP.hip_R, KP.knee_R],
    [KP.knee_R, KP.ankle_R],
  ];

  // ---------- Chart buffers ----------
  const chartSeries = {
    force: [],
    moment: [],
    impulse: [],
    angImpulse: [],
    angMom: []
  };

  const charts = {
    force: { canvasId: "chartForce", labelId: "lblForce", unit: "N" },
    moment:{ canvasId: "chartMoment", labelId: "lblMoment", unit: "N¬∑m" },
    impulse:{ canvasId: "chartImpulse", labelId: "lblImpulse", unit: "N¬∑s" },
    angImpulse:{ canvasId: "chartAngImpulse", labelId: "lblAngImpulse", unit: "N¬∑m¬∑s" },
    angMom:{ canvasId: "chartAngMom", labelId: "lblAngMom", unit: "" }
  };

  // ---------- Utils ----------
  function showStatus(message, type) {
    const el = document.getElementById('statusMessage');
    el.className = `status-message status-${type}`;
    el.textContent = message;
    el.style.display = 'block';
    setTimeout(() => { el.style.display = 'none'; }, 3200);
  }

  function clampScore(kp, thr=0.3) {
    return kp && typeof kp.score === "number" && kp.score >= thr;
  }

  function midpoint(a,b) {
    return { x:(a.x+b.x)/2, y:(a.y+b.y)/2, score: Math.min(a.score??0, b.score??0) };
  }

  function calcAngle(p1,p2,p3) {
    const rad = Math.atan2(p3.y-p2.y, p3.x-p2.x) - Math.atan2(p1.y-p2.y, p1.x-p2.x);
    let ang = Math.abs(rad*180/Math.PI);
    if (ang>180) ang = 360-ang;
    return ang;
  }

  function drawText(text, x, y) {
    octx.font = '14px Segoe UI, Arial';
    octx.fillStyle = 'rgba(0,0,0,0.65)';
    octx.fillText(text, x+1, y+1);
    octx.fillStyle = '#ffffff';
    octx.fillText(text, x, y);
  }

  function getOpts() {
    return {
      skeleton: document.getElementById('optSkeleton').checked,
      joints: document.getElementById('optJoints').checked,
      labels: document.getElementById('optLabels').checked,
      angleLabels: document.getElementById('optAngleLabels').checked,
      com: document.getElementById('optCOM').checked,
      plane: document.getElementById('planeSelection').value
    };
  }

  function vecSub(a,b){ return {x:a.x-b.x, y:a.y-b.y}; }
  function vecMul(a,s){ return {x:a.x*s, y:a.y*s}; }
  function vecLen(a){ return Math.sqrt(a.x*a.x + a.y*a.y); }
  function crossZ(a,b){ return a.x*b.y - a.y*b.x; }

  function pxToMetersScale() {
    const h_m = currentParticipant ? (currentParticipant.height / 100) : 1.70;
    const px = overlay ? overlay.height : 720;
    return h_m / px;
  }

  function resizeOverlayToVideo() {
    const vw = video.videoWidth || 0;
    const vh = video.videoHeight || 0;
    if (vw && vh) {
      if (overlay.width !== vw) overlay.width = vw;
      if (overlay.height !== vh) overlay.height = vh;
    }
  }

  function updateFPS() {
    frameCount++;
    const now = Date.now();
    if (now - lastFPSUpdate >= 1000) {
      detectedFPS = frameCount;
      document.getElementById('fpsIndicator').textContent = `FPS: ${detectedFPS}`;
      frameCount = 0;
      lastFPSUpdate = now;
    }
  }

  // ---------- Charts ----------
  function getWindowSec() {
    return parseInt(document.getElementById('windowSeconds').value, 10);
  }

  function pushPoint(seriesName, t, value) {
    const win = getWindowSec();
    const arr = chartSeries[seriesName];
    arr.push({ t, v: value });
    // drop old points
    const tMin = t - win;
    while (arr.length && arr[0].t < tMin) arr.shift();
  }

  function sizeChartCanvas(c) {
    // Make charts sharp on high-DPI
    const dpr = window.devicePixelRatio || 1;
    const cssW = c.clientWidth;
    const cssH = c.clientHeight;
    const w = Math.floor(cssW * dpr);
    const h = Math.floor(cssH * dpr);
    if (c.width !== w || c.height !== h) {
      c.width = w; c.height = h;
    }
    return { w, h, dpr };
  }

  function drawChart(seriesName) {
    const meta = charts[seriesName];
    const c = document.getElementById(meta.canvasId);
    const ctx = c.getContext("2d");
    const { w, h } = sizeChartCanvas(c);

    ctx.clearRect(0,0,w,h);

    // Background grid
    ctx.fillStyle = "#fafafa";
    ctx.fillRect(0,0,w,h);

    ctx.strokeStyle = "rgba(0,0,0,0.08)";
    ctx.lineWidth = 1;
    for (let i=1;i<=4;i++){
      const y = (h*i)/5;
      ctx.beginPath();
      ctx.moveTo(0,y);
      ctx.lineTo(w,y);
      ctx.stroke();
    }

    const data = chartSeries[seriesName];
    if (!data.length) return;

    const t0 = data[0].t;
    const t1 = data[data.length-1].t;
    const dt = Math.max(1e-6, t1 - t0);

    let minV = data[0].v, maxV = data[0].v;
    for (const p of data) { if (p.v < minV) minV = p.v; if (p.v > maxV) maxV = p.v; }
    if (minV === maxV) { minV -= 1; maxV += 1; }

    // Slight padding
    const pad = 0.08 * (maxV - minV);
    minV -= pad; maxV += pad;

    // Line
    ctx.strokeStyle = "rgba(102,126,234,0.95)";
    ctx.lineWidth = 3;
    ctx.beginPath();
    for (let i=0;i<data.length;i++){
      const x = ( (data[i].t - t0) / dt ) * w;
      const y = h - ( (data[i].v - minV) / (maxV - minV) ) * h;
      if (i===0) ctx.moveTo(x,y);
      else ctx.lineTo(x,y);
    }
    ctx.stroke();

    // Label min/max
    ctx.fillStyle = "rgba(0,0,0,0.55)";
    ctx.font = "12px Segoe UI, Arial";
    ctx.fillText(`${maxV.toFixed(2)}`, 6, 14);
    ctx.fillText(`${minV.toFixed(2)}`, 6, h - 6);
  }

  function drawAllCharts() {
    drawChart("force");
    drawChart("moment");
    drawChart("impulse");
    drawChart("angImpulse");
    drawChart("angMom");
  }

  // ---------- Pose model init ----------
  async function initializePoseDetection() {
    // iOS Safari: prefer WebGL
    try {
      await tf.setBackend('webgl');
      await tf.ready();
    } catch (e) {
      // fallback
      try { await tf.setBackend('wasm'); await tf.ready(); } catch (_) {}
    }
    const model = window.poseDetection.SupportedModels.MoveNet;
    detector = await window.poseDetection.createDetector(model, {
      modelType: window.poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING
    });
  }

  // ---------- Camera ----------
  async function startCamera() {
    try {
      video = document.getElementById("video");
      overlay = document.getElementById("overlay");
      octx = overlay.getContext("2d");

      const reqFps = parseInt(document.getElementById("fpsSelection").value, 10);
      const facingMode = document.getElementById("cameraFacing").value;

      video.setAttribute("playsinline", "");
      video.muted = true;
      video.autoplay = true;

      showStatus("Starting camera‚Ä¶", "info");

      const stream = await navigator.mediaDevices.getUserMedia({
        audio: false,
        video: {
          facingMode: { ideal: facingMode },
          width: { ideal: 1280 },
          height: { ideal: 720 }
        }
      });

      streamRef = stream;
      video.srcObject = stream;

      await new Promise(res => video.onloadedmetadata = () => res());

      const track = stream.getVideoTracks()[0];
      if (track && track.applyConstraints) {
        try {
          await track.applyConstraints({ frameRate: { ideal: reqFps, max: reqFps } });
        } catch (_) {}
      }

      await video.play();
      resizeOverlayToVideo();

      const settings = track && track.getSettings ? track.getSettings() : {};
      document.getElementById("negotiatedInfo").textContent =
        `${settings.width || video.videoWidth}√ó${settings.height || video.videoHeight} ‚Ä¢ req ${reqFps}fps ‚Ä¢ got ${settings.frameRate || "?"}fps`;

      if (!detector) {
        showStatus("Loading pose model‚Ä¶", "info");
        await initializePoseDetection();
      }

      document.getElementById("recordBtn").disabled = false;

      // reset states
      prevState = null;
      prevKpMap = null;
      prevKpTime = null;

      impulse_Ns = 0;
      angImpulse_Nms = 0;
      lastImpulseT = null;

      showStatus("Ready ‚úÖ", "success");

      if (animationId) cancelAnimationFrame(animationId);
      loop();

    } catch (err) {
      console.error(err);
      showStatus("Camera error: " + (err.message || err), "error");
    }
  }

  function stopCamera() {
    if (animationId) cancelAnimationFrame(animationId);
    animationId = null;

    if (video) { video.pause(); video.srcObject = null; }
    if (streamRef) { streamRef.getTracks().forEach(t => t.stop()); streamRef = null; }

    document.getElementById("recordBtn").disabled = true;
    document.getElementById("stopBtn").disabled = true;

    isRecording = false;
    currentParticipant = null;

    showStatus("Camera stopped.", "info");
  }

  // ---------- Overlay drawing ----------
  function drawOverlay(kps, neck, opts) {
    // Skeleton
    if (opts.skeleton) {
      octx.lineWidth = 4;
      octx.strokeStyle = "rgba(255,0,0,0.95)";
      for (const [i,j] of SKELETON) {
        const a = kps[i], b = kps[j];
        if (clampScore(a) && clampScore(b)) {
          octx.beginPath();
          octx.moveTo(a.x, a.y);
          octx.lineTo(b.x, b.y);
          octx.stroke();
        }
      }
    }

    // Joints + labels
    if (opts.joints) {
      for (let i=0;i<kps.length;i++){
        const kp = kps[i];
        if (!clampScore(kp)) continue;
        octx.beginPath();
        octx.arc(kp.x, kp.y, 6, 0, Math.PI*2);
        octx.fillStyle = "rgba(0,255,0,0.95)";
        octx.fill();
        if (opts.labels) drawText(JOINT_LABELS[i], kp.x + 8, kp.y - 8);
      }
      if (neck) {
        octx.beginPath();
        octx.arc(neck.x, neck.y, 7, 0, Math.PI*2);
        octx.fillStyle = "rgba(0,200,255,0.95)";
        octx.fill();
        if (opts.labels) drawText("neck", neck.x + 8, neck.y - 8);
      }
    }
  }

  // ---------- Main loop ----------
  async function loop() {
    try {
      if (!video || video.readyState < 2 || !detector) {
        animationId = requestAnimationFrame(loop);
        return;
      }

      resizeOverlayToVideo();
      octx.clearRect(0,0,overlay.width, overlay.height);

      const poses = await detector.estimatePoses(video);
      if (poses && poses.length) {
        const kps = poses[0].keypoints;
        const opts = getOpts();

        const shL = kps[KP.shoulder_L], shR = kps[KP.shoulder_R];
        const neck = (clampScore(shL) && clampScore(shR)) ? midpoint(shL, shR) : null;

        drawOverlay(kps, neck, opts);

        const metrics = computeMetrics(kps, neck, opts);

        // Recording
        if (isRecording && currentParticipant) {
          recordingData.push(metrics.frameRecord);
        }
      }

      updateFPS();
      animationId = requestAnimationFrame(loop);

    } catch (e) {
      console.error("Loop error:", e);
      showStatus("Pose estimation error (recovering)‚Ä¶", "error");
      animationId = requestAnimationFrame(loop);
    }
  }

  // ---------- Metrics + labels + charts ----------
  function computeMetrics(kps, neck, opts) {
    // Keypoints
    const shR = kps[KP.shoulder_R], elR = kps[KP.elbow_R], wrR = kps[KP.wrist_R];
    const shL = kps[KP.shoulder_L], elL = kps[KP.elbow_L], wrL = kps[KP.wrist_L];

    const hipR = kps[KP.hip_R], knR = kps[KP.knee_R], anR = kps[KP.ankle_R];
    const hipL = kps[KP.hip_L], knL = kps[KP.knee_L], anL = kps[KP.ankle_L];

    // Angles:
    // Shoulder angle: elbow - shoulder - hip
    // Elbow angle: shoulder - elbow - wrist
    // Wrist angle (proxy): elbow - wrist - (wrist + (wrist-elbow))  => uses forearm direction continuation
    // Hip: shoulder - hip - knee
    // Knee: hip - knee - ankle
    // Ankle: knee - ankle - (ankle + (ankle-knee)) => shank continuation proxy
    let shoulderAngR=null, shoulderAngL=null,
        elbowAngR=null, elbowAngL=null,
        wristAngR=null, wristAngL=null,
        hipAngR=null, hipAngL=null,
        kneeAngR=null, kneeAngL=null,
        ankleAngR=null, ankleAngL=null;

    if (clampScore(elR) && clampScore(shR) && clampScore(hipR)) shoulderAngR = calcAngle(elR, shR, hipR);
    if (clampScore(elL) && clampScore(shL) && clampScore(hipL)) shoulderAngL = calcAngle(elL, shL, hipL);

    if (clampScore(shR) && clampScore(elR) && clampScore(wrR)) elbowAngR = calcAngle(shR, elR, wrR);
    if (clampScore(shL) && clampScore(elL) && clampScore(wrL)) elbowAngL = calcAngle(shL, elL, wrL);

    if (clampScore(shR) && clampScore(hipR) && clampScore(knR)) hipAngR = calcAngle(shR, hipR, knR);
    if (clampScore(shL) && clampScore(hipL) && clampScore(knL)) hipAngL = calcAngle(shL, hipL, knL);

    if (clampScore(hipR) && clampScore(knR) && clampScore(anR)) kneeAngR = calcAngle(hipR, knR, anR);
    if (clampScore(hipL) && clampScore(knL) && clampScore(anL)) kneeAngL = calcAngle(hipL, knL, anL);

    // Wrist proxy: use forearm direction extension
    if (clampScore(elR) && clampScore(wrR)) {
      const p3 = { x: wrR.x + (wrR.x - elR.x), y: wrR.y + (wrR.y - elR.y) };
      wristAngR = calcAngle(elR, wrR, p3);
    }
    if (clampScore(elL) && clampScore(wrL)) {
      const p3 = { x: wrL.x + (wrL.x - elL.x), y: wrL.y + (wrL.y - elL.y) };
      wristAngL = calcAngle(elL, wrL, p3);
    }

    // Ankle proxy: shank direction extension
    if (clampScore(knR) && clampScore(anR)) {
      const p3 = { x: anR.x + (anR.x - knR.x), y: anR.y + (anR.y - knR.y) };
      ankleAngR = calcAngle(knR, anR, p3);
    }
    if (clampScore(knL) && clampScore(anL)) {
      const p3 = { x: anL.x + (anL.x - knL.x), y: anL.y + (anL.y - knL.y) };
      ankleAngL = calcAngle(knL, anL, p3);
    }

    // Update angle panels
    document.getElementById("shoulderAngles").innerHTML = `${shoulderAngR?Math.round(shoulderAngR):0} / ${shoulderAngL?Math.round(shoulderAngL):0}<span class="unit">¬∞</span>`;
    document.getElementById("elbowAngles").innerHTML    = `${elbowAngR?Math.round(elbowAngR):0} / ${elbowAngL?Math.round(elbowAngL):0}<span class="unit">¬∞</span>`;
    document.getElementById("wristAngles").innerHTML    = `${wristAngR?Math.round(wristAngR):0} / ${wristAngL?Math.round(wristAngL):0}<span class="unit">¬∞</span>`;
    document.getElementById("hipAngles").innerHTML      = `${hipAngR?Math.round(hipAngR):0} / ${hipAngL?Math.round(hipAngL):0}<span class="unit">¬∞</span>`;
    document.getElementById("kneeAngles").innerHTML     = `${kneeAngR?Math.round(kneeAngR):0} / ${kneeAngL?Math.round(kneeAngL):0}<span class="unit">¬∞</span>`;
    document.getElementById("ankleAngles").innerHTML    = `${ankleAngR?Math.round(ankleAngR):0} / ${ankleAngL?Math.round(ankleAngL):0}<span class="unit">¬∞</span>`;

    // Live labels on video
    if (opts.angleLabels) {
      if (shoulderAngR && clampScore(shR)) drawText(`Shoulder R ${Math.round(shoulderAngR)}¬∞`, shR.x + 10, shR.y + 18);
      if (shoulderAngL && clampScore(shL)) drawText(`Shoulder L ${Math.round(shoulderAngL)}¬∞`, shL.x + 10, shL.y + 18);

      if (elbowAngR && clampScore(elR)) drawText(`Elbow R ${Math.round(elbowAngR)}¬∞`, elR.x + 10, elR.y + 18);
      if (elbowAngL && clampScore(elL)) drawText(`Elbow L ${Math.round(elbowAngL)}¬∞`, elL.x + 10, elL.y + 18);

      if (wristAngR && clampScore(wrR)) drawText(`Wrist R ${Math.round(wristAngR)}¬∞`, wrR.x + 10, wrR.y + 18);
      if (wristAngL && clampScore(wrL)) drawText(`Wrist L ${Math.round(wristAngL)}¬∞`, wrL.x + 10, wrL.y + 18);

      if (hipAngR && clampScore(hipR)) drawText(`Hip R ${Math.round(hipAngR)}¬∞`, hipR.x + 10, hipR.y + 18);
      if (hipAngL && clampScore(hipL)) drawText(`Hip L ${Math.round(hipAngL)}¬∞`, hipL.x + 10, hipL.y + 18);

      if (kneeAngR && clampScore(knR)) drawText(`Knee R ${Math.round(kneeAngR)}¬∞`, knR.x + 10, knR.y + 18);
      if (kneeAngL && clampScore(knL)) drawText(`Knee L ${Math.round(kneeAngL)}¬∞`, knL.x + 10, knL.y + 18);

      if (ankleAngR && clampScore(anR)) drawText(`Ankle R ${Math.round(ankleAngR)}¬∞`, anR.x + 10, anR.y + 18);
      if (ankleAngL && clampScore(anL)) drawText(`Ankle L ${Math.round(ankleAngL)}¬∞`, anL.x + 10, anL.y + 18);
    }

    // COM estimation
    let comPx = null;
    const okSh = clampScore(shL) && clampScore(shR);
    const okHp = clampScore(hipL) && clampScore(hipR);
    const shMid = okSh ? midpoint(shL, shR) : null;
    const hpMid = okHp ? midpoint(hipL, hipR) : null;

    if (okSh && okHp) comPx = { x: shMid.x*0.4 + hpMid.x*0.6, y: shMid.y*0.4 + hpMid.y*0.6 };
    else if (okHp) comPx = { x: hpMid.x, y: hpMid.y };
    else if (clampScore(hipR)) comPx = { x: hipR.x, y: hipR.y };

    if (opts.com && comPx) {
      octx.beginPath();
      octx.arc(comPx.x, comPx.y, 7, 0, Math.PI*2);
      octx.fillStyle = "rgba(255,255,0,0.95)";
      octx.fill();
      drawText("COM", comPx.x + 8, comPx.y - 8);
    }

    // Kinetics (pose-based)
    const t = performance.now() / 1000;
    const s = pxToMetersScale();

    const mass = currentParticipant ? currentParticipant.mass : 70;

    let Fmag = 0, tau = 0, Lz = 0;

    // COM-based acceleration -> force
    if (comPx) {
      const com_m = { x: comPx.x * s, y: comPx.y * s };

      if (prevState) {
        const dt = t - prevState.t;
        if (dt > 1e-4 && dt < 0.2) {
          const d = vecSub(com_m, prevState.com_m);
          const v = vecMul(d, 1/dt);
          const dv = vecSub(v, prevState.v_mps);
          const a = vecMul(dv, 1/dt);

          const Fvec = { x: mass * a.x, y: mass * a.y };
          Fmag = vecLen(Fvec);

          // Moment about COM: use pelvis as r
          if (okHp) {
            const r_m = { x: (hpMid.x - comPx.x) * s, y: (hpMid.y - comPx.y) * s };
            tau = crossZ(r_m, Fvec);
          }

          // Angular momentum Lz (lumped)
          const lumps = [
            { name:'shoulder_L', kp: shL, m: mass*0.10 },
            { name:'shoulder_R', kp: shR, m: mass*0.10 },
            { name:'hip_L', kp: hipL, m: mass*0.20 },
            { name:'hip_R', kp: hipR, m: mass*0.20 },
            { name:'knee_L', kp: knL, m: mass*0.10 },
            { name:'knee_R', kp: knR, m: mass*0.10 },
            { name:'ankle_L', kp: anL, m: mass*0.05 },
            { name:'ankle_R', kp: anR, m: mass*0.05 },
            { name:'wrist_L', kp: wrL, m: mass*0.05 },
            { name:'wrist_R', kp: wrR, m: mass*0.05 },
          ];

          if (prevKpMap && prevKpTime) {
            const dt2 = t - prevKpTime;
            if (dt2 > 1e-4 && dt2 < 0.2) {
              for (const L of lumps) {
                if (!clampScore(L.kp)) continue;
                const prev = prevKpMap[L.name];
                if (!prev) continue;
                const pos_m = { x: L.kp.x*s, y: L.kp.y*s };
                const prev_m = { x: prev.x*s, y: prev.y*s };
                const v_i = vecMul(vecSub(pos_m, prev_m), 1/dt2);
                const r_i = vecSub(pos_m, com_m);
                Lz += L.m * crossZ(r_i, v_i);
              }
            }
          }

          // Impulse integrators (only meaningful during recording)
          if (isRecording) {
            if (lastImpulseT != null) {
              const dtI = t - lastImpulseT;
              if (dtI > 1e-4 && dtI < 0.2) {
                impulse_Ns += Fmag * dtI;
                angImpulse_Nms += tau * dtI;
              }
            }
            lastImpulseT = t;
          }
        }
      }

      prevState = { t, com_m, v_mps: prevState ? prevState.v_mps : {x:0,y:0} };
      // update v_mps properly on next frame: store it now if we computed it
      if (prevState && prevState.t === t && comPx && prevState.com_m) {
        // leave as-is; v updated in next frame computation block
      }

      // Update prev keypoint map
      prevKpMap = {
        shoulder_L: shL, shoulder_R: shR,
        hip_L: hipL, hip_R: hipR,
        knee_L: knL, knee_R: knR,
        ankle_L: anL, ankle_R: anR,
        wrist_L: wrL, wrist_R: wrR
      };
      prevKpTime = t;
    }

    // Push to charts
    pushPoint("force", t, Fmag);
    pushPoint("moment", t, tau);
    pushPoint("impulse", t, impulse_Ns);
    pushPoint("angImpulse", t, angImpulse_Nms);
    pushPoint("angMom", t, Lz);

    // Update chart header live labels
    document.getElementById("lblForce").textContent = `${Fmag.toFixed(1)} N`;
    document.getElementById("lblMoment").textContent = `${tau.toFixed(2)} N¬∑m`;
    document.getElementById("lblImpulse").textContent = `${impulse_Ns.toFixed(2)} N¬∑s`;
    document.getElementById("lblAngImpulse").textContent = `${angImpulse_Nms.toFixed(2)} N¬∑m¬∑s`;
    document.getElementById("lblAngMom").textContent = `${Lz.toFixed(2)}`;

    // Draw charts at a sane rate (don‚Äôt redraw every pose frame on high FPS)
    throttleCharts(t);

    // Prepare a compact frame record for export
    const frameRecord = {
      t_ms: Date.now(),
      fpsDetected: detectedFPS,
      plane: opts.plane,

      shoulderAngle_R: shoulderAngR ?? null, shoulderAngle_L: shoulderAngL ?? null,
      elbowAngle_R: elbowAngR ?? null, elbowAngle_L: elbowAngL ?? null,
      wristAngle_R: wristAngR ?? null, wristAngle_L: wristAngL ?? null,
      hipAngle_R: hipAngR ?? null, hipAngle_L: hipAngL ?? null,
      kneeAngle_R: kneeAngR ?? null, kneeAngle_L: kneeAngL ?? null,
      ankleAngle_R: ankleAngR ?? null, ankleAngle_L: ankleAngL ?? null,

      force_N: Fmag,
      moment_Nm: tau,
      impulse_Ns: impulse_Ns,
      angImpulse_Nms: angImpulse_Nms,
      angMom_z: Lz,

      joints: {
        shoulder_L: pickJoint(kps, KP.shoulder_L),
        shoulder_R: pickJoint(kps, KP.shoulder_R),
        elbow_L: pickJoint(kps, KP.elbow_L),
        elbow_R: pickJoint(kps, KP.elbow_R),
        wrist_L: pickJoint(kps, KP.wrist_L),
        wrist_R: pickJoint(kps, KP.wrist_R),
        hip_L: pickJoint(kps, KP.hip_L),
        hip_R: pickJoint(kps, KP.hip_R),
        knee_L: pickJoint(kps, KP.knee_L),
        knee_R: pickJoint(kps, KP.knee_R),
        ankle_L: pickJoint(kps, KP.ankle_L),
        ankle_R: pickJoint(kps, KP.ankle_R),
        neck: (neck ? { x: neck.x, y: neck.y, score: neck.score ?? 0.5 } : null)
      }
    };

    return { frameRecord };
  }

  function pickJoint(kps, idx) {
    const kp = kps[idx];
    return clampScore(kp) ? { x: kp.x, y: kp.y, score: kp.score } : null;
  }

  // Chart redraw throttle (~15fps)
  let lastChartDrawT = 0;
  function throttleCharts(t) {
    if (t - lastChartDrawT < 1/15) return;
    lastChartDrawT = t;
    drawAllCharts();
  }

  // ---------- Recording ----------
  function startRecording() {
    const selectedId = document.getElementById("selectedParticipant").value;
    if (!selectedId) { showStatus("Select a participant first!", "error"); return; }
    currentParticipant = participants.find(p => String(p.id) === String(selectedId));
    if (!currentParticipant) { showStatus("Participant not found.", "error"); return; }

    isRecording = true;
    recordingData = [];

    impulse_Ns = 0;
    angImpulse_Nms = 0;
    lastImpulseT = null;

    document.getElementById("recordBtn").disabled = true;
    document.getElementById("stopBtn").disabled = false;

    showStatus(`Recording for ${currentParticipant.name}‚Ä¶`, "info");
  }

  function stopRecording() {
    if (isRecording && currentParticipant && recordingData.length) {
      currentParticipant.recordings.push({
        timestamp: new Date().toISOString(),
        fps: detectedFPS,
        plane: document.getElementById("planeSelection").value,
        totalImpulse_Ns: impulse_Ns,
        totalAngImpulse_Nms: angImpulse_Nms,
        data: recordingData
      });
      updateParticipantsList();
      showStatus(`Saved ‚úÖ ${recordingData.length} frames`, "success");
    } else {
      showStatus("Stopped (no frames saved).", "info");
    }

    isRecording = false;
    recordingData = [];
    currentParticipant = null;

    document.getElementById("recordBtn").disabled = false;
    document.getElementById("stopBtn").disabled = true;
  }

  // ---------- Participants ----------
  function addParticipant() {
    if (participants.length >= 10) { showStatus("Max 10 participants.", "error"); return; }
    const name = document.getElementById('participantName').value.trim();
    const sex = document.getElementById('participantSex').value;
    const age = document.getElementById('participantAge').value;
    const mass = document.getElementById('participantMass').value;
    const height = document.getElementById('participantHeight').value;

    if (!name || !sex || !age || !mass || !height) {
      showStatus("Fill all participant fields.", "error"); return;
    }

    participants.push({
      id: Date.now(),
      name,
      sex,
      age: parseInt(age, 10),
      mass: parseFloat(mass),
      height: parseFloat(height),
      recordings: []
    });

    clearParticipantForm();
    updateParticipantsList();
    showStatus(`Added "${name}" ‚úÖ`, "success");
  }

  function clearParticipantForm() {
    document.getElementById('participantName').value = '';
    document.getElementById('participantSex').value = '';
    document.getElementById('participantAge').value = '';
    document.getElementById('participantMass').value = '';
    document.getElementById('participantHeight').value = '';
  }

  function updateParticipantsList() {
    document.getElementById("participantCount").textContent = participants.length;

    const list = document.getElementById("participantsList");
    list.innerHTML = participants.map(p => `
      <div class="item">
        <div>
          <b>${p.name}</b> ‚Äî ${p.sex}, ${p.age}y, ${p.mass}kg, ${p.height}cm
          <div style="color:#666; font-weight:800; font-size:.88em; margin-top:4px;">
            Recordings: ${p.recordings.length}
          </div>
        </div>
        <button class="btn btn-danger" onclick="removeParticipant(${p.id})">Remove</button>
      </div>
    `).join("");

    const sel = document.getElementById("selectedParticipant");
    sel.innerHTML = `<option value="">Select a participant</option>` +
      participants.map(p => `<option value="${p.id}">${p.name}</option>`).join("");
  }

  function removeParticipant(id) {
    participants = participants.filter(p => p.id !== id);
    updateParticipantsList();
    showStatus("Participant removed.", "info");
  }

  // ---------- Export XLSX ----------
  function downloadData() {
    if (!participants.length) { showStatus("No participants to export!", "error"); return; }

    const wb = XLSX.utils.book_new();

    participants.forEach(p => {
      const rows = [];
      rows.push(["Participant Information"]);
      rows.push(["Name", p.name]);
      rows.push(["Sex", p.sex]);
      rows.push(["Age", p.age]);
      rows.push(["Mass (kg)", p.mass]);
      rows.push(["Height (cm)", p.height]);
      rows.push([]);
      rows.push(["Recordings", p.recordings.length]);

      p.recordings.forEach((rec, idx) => {
        rows.push([]);
        rows.push([`Recording ${idx+1}`, rec.timestamp]);
        rows.push(["Plane", rec.plane]);
        rows.push(["FPS", rec.fps]);
        rows.push(["Total Impulse (N¬∑s)", rec.totalImpulse_Ns]);
        rows.push(["Total Angular Impulse (N¬∑m¬∑s)", rec.totalAngImpulse_Nms]);
        rows.push([]);

        const header = [
          "Frame","t_ms","plane","fpsDetected",
          "shoulderAngle_R","shoulderAngle_L",
          "elbowAngle_R","elbowAngle_L",
          "wristAngle_R","wristAngle_L",
          "hipAngle_R","hipAngle_L",
          "kneeAngle_R","kneeAngle_L",
          "ankleAngle_R","ankleAngle_L",
          "force_N","moment_Nm","impulse_Ns","angImpulse_Nms","angMom_z",
          "shoulder_L_x","shoulder_L_y","shoulder_R_x","shoulder_R_y",
          "elbow_L_x","elbow_L_y","elbow_R_x","elbow_R_y",
          "wrist_L_x","wrist_L_y","wrist_R_x","wrist_R_y",
          "hip_L_x","hip_L_y","hip_R_x","hip_R_y",
          "knee_L_x","knee_L_y","knee_R_x","knee_R_y",
          "ankle_L_x","ankle_L_y","ankle_R_x","ankle_R_y",
          "neck_x","neck_y"
        ];
        rows.push(header);

        rec.data.forEach((f, i) => {
          const j = f.joints || {};
          const xy = (o) => o ? [Number(o.x.toFixed(2)), Number(o.y.toFixed(2))] : ["N/A","N/A"];
          rows.push([
            i, f.t_ms, f.plane, f.fpsDetected,
            f.shoulderAngle_R ?? "N/A", f.shoulderAngle_L ?? "N/A",
            f.elbowAngle_R ?? "N/A", f.elbowAngle_L ?? "N/A",
            f.wristAngle_R ?? "N/A", f.wristAngle_L ?? "N/A",
            f.hipAngle_R ?? "N/A", f.hipAngle_L ?? "N/A",
            f.kneeAngle_R ?? "N/A", f.kneeAngle_L ?? "N/A",
            f.ankleAngle_R ?? "N/A", f.ankleAngle_L ?? "N/A",
            Number((f.force_N ?? 0).toFixed(3)),
            Number((f.moment_Nm ?? 0).toFixed(3)),
            Number((f.impulse_Ns ?? 0).toFixed(3)),
            Number((f.angImpulse_Nms ?? 0).toFixed(3)),
            Number((f.angMom_z ?? 0).toFixed(3)),
            ...xy(j.shoulder_L), ...xy(j.shoulder_R),
            ...xy(j.elbow_L), ...xy(j.elbow_R),
            ...xy(j.wrist_L), ...xy(j.wrist_R),
            ...xy(j.hip_L), ...xy(j.hip_R),
            ...xy(j.knee_L), ...xy(j.knee_R),
            ...xy(j.ankle_L), ...xy(j.ankle_R),
            ...xy(j.neck)
          ]);
        });
      });

      const ws = XLSX.utils.aoa_to_sheet(rows);
      XLSX.utils.book_append_sheet(wb, ws, p.name.substring(0,31));
    });

    XLSX.writeFile(wb, `sport_performance_${new Date().toISOString().split("T")[0]}.xlsx`);
    showStatus("Exported XLSX ‚úÖ", "success");
  }

  // ---------- Boot ----------
  window.addEventListener("load", () => {
    updateParticipantsList();
    // Pre-size charts once
    window.addEventListener("resize", () => drawAllCharts());
    showStatus("Ready. Add participant ‚Üí Start Camera.", "info");
  });
</script>
</body>
</html>
