<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <meta name="author" content="Ng Jun Wei">
  <meta name="copyright" content="¬© 2025 Ng Jun Wei. All rights reserved.">
  <title>Sport Performance Analyzer (iOS) + Joint-Driven Kinetics</title>

  <!-- TFJS + Pose -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.11.0"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@2.1.0"></script>

  <!-- Projectile (COCO-SSD) -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.3"></script>

  <!-- XLSX -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

  <style>
    * { margin:0; padding:0; box-sizing:border-box; }
    body{
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 14px;
      padding-bottom: 80px;
    }
    .container{
      max-width: 1400px;
      margin: 0 auto;
      background:#fff;
      border-radius: 18px;
      padding: 16px;
      box-shadow: 0 18px 55px rgba(0,0,0,0.22);
    }
    h1 { text-align:center; color:#667eea; margin-bottom:6px; font-size:2.05em; }
    .subtitle{ text-align:center; color:#666; margin-bottom:14px; font-size:1.02em; }

    .layout{
      display:grid;
      grid-template-columns: 1.08fr 0.92fr;
      gap: 14px;
      align-items:start;
    }
    @media (max-width: 980px){ .layout{ grid-template-columns: 1fr; } }

    .card{ background:#f8f9fa; border-radius: 14px; padding: 14px; }
    .form-grid{
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(190px, 1fr));
      gap: 10px;
      margin-top: 10px;
    }
    label{ font-weight: 850; margin-bottom: 6px; color:#333; display:block; }
    input, select{
      width:100%;
      padding: 10px;
      border: 2px solid #ddd;
      border-radius: 12px;
      font-size: 14px;
      background:#fff;
    }
    input:focus, select:focus{ outline:none; border-color:#667eea; }

    .btn{
      padding: 11px 14px;
      border: none;
      border-radius: 12px;
      font-size: 14px;
      font-weight: 900;
      cursor:pointer;
      margin: 8px 8px 0 0;
      transition: transform .15s, opacity .15s;
    }
    .btn:hover{ transform: translateY(-1px); }
    .btn:disabled{ background:#cfcfcf !important; cursor:not-allowed; opacity:.85; transform:none; }
    .btn-primary{ background:#667eea; color:#fff; }
    .btn-success{ background:#10b981; color:#fff; }
    .btn-danger { background:#ef4444; color:#fff; }
    .btn-ghost { background: rgba(102,126,234,0.12); color:#3b4bd6; }

    .status-message{
      display:none;
      text-align:center;
      padding: 10px 12px;
      border-radius: 12px;
      font-weight: 950;
      margin: 10px 0 14px 0;
    }
    .status-success{ background:#d1fae5; color:#065f46; }
    .status-error{ background:#fee2e2; color:#991b1b; }
    .status-info{ background:#dbeafe; color:#1e40af; }

    .sticky{ position: sticky; top: 8px; }
    @media (max-width: 980px){ .sticky{ top: 0; z-index: 50; position: static; } }

    .video-wrap{ position:relative; background:#000; border-radius: 14px; overflow:hidden; min-height: 200px; }
    video{
      width:100%;
      height:auto;
      display:block;
      position:relative;
      z-index:1;
    }
    canvas#overlay{
      width:100%;
      height:100%;
      display:block;
      position:absolute;
      left:0; top:0;
      z-index:5;
      pointer-events:none;
    }
    .hud{
      position:absolute;
      top: 10px; right: 10px;
      z-index: 10;
      background: rgba(0,0,0,0.72);
      color:#fff;
      padding: 6px 10px;
      border-radius: 12px;
      font-size: 13px;
      font-weight: 950;
      display:flex;
      flex-direction: column;
      gap:6px;
      align-items:flex-end;
      max-width: 95%;
      white-space: pre-line;
    }
    .hud small{ font-weight: 850; opacity: .92; }
    .divider{ height:1px; background:#e9e9e9; margin: 12px 0; }
    .mini{ color:#666; font-size: .88em; line-height: 1.35; margin-top: 8px; }

    .metrics-grid{
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 10px;
      margin-top: 10px;
    }
    .metric{
      background:#fff;
      border-radius: 14px;
      padding: 12px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.06);
    }
    .metric .t{ color:#666; font-weight:850; font-size:.92em; margin-bottom: 6px; }
    .metric .v{ color:#667eea; font-weight: 1000; font-size: 1.55em; }
    .metric .s{ color:#666; font-weight: 850; font-size: .88em; margin-top: 6px; line-height: 1.25; }

    .chiplist{ margin-top: 10px; display:flex; flex-wrap:wrap; gap: 8px; }
    .chip{
      background:#fff;
      border-radius: 999px;
      padding: 6px 10px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.06);
      display:flex;
      align-items:center;
      gap: 10px;
      font-weight: 900;
      color:#333;
      font-size: 13px;
    }
    .chip button{
      border:none;
      background: rgba(239,68,68,0.12);
      color:#ef4444;
      font-weight: 1000;
      border-radius: 999px;
      padding: 4px 8px;
      cursor:pointer;
    }

    .charts-grid{ display:grid; grid-template-columns: 1fr; gap: 12px; margin-top: 10px; }
    .chart-card{
      background:#fff;
      border-radius: 14px;
      padding: 12px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.06);
    }
    .chart-title{
      display:flex;
      justify-content: space-between;
      align-items:center;
      gap: 10px;
      margin-bottom: 8px;
    }
    .chart-title b{ color:#222; }
    .chart-title span{ color:#666; font-weight: 850; font-size: .9em; }
    canvas.chart{
      width: 100%;
      height: 150px;
      display:block;
      border-radius: 12px;
      background: #fafafa;
    }

    .card-head{
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 6px;
    }
    .collapse-btn{
      display:inline-flex;
      align-items:center;
      gap: 8px;
      border:none;
      cursor:pointer;
      border-radius: 12px;
      padding: 10px 12px;
      font-weight: 1000;
      background: rgba(102,126,234,0.12);
      color:#3b4bd6;
    }
    .collapse-icon{
      width: 10px;
      height: 10px;
      border-right: 3px solid currentColor;
      border-bottom: 3px solid currentColor;
      transform: rotate(45deg);
      transition: transform .18s ease;
      margin-left: 2px;
    }
    .collapsed .collapse-icon{ transform: rotate(-45deg); }
    .collapsible{
      overflow: hidden;
      transition: max-height .22s ease, opacity .22s ease;
      max-height: 2000px;
      opacity: 1;
    }
    .collapsed .collapsible{
      max-height: 0px;
      opacity: 0;
      pointer-events: none;
    }

    footer{ margin-top: 14px; text-align:center; color:#666; font-weight: 850; font-size: 0.92em; }

    .pip-toggle{ display:none; margin-top: 10px; }
    @media (max-width: 980px) {
      .pip-toggle{ display:inline-block; }
      body.pip-on .sticky .card{
        position: fixed;
        left: 12px; right: 12px; bottom: 12px;
        z-index: 9999;
        padding: 10px;
        box-shadow: 0 18px 55px rgba(0,0,0,0.35);
        max-width: 520px;
        margin: 0 auto;
      }
      body.pip-on .container{ padding-bottom: 270px; }
    }
  </style>
</head>

<body>
<div class="container">
  <h1>üèÉ‚Äç‚ôÇÔ∏è Movement Kinetics Lab</h1>
  <p class="subtitle">Event-based phases (peak projectile speed + peak angular velocity) ‚Ä¢ low-pass Force‚ÄìTime & Moment‚ÄìTime ‚Ä¢ simplified XLSX</p>

  <div id="statusMessage" class="status-message"></div>

  <div class="layout">
    <div>
      <div class="card">
        <h3>Participant</h3>
        <div class="form-grid">
          <div><label>Name *</label><input id="participantName" placeholder="Enter name"></div>
          <div>
            <label>Sex *</label>
            <select id="participantSex">
              <option value="male">Male</option><option value="female">Female</option>
            </select>
          </div>
          <div><label>Age *</label><input id="participantAge" type="number" value="25"></div>
          <div><label>Mass (kg) *</label><input id="participantMass" type="number" value="70"></div>
          <div><label>Height (cm) *</label><input id="participantHeight" type="number" value="175"></div>
        </div>
        <button class="btn btn-success" onclick="addParticipant()">Add / Update Participant</button>

        <div class="divider"></div>

        <label>Select Participant</label>
        <select id="selectedParticipant" onchange="onParticipantChange()"></select>

        <div class="divider"></div>

        <h3>Input Source</h3>
        <div class="form-grid">
          <div>
            <label>Source</label>
            <select id="inputSource">
              <option value="camera" selected>Live Camera</option>
              <option value="upload">Video Upload</option>
            </select>
          </div>
          <div>
             <label>FPS (Requested)</label>
             <select id="fpsSelection">
               <option value="30">30</option>
               <option value="60" selected>60</option>
               <option value="120">120 (best effort)</option>
               <option value="240">240 (best effort)</option>
             </select>
          </div>
          <div>
             <label>Camera</label>
             <select id="cameraFacing"><option value="environment">Back</option><option value="user">Front</option></select>
          </div>
          <div>
            <label>Window (s)</label>
            <select id="windowSeconds"><option value="5">5s</option><option value="10" selected>10s</option></select>
          </div>
          <div>
             <label>Low-pass cutoff (Hz)</label>
             <select id="cutoffHz"><option value="3">3</option><option value="4">4</option><option value="6" selected>6</option><option value="10">10</option><option value="12">12</option></select>
          </div>
        </div>

        <div class="form-grid" style="margin-top:10px;">
          <div>
            <label>Video File (Upload)</label>
            <input id="videoUpload" type="file" accept="video/*">
          </div>
        </div>

        <button class="btn btn-primary" onclick="startInput()">Start (Camera / Upload)</button>
        <button class="btn btn-danger" onclick="stopInput()">Stop</button>
        <button class="btn btn-success" id="recordBtn" onclick="toggleRecording()" disabled>Start Recording</button>
        <button class="btn btn-ghost" onclick="snapshotPNG()" id="snapBtn" disabled>üì∏ Snapshot PNG</button>
        <button class="btn btn-primary pip-toggle" onclick="togglePiP()">üìå Pin Video (PiP)</button>

        <div class="divider"></div>

        <h3>Projectile Tracking</h3>
        <div class="form-grid">
          <div>
            <label>Mode</label>
            <select id="projMode">
              <option value="off" selected>Off</option>
              <option value="coco">COCO-SSD Detect</option>
            </select>
          </div>
          <div>
            <label>Class</label>
            <select id="projClassHint">
              <option value="sports ball" selected>Sports ball</option>
              <option value="frisbee">Frisbee</option>
              <option value="kite">Kite</option>
              <option value="bottle">Bottle</option>
              <option value="cup">Cup</option>
              <option value="person">Person</option>
            </select>
          </div>
          <div>
            <label>Confidence</label>
            <select id="projMinScore">
              <option value="0.30">0.30</option>
              <option value="0.40" selected>0.40</option>
              <option value="0.50">0.50</option>
              <option value="0.60">0.60</option>
            </select>
          </div>
          <div>
            <label>Detect Rate</label>
            <select id="projEveryN">
              <option value="1">Every frame</option>
              <option value="2" selected>Every 2 frames</option>
              <option value="3">Every 3 frames</option>
              <option value="4">Every 4 frames</option>
            </select>
          </div>
        </div>

        <div class="divider"></div>

        <h3>Kinetics Driver</h3>
        <div class="form-grid">
          <div>
            <label>Driver Joint</label>
            <select id="kinJoint">
              <option value="hip">Hip</option><option value="knee">Knee</option>
              <option value="shoulder">Shoulder</option><option value="elbow">Elbow</option>
              <option value="ankle">Ankle</option><option value="wrist">Wrist</option>
            </select>
          </div>
          <div>
            <label>Side</label>
            <select id="kinSide"><option value="R">Right</option><option value="L">Left</option></select>
          </div>
        </div>
        <p class="mini">
          Kinetics are simplified proxies (use trends). Phases are event-based using peak projectile speed and peak angular velocity.
        </p>
      </div>

      <div class="card collapsible-card" id="displaySelectorCard" style="margin-top:12px;">
        <div class="card-head">
          <h3 style="margin:0;">Display Selector</h3>
          <button class="collapse-btn" onclick="toggleCollapse('displaySelectorCard')">
            <span id="displaySelectorCard_lbl">Collapse</span><span class="collapse-icon"></span>
          </button>
        </div>
        <div class="collapsible">
          <div class="form-grid">
            <div>
              <label>Metric</label>
              <select id="metricType">
                <option value="angle">Angle (¬∞)</option>
                <option value="angVel">Ang. Vel (¬∞/s)</option>
                <option value="linVel">Lin. Vel (m/s)</option>
              </select>
            </div>
            <div>
              <label>Joint</label>
              <select id="metricJoint">
                <option value="shoulder">Shoulder</option>
                <option value="elbow">Elbow</option>
                <option value="wrist">Wrist</option>
                <option value="hip">Hip</option>
                <option value="knee">Knee</option>
                <option value="ankle">Ankle</option>
              </select>
            </div>
            <div>
              <label>Side</label>
              <select id="metricSide"><option value="R">Right</option><option value="L">Left</option></select>
            </div>
          </div>
          <button class="btn btn-primary" onclick="addMetric()">Add</button>
          <button class="btn btn-danger" onclick="clearMetrics()">Clear</button>
          <div class="chiplist" id="metricChips"></div>
          <div class="divider"></div>
          <div class="metrics-grid" id="selectedMetricsPanel"></div>

          <div class="divider"></div>
          <div class="metric">
            <div class="t">Quick interpretation (live)</div>
            <div class="s" id="liveInterpretation">‚Äî</div>
          </div>
        </div>
      </div>

      <div class="card" style="margin-top:12px;">
        <h3>Real-time Charts</h3>
        <div class="charts-grid">
          <div class="chart-card">
            <div class="chart-title"><b>Force‚ÄìTime (filtered, N)</b><span id="lblForce">0 N</span></div>
            <canvas id="chartForce" class="chart"></canvas>
          </div>
          <div class="chart-card">
            <div class="chart-title"><b>Moment‚ÄìTime (filtered, Nm)</b><span id="lblMoment">0 Nm</span></div>
            <canvas id="chartMoment" class="chart"></canvas>
          </div>
        </div>
      </div>

      <div class="card" style="margin-top:12px;">
        <button class="btn btn-primary" onclick="downloadData()">üìä Download XLSX (Profile ‚Ä¢ Kinematics Summary by Event-Phases ‚Ä¢ Kinetics Force/Moment Time ‚Ä¢ Technical Model)</button>
      </div>
    </div>

    <div class="sticky" id="stickyVideo">
      <div class="card">
        <h3>Live View</h3>
        <div class="video-wrap">
          <video id="video" playsinline muted></video>
          <canvas id="overlay"></canvas>
          <div class="hud">
            <div id="fpsIndicator">FPS: 0</div>
            <small id="statusText">Ready</small>
            <small id="sourceText">Source: ‚Äî</small>
          </div>
        </div>
        <p class="mini">
          Warnings: 2D pose has depth ambiguity; fast motion blur reduces keypoint confidence; occlusion drops wrist/ankle.
          Best: tripod + strong lighting + keep projectile large in frame.
        </p>
      </div>
    </div>
  </div>

  <footer>¬© 2025 Ng Jun Wei. All rights reserved.</footer>
</div>

<script>
/* =========================================================
   Globals
========================================================= */
let detector = null, cocoModel = null;
let video = null, overlay = null, ctx = null;
let streamRef = null;
let animationId = null;

let participants = [];
let currentParticipant = null;

let isRecording = false;

let rec = {
  t: [],
  driverLinVel: [],
  driverAngVel: [],
  driverAngle: [],
  driverDisp: [],
  forceFilt: [],
  momentFilt: [],
  projSpeed: [],
  projValid: []
};

let sessionMeta = {};
let prevFrameTS = 0;
let prevKeypoints = null;
let frameIndex = 0;

let prevAngleDriver = null;
let prevDriverPos = null;
let cumDisp = 0;

let prevProj = null;
let lastProjectiles = [];

let detectedFPS = 0;
let framesInSecond = 0;
let lastFPSUpdate = performance.now();

let selectedMetrics = [];
let prevAngleMap = new Map();

const chartSeries = { forceFilt:[], momentFilt:[] };
let lastChartDraw = 0;

const KP = {
  nose:0, left_eye:1, right_eye:2, left_ear:3, right_ear:4,
  shoulder_L:5, shoulder_R:6, elbow_L:7, elbow_R:8, wrist_L:9, wrist_R:10,
  hip_L:11, hip_R:12, knee_L:13, knee_R:14, ankle_L:15, ankle_R:16
};

const SEG_MASS = {
  thigh: 0.10, shank: 0.0465, foot: 0.0145,
  upperArm: 0.028, forearm: 0.016, hand: 0.006,
  trunk: 0.50
};

const SEG_K = { thigh:0.323, shank:0.302, foot:0.475, upperArm:0.322, forearm:0.303, hand:0.628 };

/* =========================================================
   Init
========================================================= */
window.onload = async () => {
  video = document.getElementById('video');
  overlay = document.getElementById('overlay');
  ctx = overlay.getContext('2d');

  document.getElementById('participantName').value = "Athlete 1";
  addParticipant(true);

  showStatus("Loading Neural Networks...", "info");
  try {
    await tf.ready();
    try { await tf.setBackend('webgl'); await tf.ready(); } catch(_) {}

    detector = await poseDetection.createDetector(
      poseDetection.SupportedModels.MoveNet,
      { modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING }
    );
    cocoModel = await cocoSsd.load();

    showStatus("Models Ready. Start Camera or Upload.", "success");
    setStatusText("Models ready");
  } catch(e) {
    console.error(e);
    showStatus("Error loading models. Try reloading.", "error");
    setStatusText("Model load error");
  }
};

/* =========================================================
   Participant
========================================================= */
function addParticipant(silent=false) {
  const name = (document.getElementById('participantName').value || "").trim();
  const sex = document.getElementById('participantSex').value;
  const age = parseInt(document.getElementById('participantAge').value || "0");
  const mass = parseFloat(document.getElementById('participantMass').value || "0");
  const height = parseFloat(document.getElementById('participantHeight').value || "0");

  if(!name || !mass || !height || !age) {
    if(!silent) showStatus("Please fill Name, Age, Mass, Height.", "error");
    return;
  }

  const existing = participants.find(p => p.name === name);
  const profile = { name, sex, age, mass, height };

  if(existing) Object.assign(existing, profile);
  else participants.push(profile);

  const sel = document.getElementById('selectedParticipant');
  sel.innerHTML = "";
  participants.forEach(p => {
    const opt = document.createElement('option');
    opt.value = p.name; opt.textContent = p.name;
    sel.appendChild(opt);
  });
  sel.value = name;

  currentParticipant = profile;

  if(!silent) showStatus(`Participant set: ${name}`, "success");
}
function onParticipantChange() {
  const sel = document.getElementById('selectedParticipant');
  const p = participants.find(x => x.name === sel.value);
  if(p) currentParticipant = p;
}

/* =========================================================
   Input Source
========================================================= */
async function startInput() {
  if(!detector) return showStatus("Wait for models to load.", "error");
  stopActive();
  resetSessionState();

  const src = document.getElementById('inputSource').value;
  const fpsReq = parseInt(document.getElementById('fpsSelection').value);
  const facing = document.getElementById('cameraFacing').value;

  sessionMeta = { source: src, fpsRequested: fpsReq, facing, startedAt: new Date().toISOString() };

  if(src === "camera") await startCameraInternal(fpsReq, facing);
  else await startUploadInternal();
}

async function startCameraInternal(fpsReq, facing) {
  setStatusText("Starting camera...");
  setSourceText(`Source: Camera (${facing}, req ${fpsReq}fps)`);

  const constraints = {
    video: {
      facingMode: facing,
      width: { ideal: 1280 },
      height: { ideal: 720 },
      frameRate: { ideal: fpsReq, max: fpsReq }
    },
    audio: false
  };

  try {
    streamRef = await navigator.mediaDevices.getUserMedia(constraints);
    video.srcObject = streamRef;

    video.onloadedmetadata = async () => {
      await video.play();

      overlay.width = video.videoWidth || 1280;
      overlay.height = video.videoHeight || 720;

      if(facing === 'user') {
        video.style.transform = "scaleX(-1)";
        overlay.style.transform = "scaleX(-1)";
      } else {
        video.style.transform = "none";
        overlay.style.transform = "none";
      }

      enableRunButtons(true);
      setStatusText("Running");
      animationId = requestAnimationFrame(renderLoop);
      showStatus("Camera Active", "success");
    };
  } catch(err) {
    console.error(err);
    showStatus("Camera Error: " + err.message, "error");
    setStatusText("Camera error");
  }
}

async function startUploadInternal() {
  const fileInput = document.getElementById('videoUpload');
  if(!fileInput.files.length) return showStatus("Select a video file first.", "error");

  const file = fileInput.files[0];
  const url = URL.createObjectURL(file);

  setStatusText("Loading video...");
  setSourceText(`Source: Upload (${file.name})`);

  video.srcObject = null;
  video.src = url;
  video.loop = true;
  video.muted = true;
  video.playsInline = true;

  video.onloadedmetadata = async () => {
    try {
      await video.play();

      overlay.width = video.videoWidth || 1280;
      overlay.height = video.videoHeight || 720;

      video.style.transform = "none";
      overlay.style.transform = "none";

      enableRunButtons(true);
      setStatusText("Running");
      animationId = requestAnimationFrame(renderLoop);
      showStatus("Playing Upload", "success");
    } catch(e) {
      console.error(e);
      showStatus("Upload playback error: " + e.message, "error");
      setStatusText("Upload error");
    }
  };
}

function stopInput() {
  stopActive();
  enableRunButtons(false);
  showStatus("Stopped", "info");
  setStatusText("Stopped");
  setSourceText("Source: ‚Äî");
}

function stopActive() {
  if(animationId) cancelAnimationFrame(animationId);
  animationId = null;

  if(streamRef) {
    try { streamRef.getTracks().forEach(t => t.stop()); } catch(_) {}
  }
  streamRef = null;

  try { video.pause(); } catch(_) {}
  video.srcObject = null;

  if(ctx) ctx.clearRect(0,0,overlay.width,overlay.height);
}

function enableRunButtons(running) {
  document.getElementById('recordBtn').disabled = !running;
  document.getElementById('snapBtn').disabled = !running;
}

function resetSessionState() {
  isRecording = false;

  rec = { t:[], driverLinVel:[], driverAngVel:[], driverAngle:[], driverDisp:[], forceFilt:[], momentFilt:[], projSpeed:[], projValid:[] };

  prevFrameTS = 0;
  prevKeypoints = null;
  frameIndex = 0;

  prevAngleDriver = null;
  prevDriverPos = null;
  cumDisp = 0;

  prevAngleMap.clear();
  prevProj = null;
  lastProjectiles = [];

  chartSeries.forceFilt = [];
  chartSeries.momentFilt = [];
  lastChartDraw = 0;

  prevForceFilt = 0;
  prevMomentFilt = 0;

  document.getElementById('lblForce').innerText = "0 N";
  document.getElementById('lblMoment').innerText = "0 Nm";
  document.getElementById('liveInterpretation').innerText = "‚Äî";
}

/* =========================================================
   Main Loop
========================================================= */
async function renderLoop(ts) {
  animationId = requestAnimationFrame(renderLoop);
  if(!video || video.paused || video.ended) return;

  framesInSecond++;
  const nowPerf = performance.now();
  if(nowPerf - lastFPSUpdate >= 1000) {
    detectedFPS = framesInSecond;
    framesInSecond = 0;
    lastFPSUpdate = nowPerf;
    document.getElementById('fpsIndicator').innerText = "FPS: " + detectedFPS;
  }

  frameIndex++;

  const tSec = (ts || performance.now()) / 1000;
  const dt = prevFrameTS ? clamp(tSec - prevFrameTS, 1/240, 0.2) : (1/60);
  prevFrameTS = tSec;

  let kp = null;
  try {
    const poses = await detector.estimatePoses(video, { flipHorizontal: false });
    if(poses && poses.length && poses[0].keypoints) kp = poses[0].keypoints;
  } catch(_) {}

  const projMode = document.getElementById('projMode').value;
  if(projMode === "coco" && cocoModel) {
    const everyN = parseInt(document.getElementById('projEveryN').value);
    if(frameIndex % everyN === 0) {
      try {
        const preds = await cocoModel.detect(video);
        const cls = document.getElementById('projClassHint').value;
        const minScore = parseFloat(document.getElementById('projMinScore').value);
        lastProjectiles = preds.filter(p => p.class === cls && p.score >= minScore).sort((a,b)=>b.score-a.score).slice(0, 2);
      } catch(_) {}
    }
  } else {
    lastProjectiles = [];
  }

  ctx.clearRect(0,0,overlay.width, overlay.height);
  if(kp) drawSkeleton(kp);
  drawProjectile(lastProjectiles, dt);

  if(kp) {
    processSelectedMetrics(kp, dt);
    const kin = processDriverKinematics(kp, dt);
    const kinets = processDriverKinetics(kp, dt, tSec, kin);

    document.getElementById('liveInterpretation').innerText = buildLiveInterpretation(kin, kinets);

    if(isRecording) recordSimplified(tSec, kin, kinets);

    prevKeypoints = kp;
    setStatusText("Running");
  } else {
    setStatusText("No pose detected (framing/lighting)");
  }

  throttleChartDraw(tSec);
}

/* =========================================================
   Drawing
========================================================= */
function drawSkeleton(kp) {
  const minScore = 0.30;
  ctx.lineWidth = 3;
  ctx.strokeStyle = "#00ff66";

  const skeleton = [
    [KP.shoulder_L, KP.shoulder_R],
    [KP.shoulder_L, KP.elbow_L], [KP.elbow_L, KP.wrist_L],
    [KP.shoulder_R, KP.elbow_R], [KP.elbow_R, KP.wrist_R],
    [KP.shoulder_L, KP.hip_L], [KP.shoulder_R, KP.hip_R],
    [KP.hip_L, KP.hip_R],
    [KP.hip_L, KP.knee_L], [KP.knee_L, KP.ankle_L],
    [KP.hip_R, KP.knee_R], [KP.knee_R, KP.ankle_R]
  ];

  skeleton.forEach(([i, j]) => {
    if(kp[i]?.score > minScore && kp[j]?.score > minScore) {
      ctx.beginPath();
      ctx.moveTo(kp[i].x, kp[i].y);
      ctx.lineTo(kp[j].x, kp[j].y);
      ctx.stroke();
    }
  });

  kp.forEach(p => {
    if(p.score > minScore) {
      ctx.beginPath();
      ctx.arc(p.x, p.y, 5, 0, 2*Math.PI);
      ctx.fillStyle = "red";
      ctx.fill();
    }
  });
}

function drawProjectile(projs, dt) {
  if(!projs || !projs.length) { prevProj = null; return; }

  ctx.save();
  ctx.lineWidth = 2;
  ctx.strokeStyle = "orange";
  ctx.fillStyle = "orange";
  ctx.font = "14px system-ui, -apple-system, Segoe UI, Roboto, Arial";

  projs.forEach(p => {
    const [x,y,w,h] = p.bbox;
    ctx.strokeRect(x,y,w,h);
    ctx.fillText(`${p.class} ${(p.score*100).toFixed(0)}%`, x, y > 18 ? y-6 : y+18);
  });

  const s = computeProjectileState(projs, dt);
  if(s.valid) {
    ctx.beginPath();
    ctx.arc(s.cx, s.cy, 6, 0, 2*Math.PI);
    ctx.fill();

    const pxScale = 0.15;
    ctx.beginPath();
    ctx.moveTo(s.cx, s.cy);
    ctx.lineTo(s.cx + (s.vx_mps/pxScale), s.cy + (s.vy_mps/pxScale));
    ctx.stroke();
  }
  ctx.restore();
}

/* =========================================================
   Helpers: scale / indices
========================================================= */
function getPxToMeter() {
  const hM = currentParticipant ? (currentParticipant.height / 100) : 1.75;
  const denom = Math.max(240, overlay.height * 0.80);
  return hM / denom;
}

function getJointIndex(joint, side) {
  const map = {
    shoulder_R: KP.shoulder_R, shoulder_L: KP.shoulder_L,
    elbow_R: KP.elbow_R, elbow_L: KP.elbow_L,
    wrist_R: KP.wrist_R, wrist_L: KP.wrist_L,
    hip_R: KP.hip_R, hip_L: KP.hip_L,
    knee_R: KP.knee_R, knee_L: KP.knee_L,
    ankle_R: KP.ankle_R, ankle_L: KP.ankle_L
  };
  const key = `${joint}_${side}`;
  return (key in map) ? map[key] : null;
}

/* =========================================================
   Selected metrics (UI only)
========================================================= */
function processSelectedMetrics(kp, dt) {
  selectedMetrics.forEach(m => {
    const v = computeMetricValue(kp, m, dt);
    const el = document.getElementById(`val_${m.id}`);
    if(el) el.innerText = isFinite(v) ? v.toFixed(1) : "--";
  });
}

function computeMetricValue(kp, m, dt) {
  if(m.type === "angle") return getJointAngleDeg(kp, m.joint, m.side);
  if(m.type === "linVel") {
    const idx = getJointIndex(m.joint, m.side);
    return idx == null ? NaN : getLinearVelMps(kp, idx, dt);
  }
  if(m.type === "angVel") {
    const ang = getJointAngleDeg(kp, m.joint, m.side);
    const prev = prevAngleMap.get(m.id);
    prevAngleMap.set(m.id, ang);
    if(prev == null || !isFinite(prev) || !isFinite(ang)) return 0;
    let d = ang - prev;
    if(d > 180) d -= 360;
    if(d < -180) d += 360;
    return d / Math.max(1e-4, dt);
  }
  return NaN;
}

function getJointAngleDeg(kp, joint, side) {
  const minScore = 0.30;
  let a=null,b=null,c=null;

  if(joint === "elbow")      { a=`shoulder_${side}`; b=`elbow_${side}`; c=`wrist_${side}`; }
  else if(joint === "knee")  { a=`hip_${side}`;      b=`knee_${side}`;  c=`ankle_${side}`; }
  else if(joint === "hip")   { a=`shoulder_${side}`; b=`hip_${side}`;   c=`knee_${side}`; }
  else if(joint === "shoulder"){ a=`hip_${side}`; b=`shoulder_${side}`; c=`elbow_${side}`; }
  else if(joint === "wrist") {
    const e = kp[getJointIndex("elbow", side)];
    const w = kp[getJointIndex("wrist", side)];
    if(!e || !w || e.score < minScore || w.score < minScore) return NaN;
    const ang = Math.atan2(w.y - e.y, w.x - e.x) * 180/Math.PI;
    return Math.abs(normalizeDeg(ang));
  }
  else if(joint === "ankle") {
    const k = kp[getJointIndex("knee", side)];
    const a2 = kp[getJointIndex("ankle", side)];
    if(!k || !a2 || k.score < minScore || a2.score < minScore) return NaN;
    const ang = Math.atan2(a2.x - k.x, a2.y - k.y) * 180/Math.PI;
    return Math.abs(normalizeDeg(ang));
  }
  else return NaN;

  const pA = kp[getJointIndex(a.split("_")[0], a.split("_")[1])];
  const pB = kp[getJointIndex(b.split("_")[0], b.split("_")[1])];
  const pC = kp[getJointIndex(c.split("_")[0], c.split("_")[1])];
  if(!pA || !pB || !pC) return NaN;
  if(pA.score < minScore || pB.score < minScore || pC.score < minScore) return NaN;

  const rad =
    Math.atan2(pC.y - pB.y, pC.x - pB.x) -
    Math.atan2(pA.y - pB.y, pA.x - pB.x);

  let deg = Math.abs(rad * 180.0 / Math.PI);
  if(deg > 180) deg = 360 - deg;
  return deg;
}

function normalizeDeg(d) {
  let x = d % 360;
  if(x < 0) x += 360;
  return x;
}

function getLinearVelMps(kp, idx, dt) {
  if(!prevKeypoints || !kp[idx] || !prevKeypoints[idx]) return 0;
  const curr = kp[idx], prev = prevKeypoints[idx];
  if(curr.score < 0.30 || prev.score < 0.30) return 0;
  const scale = getPxToMeter();
  const dx = (curr.x - prev.x) * scale;
  const dy = (curr.y - prev.y) * scale;
  return Math.hypot(dx, dy) / Math.max(1e-4, dt);
}

/* =========================================================
   Driver kinematics (export + model)
========================================================= */
function processDriverKinematics(kp, dt) {
  const jName = document.getElementById('kinJoint').value;
  const side = document.getElementById('kinSide').value;
  const idx = getJointIndex(jName, side);
  if(idx == null) return null;

  const p = kp[idx];
  if(!p || p.score < 0.30) return null;

  const v = getLinearVelMps(kp, idx, dt);

  const ang = getJointAngleDeg(kp, jName, side);
  let w = 0;
  if(prevAngleDriver != null && isFinite(prevAngleDriver) && isFinite(ang)) {
    let d = ang - prevAngleDriver;
    if(d > 180) d -= 360;
    if(d < -180) d += 360;
    w = d / Math.max(1e-4, dt);
  }
  prevAngleDriver = ang;

  const scale = getPxToMeter();
  if(prevDriverPos && prevDriverPos.ok) {
    const dx = (p.x - prevDriverPos.x) * scale;
    const dy = (p.y - prevDriverPos.y) * scale;
    cumDisp += Math.hypot(dx, dy);
  }
  prevDriverPos = { x:p.x, y:p.y, ok:true };

  const proj = computeProjectileState(lastProjectiles, dt);

  return {
    driver: `${jName}_${side}`,
    v_mps: v,
    angle_deg: isFinite(ang) ? ang : 0,
    angVel_dps: w,
    disp_m: cumDisp,
    projValid: proj.valid ? 1 : 0,
    projSpeed_mps: proj.valid ? proj.speed_mps : 0
  };
}

/* =========================================================
   Kinetics Driver (low-pass clean)
========================================================= */
let prevForceFilt = 0;
let prevMomentFilt = 0;

function processDriverKinetics(kp, dt, tSec, kin) {
  if(!currentParticipant || !prevKeypoints || !kin) return null;

  const driverJoint = kin.driver.split("_")[0];
  let seg = "thigh";
  if(driverJoint === "knee") seg = "shank";
  if(driverJoint === "ankle") seg = "foot";
  if(driverJoint === "shoulder") seg = "upperArm";
  if(driverJoint === "elbow") seg = "forearm";
  if(driverJoint === "wrist") seg = "hand";

  const segMass = currentParticipant.mass * (SEG_MASS[seg] || 0.10);

  const prevV = rec.driverLinVel.length ? rec.driverLinVel[rec.driverLinVel.length - 1] : kin.v_mps;
  const accel = Math.abs(kin.v_mps - prevV) / Math.max(1e-4, dt);
  const forceRaw = segMass * accel;

  const prevW = rec.driverAngVel.length ? rec.driverAngVel[rec.driverAngVel.length - 1] : kin.angVel_dps;
  const angAccel_dps2 = (kin.angVel_dps - prevW) / Math.max(1e-4, dt);
  const alpha = angAccel_dps2 * Math.PI / 180;

  const L = estimateSegmentLengthM(seg);
  const k = SEG_K[seg] || 0.30;
  const I = segMass * Math.pow(k * L, 2);

  const momentRaw = I * alpha;

  const hz = parseFloat(document.getElementById('cutoffHz').value);
  const f1 = lowPass(prevForceFilt, forceRaw, dt, hz);
  const m1 = lowPass(prevMomentFilt, momentRaw, dt, hz);
  const forceFilt = lowPass(prevForceFilt, f1, dt, hz);
  const momentFilt = lowPass(prevMomentFilt, m1, dt, hz);

  prevForceFilt = forceFilt;
  prevMomentFilt = momentFilt;

  document.getElementById('lblForce').innerText = forceFilt.toFixed(0) + " N";
  document.getElementById('lblMoment').innerText = momentFilt.toFixed(2) + " Nm";

  pushChart('forceFilt', tSec, forceFilt);
  pushChart('momentFilt', tSec, momentFilt);

  return { forceFilt_N: forceFilt, momentFilt_Nm: momentFilt };
}

function estimateSegmentLengthM(seg) {
  const h = currentParticipant ? (currentParticipant.height/100) : 1.75;
  const frac = { thigh:0.245, shank:0.246, foot:0.152, upperArm:0.186, forearm:0.146, hand:0.108, trunk:0.288 };
  return h * (frac[seg] || 0.20);
}

function lowPass(prev, curr, dt, fc) {
  const rc = 1.0 / (2 * Math.PI * fc);
  const alpha = dt / (rc + dt);
  return prev + alpha * (curr - prev);
}

/* =========================================================
   Charts
========================================================= */
function pushChart(key, t, v) {
  const win = parseInt(document.getElementById('windowSeconds').value);
  chartSeries[key].push({t, v});
  while(chartSeries[key].length && chartSeries[key][0].t < t - win) chartSeries[key].shift();
}

function throttleChartDraw(t) {
  if(t - lastChartDraw < 0.1) return;
  lastChartDraw = t;
  drawChart('chartForce', 'forceFilt');
  drawChart('chartMoment', 'momentFilt');
}

function drawChart(id, key) {
  const c = document.getElementById(id);
  const g = c.getContext('2d');
  const w = c.width = c.clientWidth;
  const h = c.height = c.clientHeight;
  g.clearRect(0,0,w,h);

  g.strokeStyle="#eee";
  g.beginPath(); g.moveTo(0,h/2); g.lineTo(w,h/2); g.stroke();

  const data = chartSeries[key];
  if(!data || data.length < 2) return;

  let max = 1;
  data.forEach(d => { max = Math.max(max, Math.abs(d.v)); });

  const win = parseInt(document.getElementById('windowSeconds').value);
  const now = data[data.length-1].t;

  g.strokeStyle = "#667eea";
  g.lineWidth = 2;
  g.beginPath();

  data.forEach((pt, i) => {
    const x = ((win - (now - pt.t)) / win) * w;
    const y = h - ((pt.v / (max*1.2)) * (h/2) + h/2);
    if(i===0) g.moveTo(x,y); else g.lineTo(x,y);
  });
  g.stroke();
}

/* =========================================================
   Projectile state
========================================================= */
function computeProjectileState(projs, dt) {
  const state = { valid:false, cx:0, cy:0, vx_mps:0, vy_mps:0, speed_mps:0, angle_deg:0 };
  if(!projs || !projs.length) { prevProj = null; return state; }

  const best = projs[0];
  const [x,y,w,h] = best.bbox;
  const cx = x + w/2;
  const cy = y + h/2;

  state.valid = true;
  state.cx = cx; state.cy = cy;

  const scale = getPxToMeter();
  if(prevProj && prevProj.valid) {
    const vx = ((cx - prevProj.cx) * scale) / Math.max(1e-4, dt);
    const vy = ((cy - prevProj.cy) * scale) / Math.max(1e-4, dt);
    const a = 0.35;
    state.vx_mps = a*vx + (1-a)*(prevProj.vx_mps || 0);
    state.vy_mps = a*vy + (1-a)*(prevProj.vy_mps || 0);
  }

  state.speed_mps = Math.hypot(state.vx_mps, state.vy_mps);
  state.angle_deg = Math.atan2(-state.vy_mps, state.vx_mps) * 180/Math.PI;

  prevProj = {...state, valid:true};
  return state;
}

/* =========================================================
   Recording
========================================================= */
function toggleRecording() {
  const btn = document.getElementById('recordBtn');
  if(!isRecording) {
    if(!currentParticipant) return showStatus("Set a participant first.", "error");
    isRecording = true;

    rec = { t:[], driverLinVel:[], driverAngVel:[], driverAngle:[], driverDisp:[], forceFilt:[], momentFilt:[], projSpeed:[], projValid:[] };
    prevForceFilt = 0;
    prevMomentFilt = 0;
    prevAngleDriver = null;
    prevDriverPos = null;
    cumDisp = 0;

    btn.textContent = "Stop Recording";
    btn.className = "btn btn-danger";
    showStatus("Recording started...", "info");
    setStatusText("Recording...");
  } else {
    isRecording = false;
    btn.textContent = "Start Recording";
    btn.className = "btn btn-success";
    showStatus(`Recording saved. ${rec.t.length} samples.`, "success");
    setStatusText("Running");
  }
}

function recordSimplified(tSec, kin, kinets) {
  if(!kin) return;
  rec.t.push(tSec);
  rec.driverLinVel.push(kin.v_mps || 0);
  rec.driverAngVel.push(kin.angVel_dps || 0);
  rec.driverAngle.push(kin.angle_deg || 0);
  rec.driverDisp.push(kin.disp_m || 0);

  rec.forceFilt.push(kinets?.forceFilt_N || 0);
  rec.momentFilt.push(kinets?.momentFilt_Nm || 0);

  rec.projValid.push(kin.projValid || 0);
  rec.projSpeed.push(kin.projSpeed_mps || 0);
}

function snapshotPNG() {
  if(!video || video.paused) return showStatus("Start Camera/Upload first.", "error");
  const c = document.createElement('canvas');
  const w = overlay.width, h = overlay.height;
  c.width = w; c.height = h;
  const g = c.getContext('2d');
  try { g.drawImage(video, 0, 0, w, h); } catch(_) {}
  try { g.drawImage(overlay, 0, 0, w, h); } catch(_) {}

  const a = document.createElement('a');
  a.href = c.toDataURL("image/png");
  a.download = `snapshot_${Date.now()}.png`;
  a.click();
}

/* =========================================================
   XLSX Export (event-based phases)
   Marker events:
   - Peak projectile speed (valid frames only)
   - Peak angular velocity (driver)
   Phases:
   A) Preparation: start -> min(peakAngVel, peakProjSpeed) - buffer
   B) Acceleration/Cocking: around peakAngVel (window)
   C) Release/Impact: around peakProjSpeed (window)
   D) Follow-through: after release window -> end
========================================================= */
function downloadData() {
  if(!rec.t.length) return showStatus("No recorded data. Press Start Recording first.", "error");

  const profile = currentParticipant || participants[0] || {name:"",sex:"",age:"",mass:"",height:""};
  const driver = `${document.getElementById('kinJoint').value}_${document.getElementById('kinSide').value}`;

  const phases = segmentPhasesEventBased(rec);

  const kinSummaryRows = [];
  kinSummaryRows.push(...makeKinSummaryBlock("Overall", driver, rangeAll(phases), rec, phases.events));
  phases.list.forEach(ph => kinSummaryRows.push(...makeKinSummaryBlock(ph.name, driver, ph, rec, phases.events)));

  const kineticsRows = rec.t.map((t, i) => ({
    time_s: round(t, 4),
    forceFilt_N: round(rec.forceFilt[i] || 0, 3),
    momentFilt_Nm: round(rec.momentFilt[i] || 0, 4)
  }));

  const modelRows = buildTechnicalModel(profile, driver, phases, rec);

  const profileRows = [
    { field:"name", value: profile.name },
    { field:"sex", value: profile.sex },
    { field:"age", value: profile.age },
    { field:"mass_kg", value: profile.mass },
    { field:"height_cm", value: profile.height },
    { field:"driver_joint", value: driver },
    { field:"source", value: sessionMeta.source || "" },
    { field:"camera_facing", value: sessionMeta.facing || "" },
    { field:"fps_requested", value: sessionMeta.fpsRequested || "" },
    { field:"fps_detected_est", value: detectedFPS || "" },
    { field:"started_at", value: sessionMeta.startedAt || "" },
    { field:"notes", value:"Event markers: peak projectile speed + peak angular velocity. Kinetics are simplified proxies; interpret trends, not lab-grade ground truth." }
  ];

  const wb = XLSX.utils.book_new();
  XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet(profileRows), "1_Profile");
  XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet(kinSummaryRows), "2_Kinematics_Summary");
  XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet(kineticsRows), "3_Kinetics_ForceMoment_Time");
  XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet(modelRows), "4_Technical_Model");

  const fname = `sport_analysis_${(profile.name||"participant").replace(/\s+/g,"_")}_${Date.now()}.xlsx`;
  XLSX.writeFile(wb, fname);
  showStatus("XLSX exported (event-based phases).", "success");
}

/* =========================================================
   Event-based phase segmentation
========================================================= */
function segmentPhasesEventBased(rec) {
  const n = rec.t.length;
  const minN = 12;
  if(n < minN) {
    return {
      events: { peakProjIdx: 0, peakProjSpeed: 0, peakAngVelIdx: 0, peakAngVel: 0 },
      list: [
        { name:"Preparation", i0:0, i1:n-1 },
        { name:"Acceleration/Cocking", i0:0, i1:n-1 },
        { name:"Release/Impact", i0:0, i1:n-1 },
        { name:"FollowThrough", i0:0, i1:n-1 }
      ]
    };
  }

  // Peak projectile speed (valid only)
  let peakProjIdx = -1;
  let peakProjSpeed = 0;
  for(let i=0;i<n;i++){
    if((rec.projValid[i]||0)===1){
      const s = Math.abs(rec.projSpeed[i]||0);
      if(s > peakProjSpeed){
        peakProjSpeed = s;
        peakProjIdx = i;
      }
    }
  }

  // Peak angular velocity (driver)
  const peakAngVelIdx = argMaxAbs(rec.driverAngVel);
  const peakAngVel = Math.abs(rec.driverAngVel[peakAngVelIdx]||0);

  // If projectile not detected, fallback: use angular velocity peak as release surrogate
  if(peakProjIdx < 0) peakProjIdx = peakAngVelIdx;

  // Windows (in samples)
  const wAng = Math.max(3, Math.floor(n * 0.10));
  const wRel = Math.max(3, Math.floor(n * 0.08));
  const buffer = Math.max(2, Math.floor(n * 0.03));

  const ang0 = clampInt(peakAngVelIdx - wAng, 0, n-1);
  const ang1 = clampInt(peakAngVelIdx + wAng, 0, n-1);

  const rel0 = clampInt(peakProjIdx - wRel, 0, n-1);
  const rel1 = clampInt(peakProjIdx + wRel, 0, n-1);

  const prepEnd = clampInt(Math.min(peakAngVelIdx, peakProjIdx) - buffer, 0, n-1);

  const phases = [
    { name:"Preparation", i0:0, i1:prepEnd },
    { name:"Acceleration/Cocking", i0:ang0, i1:ang1 },
    { name:"Release/Impact", i0:rel0, i1:rel1 },
    { name:"FollowThrough", i0:Math.min(n-1, rel1), i1:n-1 }
  ];

  // Ensure monotonic / valid ranges
  phases.forEach(ph => {
    if(ph.i1 < ph.i0){ const tmp=ph.i0; ph.i0=ph.i1; ph.i1=tmp; }
    ph.i0 = clampInt(ph.i0, 0, n-1);
    ph.i1 = clampInt(ph.i1, 0, n-1);
  });

  return {
    events: {
      peakProjIdx,
      peakProjSpeed,
      peakAngVelIdx,
      peakAngVel
    },
    list: phases
  };
}

function rangeAll(phasesObj) {
  const list = phasesObj.list;
  return { i0: 0, i1: list.length ? list[list.length-1].i1 : 0 };
}

/* =========================================================
   Kinematics summary block (with event notes)
========================================================= */
function makeKinSummaryBlock(label, driver, ph, rec, events) {
  const i0 = ph.i0, i1 = ph.i1;
  const tt = slice(rec.t, i0, i1);
  const v = slice(rec.driverLinVel, i0, i1);
  const w = slice(rec.driverAngVel, i0, i1);
  const ang = slice(rec.driverAngle, i0, i1);
  const disp = slice(rec.driverDisp, i0, i1);
  const projV = slice(rec.projSpeed, i0, i1);
  const projOk = slice(rec.projValid, i0, i1);

  const dur = tt.length ? (tt[tt.length-1] - tt[0]) : 0;

  const peakV = maxAbs(v);
  const avgV = mean(v);

  const peakW = maxAbs(w);
  const avgW = mean(w);

  const rom = (ang.length ? (Math.max(...ang) - Math.min(...ang)) : 0);
  const avgAng = mean(ang);

  const dispNet = disp.length ? (disp[disp.length-1] - disp[0]) : 0;
  const avgDispRate = dur > 0 ? dispNet / dur : 0;

  let peakProj = 0;
  for(let i=0;i<projV.length;i++){
    if((projOk[i]||0)===1) peakProj = Math.max(peakProj, Math.abs(projV[i]||0));
  }

  // Event annotation (only on Overall for readability)
  const eventNote = (label === "Overall" && events)
    ? `Events: peakProjSpeed=${round(events.peakProjSpeed,3)}m/s @ idx ${events.peakProjIdx}; peakAngVel=${round(events.peakAngVel,2)}deg/s @ idx ${events.peakAngVelIdx}`
    : "";

  return [{
    phase: label,
    driver_joint: driver,
    duration_s: round(dur, 3),
    peak_linVel_mps: round(peakV, 3),
    avg_linVel_mps: round(avgV, 3),
    peak_angVel_dps: round(peakW, 2),
    avg_angVel_dps: round(avgW, 2),
    peak_angDisplacement_deg: round(rom, 2),
    avg_angle_deg: round(avgAng, 2),
    displacement_m: round(dispNet, 3),
    avg_dispRate_mps: round(avgDispRate, 3),
    peak_projectile_speed_mps: round(peakProj, 3),
    notes: eventNote
  }];
}

/* =========================================================
   Technical model: push vs throw (event-based logic)
   Uses relative timing:
   - Throw-like: peak angular velocity occurs BEFORE peak projectile speed (rotation leads to release)
   - Push-like: peak angular velocity occurs AT/AFTER projectile speed peak (late rotation / push-through)
   Also uses dominance scores for robustness.
========================================================= */
function buildTechnicalModel(profile, driver, phasesObj, rec) {
  const events = phasesObj.events;
  const list = phasesObj.list;

  const all = rangeAll(phasesObj);
  const vAll = slice(rec.driverLinVel, all.i0, all.i1);
  const wAll = slice(rec.driverAngVel, all.i0, all.i1);
  const angAll = slice(rec.driverAngle, all.i0, all.i1);
  const dispAll = slice(rec.driverDisp, all.i0, all.i1);
  const forceAll = slice(rec.forceFilt, all.i0, all.i1);
  const momAll = slice(rec.momentFilt, all.i0, all.i1);

  const peakV = maxAbs(vAll);
  const peakW = maxAbs(wAll);
  const rom = angAll.length ? (Math.max(...angAll)-Math.min(...angAll)) : 0;
  const dispNet = dispAll.length ? (dispAll[dispAll.length-1]-dispAll[0]) : 0;
  const peakF = maxAbs(forceAll);
  const peakM = maxAbs(momAll);

  // Timing rule
  const timingLead = (events.peakAngVelIdx <= events.peakProjIdx - Math.max(1, Math.floor(rec.t.length*0.01)));

  // Dominance score (backup)
  const transScore = safeDiv(peakV, 1) + safeDiv(dispNet, 0.5) + safeDiv(peakF, 200);
  const rotScore = safeDiv(peakW, 200) + safeDiv(rom, 60) + safeDiv(Math.abs(peakM), 10);

  let pattern = "Throw-like (rotational dominant)";
  let rationale = "";

  if(!timingLead && transScore >= rotScore) {
    pattern = "Push-like (translational/late-rotation dominant)";
    rationale = "Peak angular velocity occurs at/after peak projectile speed AND translational metrics dominate‚Äîsuggesting late push-through rather than early rotational sequencing.";
  } else if(!timingLead && transScore < rotScore) {
    pattern = "Mixed (strong rotation but timing late)";
    rationale = "Rotational capacity is high, but peak angular velocity occurs at/after peak projectile speed‚Äîtiming/sequence may be suboptimal (late whip).";
  } else {
    pattern = "Throw-like (rotation leads release)";
    rationale = "Peak angular velocity occurs before peak projectile speed‚Äîconsistent with proximal-to-distal sequencing and rotation leading to release/impact.";
  }

  const recos = [];
  if(pattern.startsWith("Push-like")) {
    recos.push("Biomechanics: Improve proximal-to-distal sequencing‚Äîbuild hip/torso rotation earlier, then transfer to distal segments before release.");
    recos.push("Kinematics: Target peak angular velocity slightly BEFORE peak projectile speed (rotation leads). Reduce ‚Äòlate snap‚Äô that peaks after release.");
    recos.push("Kinetics: If Force‚ÄìTime is spiky, train smoother acceleration/braking (eccentric control) to reduce unnecessary peak loads.");
    recos.push("Training: rotational med-ball throws (hip-to-shoulder separation), cable chops/lifts, landmine rotations, decel drills (catch-and-stick, anti-rotation holds).");
  } else if(pattern.startsWith("Mixed")) {
    recos.push("Biomechanics: Rotation is present; focus on timing‚Äîavoid dumping rotation too late.");
    recos.push("Kinematics: Cue earlier trunk rotation and stable base; aim for cleaner transfer to projectile speed around release.");
    recos.push("Training: tempo throws (70‚Äì85% effort) for timing, then progress to full speed; add eccentric braking for shoulder/elbow/hip.");
  } else {
    recos.push("Biomechanics: Rotation leads release‚Äîmaintain stability to prevent energy leak (trunk/pelvis control).");
    recos.push("Kinematics: Verify peak angular velocity is not TOO early (premature rotation). Ideally: proximal œâ peak ‚Üí distal v peak ‚Üí release.");
    recos.push("Kinetics: If Moment‚ÄìTime spikes sharply, add eccentric control to protect joints while preserving speed.");
    recos.push("Training: plyometric med-ball variations + controlled decel reps, band-speed rotations, technique reps with lighter implements to refine timing.");
  }

  if(peakF > 600) recos.push("Flag: High peak Force proxy‚Äîcheck technique and consider reducing stiffness at peak load (more joint flexion, smoother braking).");
  if(Math.abs(peakM) > 20) recos.push("Flag: High peak Moment proxy‚Äîprioritize trunk/hip stability + eccentric strength for rotation control.");
  if(peakW > 700) recos.push("Flag: Very high peak angular velocity‚Äîvalidate keypoint confidence; motion blur can inflate angular velocity.");

  const rows = [];
  rows.push({ section:"Event markers", item:"Peak projectile speed (m/s)", value: round(events.peakProjSpeed,3) });
  rows.push({ section:"Event markers", item:"Peak projectile idx", value: events.peakProjIdx });
  rows.push({ section:"Event markers", item:"Peak angular velocity (deg/s)", value: round(events.peakAngVel,2) });
  rows.push({ section:"Event markers", item:"Peak angular velocity idx", value: events.peakAngVelIdx });

  rows.push({ section:"Pattern classification", item:"Pattern", value: pattern });
  rows.push({ section:"Pattern classification", item:"Rationale", value: rationale });

  rows.push({ section:"Key values (overall)", item:"Peak linear velocity (m/s)", value: round(peakV,3) });
  rows.push({ section:"Key values (overall)", item:"Peak angular velocity (deg/s)", value: round(peakW,2) });
  rows.push({ section:"Key values (overall)", item:"Peak angular displacement ROM (deg)", value: round(rom,2) });
  rows.push({ section:"Key values (overall)", item:"Displacement (m)", value: round(dispNet,3) });
  rows.push({ section:"Key values (overall)", item:"Peak Force‚ÄìTime (N, filtered)", value: round(peakF,0) });
  rows.push({ section:"Key values (overall)", item:"Peak Moment‚ÄìTime (Nm, filtered)", value: round(peakM,3) });

  list.forEach(ph => {
    const blk = makeKinSummaryBlock(ph.name, driver, ph, rec, events)[0];
    rows.push({ section:"Phase summary", item:`${ph.name} duration (s)`, value: blk.duration_s });
    rows.push({ section:"Phase summary", item:`${ph.name} peak linVel (m/s)`, value: blk.peak_linVel_mps });
    rows.push({ section:"Phase summary", item:`${ph.name} peak angVel (deg/s)`, value: blk.peak_angVel_dps });
    rows.push({ section:"Phase summary", item:`${ph.name} ROM (deg)`, value: blk.peak_angDisplacement_deg });
    rows.push({ section:"Phase summary", item:`${ph.name} peak projectile speed (m/s)`, value: blk.peak_projectile_speed_mps });
  });

  recos.forEach((t, i) => rows.push({ section:"Recommendations", item:`R${i+1}`, value: t }));

  rows.push({ section:"Notes", item:"Method", value:"Event-based phases anchored on peak angular velocity and peak projectile speed windows. Kinetics are simplified proxies; interpret trends and relative changes." });
  return rows;
}

/* =========================================================
   Live interpretation
========================================================= */
function buildLiveInterpretation(kin, kinets) {
  if(!kin) return "‚Äî";
  const parts = [];
  parts.push(`Driver: ${kin.driver}`);
  parts.push(`v: ${kin.v_mps.toFixed(2)} m/s | œâ: ${kin.angVel_dps.toFixed(0)} ¬∞/s | Œ∏: ${kin.angle_deg.toFixed(1)}¬∞ | disp: ${kin.disp_m.toFixed(2)} m`);
  if(kinets) parts.push(`Force: ${kinets.forceFilt_N.toFixed(0)} N | Moment: ${kinets.momentFilt_Nm.toFixed(2)} Nm`);
  if(kin.projValid) parts.push(`Projectile speed: ${kin.projSpeed_mps.toFixed(2)} m/s`);
  return parts.join("\n");
}

/* =========================================================
   UI: metric selection
========================================================= */
function addMetric() {
  const type = document.getElementById('metricType').value;
  const joint = document.getElementById('metricJoint').value;
  const side = document.getElementById('metricSide').value;
  const id = `${type}_${joint}_${side}`;
  if(!selectedMetrics.find(m => m.id === id)) {
    selectedMetrics.push({id, type, joint, side});
    renderMetricChips();
  }
}
function removeMetric(id) { selectedMetrics = selectedMetrics.filter(m => m.id !== id); renderMetricChips(); }
function clearMetrics() { selectedMetrics = []; renderMetricChips(); }

function renderMetricChips() {
  const chips = document.getElementById('metricChips');
  const panel = document.getElementById('selectedMetricsPanel');
  chips.innerHTML = "";
  panel.innerHTML = "";
  selectedMetrics.forEach(m => {
    const label = `${m.type} ${m.joint} ${m.side}`;
    const chip = document.createElement('div');
    chip.className = "chip";
    chip.innerHTML = `${label} <button onclick="removeMetric('${m.id}')">‚úï</button>`;
    chips.appendChild(chip);

    const card = document.createElement('div');
    card.className = "metric";
    card.innerHTML = `
      <div class="t">${label}</div>
      <div class="v" id="val_${m.id}">--</div>
      <div class="s">${metricHint(m)}</div>
    `;
    panel.appendChild(card);
  });
}
function metricHint(m) {
  if(m.type === "linVel") return "Linear velocity (m/s) of the joint point in 2D.";
  if(m.type === "angVel") return "Angular velocity (¬∞/s) from change in joint angle frame-to-frame.";
  if(m.type === "angle") return (m.joint === "wrist" || m.joint === "ankle")
    ? "Proxy angle in 2D (limited without hand/foot keypoints). Trend only."
    : "Joint angle (¬∞) in 2D.";
  return "";
}

/* =========================================================
   Collapsible + PiP + Status
========================================================= */
function toggleCollapse(id) {
  const el = document.getElementById(id);
  el.classList.toggle('collapsed');
  document.getElementById(id+'_lbl').innerText = el.classList.contains('collapsed') ? "Expand" : "Collapse";
}
function togglePiP() { document.body.classList.toggle('pip-on'); }

function showStatus(msg, type) {
  const el = document.getElementById('statusMessage');
  el.innerText = msg;
  el.className = `status-message status-${type}`;
  el.style.display = 'block';
  setTimeout(() => el.style.display='none', 3000);
}
function setStatusText(t) { document.getElementById('statusText').innerText = t; }
function setSourceText(t) { document.getElementById('sourceText').innerText = t; }

/* =========================================================
   Utility
========================================================= */
function clamp(x, a, b){ return Math.max(a, Math.min(b, x)); }
function clampInt(x, a, b){ return Math.max(a, Math.min(b, Math.round(x))); }
function round(x, dp){ if(!isFinite(x)) return 0; const p = Math.pow(10,dp); return Math.round(x*p)/p; }
function slice(arr, i0, i1){ return arr.slice(i0, i1+1); }
function mean(arr){ if(!arr.length) return 0; return arr.reduce((s,x)=>s+(+x||0),0)/arr.length; }
function maxAbs(arr){ if(!arr.length) return 0; let m=0; arr.forEach(x=>{ const a=Math.abs(+x||0); if(a>m) m=a; }); return m; }
function argMaxAbs(arr){ let best=0, bestV=-1; for(let i=0;i<arr.length;i++){ const a=Math.abs(+arr[i]||0); if(a>bestV){ bestV=a; best=i; } } return best; }
function safeDiv(x, d){ return (d===0)?0:(x/d); }
</script>
</body>
</html>
