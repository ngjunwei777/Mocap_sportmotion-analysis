<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <meta name="author" content="Ng Jun Wei">
  <meta name="copyright" content="¬© 2025 Ng Jun Wei. All rights reserved.">
  <title>Sport Performance Analyzer (iOS) + Joint-Driven Kinetics</title>

  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.11.0"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@2.1.0"></script>

  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.3"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

  <style>
    * { margin:0; padding:0; box-sizing:border-box; }
    body{
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 14px;
      padding-bottom: 80px; /* Space for footer/pip */
    }
    .container{
      max-width: 1400px;
      margin: 0 auto;
      background:#fff;
      border-radius: 18px;
      padding: 16px;
      box-shadow: 0 18px 55px rgba(0,0,0,0.22);
    }
    h1 { text-align:center; color:#667eea; margin-bottom:6px; font-size:2.05em; }
    .subtitle{ text-align:center; color:#666; margin-bottom:14px; font-size:1.02em; }

    .layout{
      display:grid;
      grid-template-columns: 1.08fr 0.92fr;
      gap: 14px;
      align-items:start;
    }
    @media (max-width: 980px){ .layout{ grid-template-columns: 1fr; } }

    .card{ background:#f8f9fa; border-radius: 14px; padding: 14px; }
    .form-grid{
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(190px, 1fr));
      gap: 10px;
      margin-top: 10px;
    }
    label{ font-weight: 850; margin-bottom: 6px; color:#333; display:block; }
    input, select{
      width:100%;
      padding: 10px;
      border: 2px solid #ddd;
      border-radius: 12px;
      font-size: 14px;
      background:#fff;
    }
    input:focus, select:focus{ outline:none; border-color:#667eea; }

    .btn{
      padding: 11px 14px;
      border: none;
      border-radius: 12px;
      font-size: 14px;
      font-weight: 900;
      cursor:pointer;
      margin: 8px 8px 0 0;
      transition: transform .15s, opacity .15s;
    }
    .btn:hover{ transform: translateY(-1px); }
    .btn:disabled{ background:#cfcfcf !important; cursor:not-allowed; opacity:.85; transform:none; }
    .btn-primary{ background:#667eea; color:#fff; }
    .btn-success{ background:#10b981; color:#fff; }
    .btn-danger { background:#ef4444; color:#fff; }

    .status-message{
      display:none;
      text-align:center;
      padding: 10px 12px;
      border-radius: 12px;
      font-weight: 950;
      margin: 10px 0 14px 0;
    }
    .status-success{ background:#d1fae5; color:#065f46; }
    .status-error{ background:#fee2e2; color:#991b1b; }
    .status-info{ background:#dbeafe; color:#1e40af; }

    /* Desktop sticky */
    .sticky{ position: sticky; top: 8px; }
    @media (max-width: 980px){ .sticky{ top: 0; z-index: 50; position: static; } }

    .video-wrap{ position:relative; background:#000; border-radius: 14px; overflow:hidden; min-height: 200px; }
    video{
      width:100%;
      height:auto;
      display:block;
      position:relative;
      z-index:1;
      /* Mirror effect logic handled in JS/CSS depending on camera */
    }
    canvas#overlay{
      width:100%;
      height:100%;
      display:block;
      position:absolute;
      left:0; top:0;
      z-index:5;
      pointer-events:none;
    }
    .hud{
      position:absolute;
      top: 10px; right: 10px;
      z-index: 10;
      background: rgba(0,0,0,0.72);
      color:#fff;
      padding: 6px 10px;
      border-radius: 12px;
      font-size: 13px;
      font-weight: 950;
      display:flex;
      flex-direction: column;
      gap:6px;
      align-items:flex-end;
      max-width: 95%;
    }
    .hud small{ font-weight: 850; opacity: .92; }

    .divider{ height:1px; background:#e9e9e9; margin: 12px 0; }
    .mini{ color:#666; font-size: .88em; line-height: 1.35; margin-top: 8px; }

    .metrics-grid{
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 10px;
      margin-top: 10px;
    }
    .metric{
      background:#fff;
      border-radius: 14px;
      padding: 12px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.06);
    }
    .metric .t{ color:#666; font-weight:850; font-size:.92em; margin-bottom: 6px; }
    .metric .v{ color:#667eea; font-weight: 1000; font-size: 1.55em; }

    .chiplist{ margin-top: 10px; display:flex; flex-wrap:wrap; gap: 8px; }
    .chip{
      background:#fff;
      border-radius: 999px;
      padding: 6px 10px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.06);
      display:flex;
      align-items:center;
      gap: 10px;
      font-weight: 900;
      color:#333;
      font-size: 13px;
    }
    .chip button{
      border:none;
      background: rgba(239,68,68,0.12);
      color:#ef4444;
      font-weight: 1000;
      border-radius: 999px;
      padding: 4px 8px;
      cursor:pointer;
    }

    .charts-grid{ display:grid; grid-template-columns: 1fr; gap: 12px; margin-top: 10px; }
    .chart-card{
      background:#fff;
      border-radius: 14px;
      padding: 12px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.06);
    }
    .chart-title{
      display:flex;
      justify-content: space-between;
      align-items:center;
      gap: 10px;
      margin-bottom: 8px;
    }
    .chart-title b{ color:#222; }
    .chart-title span{ color:#666; font-weight: 850; font-size: .9em; }
    canvas.chart{
      width: 100%;
      height: 150px;
      display:block;
      border-radius: 12px;
      background: #fafafa;
    }

    .participants-list .item{
      background:#fff;
      border-radius: 14px;
      padding: 12px;
      margin-top: 10px;
      display:flex;
      justify-content: space-between;
      gap: 12px;
      align-items:center;
      box-shadow: 0 2px 10px rgba(0,0,0,0.06);
    }

    /* Collapsible */
    .card-head{
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 6px;
    }
    .collapse-btn{
      display:inline-flex;
      align-items:center;
      gap: 8px;
      border:none;
      cursor:pointer;
      border-radius: 12px;
      padding: 10px 12px;
      font-weight: 1000;
      background: rgba(102,126,234,0.12);
      color:#3b4bd6;
    }
    .collapse-icon{
      width: 10px;
      height: 10px;
      border-right: 3px solid currentColor;
      border-bottom: 3px solid currentColor;
      transform: rotate(45deg);
      transition: transform .18s ease;
      margin-left: 2px;
    }
    .collapsed .collapse-icon{ transform: rotate(-45deg); }
    .collapsible{
      overflow: hidden;
      transition: max-height .22s ease, opacity .22s ease;
      max-height: 2000px;
      opacity: 1;
    }
    .collapsed .collapsible{
      max-height: 0px;
      opacity: 0;
      pointer-events: none;
    }

    footer{ margin-top: 14px; text-align:center; color:#666; font-weight: 850; font-size: 0.92em; }

    /* Mobile PiP */
    .pip-toggle{ display:none; margin-top: 10px; }
    @media (max-width: 980px) {
      .pip-toggle{ display:inline-block; }
      body.pip-on .sticky .card{
        position: fixed;
        left: 12px; right: 12px; bottom: 12px;
        z-index: 9999;
        padding: 10px;
        box-shadow: 0 18px 55px rgba(0,0,0,0.35);
        max-width: 520px;
        margin: 0 auto;
      }
      body.pip-on .container{ padding-bottom: 270px; }
    }
  </style>
</head>

<body>
<div class="container">
  <h1>üèÉ‚Äç‚ôÇÔ∏è Movement Kinetics Lab</h1>
  <p class="subtitle">iOS-safe overlay ‚Ä¢ selectable metrics ‚Ä¢ joint-driven Force‚ÄìTime & Moment‚ÄìTime ‚Ä¢ projectile tracking</p>

  <div id="statusMessage" class="status-message"></div>

  <div class="layout">
    <div>
      <div class="card">
        <h3>Participant</h3>
        <div class="form-grid">
          <div><label>Name *</label><input id="participantName" placeholder="Enter name"></div>
          <div>
            <label>Sex *</label>
            <select id="participantSex"><option value="male">Male</option><option value="female">Female</option></select>
          </div>
          <div><label>Age *</label><input id="participantAge" type="number" value="25"></div>
          <div><label>Mass (kg) *</label><input id="participantMass" type="number" value="70"></div>
          <div><label>Height (cm) *</label><input id="participantHeight" type="number" value="175"></div>
        </div>
        <button class="btn btn-success" onclick="addParticipant()">Add Participant</button>

        <div class="divider"></div>

        <label>Select Participant</label>
        <select id="selectedParticipant"></select>

        <div class="form-grid">
          <div>
             <label>FPS</label>
             <select id="fpsSelection"><option value="30">30 FPS</option><option value="60" selected>60 FPS</option></select>
          </div>
          <div>
             <label>Camera</label>
             <select id="cameraFacing"><option value="environment">Back</option><option value="user">Front</option></select>
          </div>
          <div>
            <label>Window (s)</label>
            <select id="windowSeconds"><option value="5">5s</option><option value="10" selected>10s</option></select>
          </div>
          <div>
             <label>Smoothing (Hz)</label>
             <select id="cutoffHz"><option value="4">4 Hz</option><option value="6" selected>6 Hz</option><option value="12">12 Hz</option></select>
          </div>
        </div>

        <div class="divider"></div>
        
        <h3>Projectile Tracking</h3>
        <div class="form-grid">
           <div>
             <label>Mode</label>
             <select id="projMode">
               <option value="off" selected>Off</option>
               <option value="coco">Object Detect (COCO-SSD)</option>
             </select>
           </div>
           <div>
             <label>Class</label>
             <select id="projClassHint"><option value="sports ball">Sports ball</option><option value="person">Person</option></select>
           </div>
        </div>

        <button class="btn btn-primary" onclick="startCamera()">Start Camera</button>
        <button class="btn btn-danger" onclick="stopCamera()">Stop Camera</button>
        <button class="btn btn-success" id="recordBtn" onclick="toggleRecording()" disabled>Start Recording</button>
        <button class="btn btn-primary pip-toggle" onclick="togglePiP()">üìå Pin Video (PiP)</button>

        <div class="divider"></div>
        
        <h3>Video Upload Analysis</h3>
        <div class="form-grid">
           <div><label>Video File</label><input id="videoUpload" type="file" accept="video/*"></div>
        </div>
        <button class="btn btn-primary" onclick="loadUploadedVideo()">Analyze Upload</button>
      </div>

      <div class="card collapsible-card" id="displaySelectorCard" style="margin-top:12px;">
        <div class="card-head">
          <h3 style="margin:0;">Display Selector</h3>
          <button class="collapse-btn" onclick="toggleCollapse('displaySelectorCard')">
            <span id="displaySelectorCard_lbl">Collapse</span><span class="collapse-icon"></span>
          </button>
        </div>
        <div class="collapsible">
           <div class="form-grid">
             <div>
               <label>Metric</label>
               <select id="metricType">
                 <option value="angle">Angle (¬∞)</option>
                 <option value="angVel">Ang. Vel (¬∞/s)</option>
                 <option value="linVel">Lin. Vel (m/s)</option>
               </select>
             </div>
             <div>
               <label>Joint</label>
               <select id="metricJoint">
                  <option value="shoulder">Shoulder</option><option value="elbow">Elbow</option>
                  <option value="hip">Hip</option><option value="knee">Knee</option>
               </select>
             </div>
             <div>
               <label>Side</label>
               <select id="metricSide"><option value="R">Right</option><option value="L">Left</option></select>
             </div>
           </div>
           <button class="btn btn-primary" onclick="addMetric()">Add</button>
           <button class="btn btn-danger" onclick="clearMetrics()">Clear</button>
           <div class="chiplist" id="metricChips"></div>
           <div class="divider"></div>
           <div class="metrics-grid" id="selectedMetricsPanel"></div>
        </div>
      </div>

      <div class="card" style="margin-top:12px;">
         <h3>Kinetics Driver</h3>
         <div class="form-grid">
           <div>
             <label>Driver Joint</label>
             <select id="kinJoint">
               <option value="hip">Hip</option><option value="knee">Knee</option>
               <option value="shoulder">Shoulder</option><option value="elbow">Elbow</option>
             </select>
           </div>
           <div>
             <label>Side</label>
             <select id="kinSide"><option value="R">Right</option><option value="L">Left</option></select>
           </div>
         </div>
         <p class="mini">Uses F=ma (Linear) and œÑ=IŒ± (Angular) based on body segment parameters.</p>
      </div>

      <div class="card" style="margin-top:12px;">
        <h3>Real-time Charts</h3>
        <div class="charts-grid">
           <div class="chart-card">
              <div class="chart-title"><b>Force (N)</b><span id="lblForce">0 N</span></div>
              <canvas id="chartForce" class="chart"></canvas>
           </div>
           <div class="chart-card">
              <div class="chart-title"><b>Moment (Nm)</b><span id="lblMoment">0 Nm</span></div>
              <canvas id="chartMoment" class="chart"></canvas>
           </div>
        </div>
      </div>

      <div class="card" style="margin-top:12px;">
         <button class="btn btn-primary" onclick="downloadData()">üìä Download All Data (XLSX)</button>
      </div>

    </div>

    <div class="sticky" id="stickyVideo">
      <div class="card">
         <h3>Live View</h3>
         <div class="video-wrap">
            <video id="video" playsinline muted></video>
            <canvas id="overlay"></canvas>
            <div class="hud">
               <div id="fpsIndicator">FPS: 0</div>
               <small id="statusText">Ready</small>
            </div>
         </div>
      </div>
    </div>
  </div>

  <footer>¬© 2025 Ng Jun Wei. All rights reserved.</footer>
</div>

<script>
  // --- Globals ---
  let detector, cocoModel;
  let video, overlay, ctx, streamRef;
  let animationId;
  let participants = [];
  let currentParticipant = null;
  let isRecording = false;
  let recordingData = [];
  
  // State
  let prevFrameT = 0;
  let prevKeypoints = null;
  let selectedMetrics = [];
  
  // Physics State
  const chartSeries = { forceRaw:[], forceFilt:[], momentRaw:[], momentFilt:[] };
  let detectedFPS = 0;
  let frameCount = 0;
  let lastFPSUpdate = Date.now();

  // Consts
  const KP = {
    nose:0, left_eye:1, right_eye:2, left_ear:3, right_ear:4,
    shoulder_L:5, shoulder_R:6, elbow_L:7, elbow_R:8, wrist_L:9, wrist_R:10,
    hip_L:11, hip_R:12, knee_L:13, knee_R:14, ankle_L:15, ankle_R:16
  };
  const SKELETON = [
    [5,6],[5,7],[7,9],[6,8],[8,10],[5,11],[6,12],[11,12],[11,13],[13,15],[12,14],[14,16]
  ];
  // Winter's Anthropometry (Simplified Mass Fractions)
  const SEG_MASS = { 
    thigh: 0.1, shank: 0.0465, foot: 0.0145, 
    upperArm: 0.028, forearm: 0.016, hand: 0.006, trunk: 0.5 
  };

  // --- Initialization ---
  window.onload = async () => {
    video = document.getElementById('video');
    overlay = document.getElementById('overlay');
    ctx = overlay.getContext('2d');

    // Init default participant
    document.getElementById('participantName').value = "Athlete 1";
    addParticipant();

    showStatus("Loading Neural Networks...", "info");
    try {
      await tf.ready();
      // MoveNet Lightning (Faster)
      detector = await poseDetection.createDetector(
        poseDetection.SupportedModels.MoveNet,
        { modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING }
      );
      // COCO-SSD (Projectile)
      cocoModel = await cocoSsd.load();
      showStatus("Models Ready. Start Camera.", "success");
    } catch(e) {
      console.error(e);
      showStatus("Error loading models.", "error");
    }
  };

  // --- Camera & Video Handling ---
  async function startCamera() {
    if(!detector) return showStatus("Wait for models.", "error");
    stopActiveStream(); // clear previous

    const fpsReq = parseInt(document.getElementById('fpsSelection').value);
    const facing = document.getElementById('cameraFacing').value;

    const constraints = {
      video: {
        facingMode: facing,
        width: { ideal: 1280 },
        height: { ideal: 720 },
        frameRate: { ideal: fpsReq }
      },
      audio: false
    };

    try {
      streamRef = await navigator.mediaDevices.getUserMedia(constraints);
      video.srcObject = streamRef;
      video.onloadedmetadata = () => {
        video.play();
        overlay.width = video.videoWidth;
        overlay.height = video.videoHeight;
        
        // Mirror if front camera
        if(facing === 'user') {
          video.style.transform = "scaleX(-1)";
          overlay.style.transform = "scaleX(-1)";
        } else {
          video.style.transform = "none";
          overlay.style.transform = "none";
        }
        
        document.getElementById('recordBtn').disabled = false;
        requestAnimationFrame(renderLoop);
      };
      showStatus("Camera Active", "success");
    } catch(err) {
      showStatus("Camera Error: " + err.message, "error");
    }
  }

  function loadUploadedVideo() {
    const fileInput = document.getElementById('videoUpload');
    if(!fileInput.files.length) return showStatus("Select a file first.", "error");
    stopActiveStream();

    const url = URL.createObjectURL(fileInput.files[0]);
    video.src = url;
    video.onloadedmetadata = () => {
      overlay.width = video.videoWidth;
      overlay.height = video.videoHeight;
      video.play();
      video.loop = true;
      document.getElementById('recordBtn').disabled = false;
      requestAnimationFrame(renderLoop);
      showStatus("Playing Video", "success");
    };
  }

  function stopActiveStream() {
    if(streamRef) streamRef.getTracks().forEach(t=>t.stop());
    video.srcObject = null;
    video.pause();
    cancelAnimationFrame(animationId);
    ctx.clearRect(0,0,overlay.width, overlay.height);
  }

  function stopCamera(){
    stopActiveStream();
    showStatus("Stopped", "info");
  }

  // --- Main Loop ---
  async function renderLoop() {
    if(!video.paused && !video.ended) {
      // 1. FPS Calculation
      frameCount++;
      const now = Date.now();
      if(now - lastFPSUpdate >= 1000){
        detectedFPS = frameCount;
        document.getElementById('fpsIndicator').innerText = "FPS: " + detectedFPS;
        frameCount=0; lastFPSUpdate=now;
      }

      // 2. Inference
      let poses = [];
      let projectiles = [];
      
      try {
        poses = await detector.estimatePoses(video, { flipHorizontal: false });
        
        // Projectile Detection (Only if enabled)
        if(document.getElementById('projMode').value === 'coco' && cocoModel) {
            // Optimization: Detect projectile every 3rd frame to save FPS
            if(frameCount % 3 === 0) {
                const preds = await cocoModel.detect(video);
                const cls = document.getElementById('projClassHint').value;
                projectiles = preds.filter(p => p.class === cls);
            }
        }
      } catch(e){}

      // 3. Draw
      ctx.clearRect(0,0,overlay.width, overlay.height);
      const timeSec = now / 1000;
      const dt = prevFrameT ? (timeSec - prevFrameT) : 0.016;
      prevFrameT = timeSec;

      if(poses.length > 0) {
        const kp = poses[0].keypoints;
        drawSkeleton(kp);
        drawProjectile(projectiles);
        
        // Physics
        processMetrics(kp);
        const kinetics = processKinetics(kp, dt, timeSec);
        
        // Recording
        if(isRecording) {
            recordFrame(timeSec, kp, kinetics);
        }

        prevKeypoints = kp;
      }
      
      // Update Charts
      throttleChartDraw(timeSec);
    }
    animationId = requestAnimationFrame(renderLoop);
  }

  // --- Drawing Logic ---
  function drawSkeleton(kp) {
    const minScore = 0.3;
    ctx.lineWidth = 3;
    ctx.strokeStyle = "#00ff00";
    
    SKELETON.forEach(([i, j]) => {
      if(kp[i].score > minScore && kp[j].score > minScore) {
        ctx.beginPath(); ctx.moveTo(kp[i].x, kp[i].y); ctx.lineTo(kp[j].x, kp[j].y); ctx.stroke();
      }
    });
    
    kp.forEach(p => {
      if(p.score > minScore) {
        ctx.beginPath(); ctx.arc(p.x, p.y, 5, 0, 2*Math.PI); ctx.fillStyle = "red"; ctx.fill();
      }
    });
  }

  function drawProjectile(projs) {
      if(!projs || projs.length === 0) return;
      ctx.strokeStyle = "orange";
      ctx.lineWidth = 2;
      projs.forEach(p => {
          // BBox: [x, y, width, height]
          const x = p.bbox[0], y = p.bbox[1], w = p.bbox[2], h = p.bbox[3];
          ctx.strokeRect(x, y, w, h);
          ctx.fillStyle = "orange";
          ctx.fillText(`${p.class} ${(p.score*100).toFixed(0)}%`, x, y > 10 ? y-5 : y+10);
      });
  }

  // --- Math & Physics ---
  function getPxToMeter() {
      // Rough estimate: Assume User Height = Distance from Ankle to Eye * 1.1 (pixels)
      // Or fallback: Video height ~ 2.5m (User stands back)
      // This is a simplified scale for demo
      return currentParticipant ? (currentParticipant.height / 100) / (overlay.height * 0.8) : 0.0025;
  }

  function processMetrics(kp) {
    selectedMetrics.forEach(m => {
      let val = 0;
      const jIdx = KP[`${m.joint}_${m.side}`];
      if(kp[jIdx].score > 0.3) {
         if(m.type === 'angle') val = getJointAngle(kp, m.joint, m.side);
         else if(m.type === 'linVel') val = getLinearVel(kp, jIdx);
         // angVel requires previous frame, simplified here
      }
      document.getElementById(`val_${m.id}`).innerText = val.toFixed(1);
    });
  }

  function getJointAngle(kp, joint, side) {
    // Basic mapping
    let a, b, c; // a=anchor, b=center, c=end
    if(joint==='elbow'){ a=`shoulder_${side}`; b=`elbow_${side}`; c=`wrist_${side}`; }
    else if(joint==='knee'){ a=`hip_${side}`; b=`knee_${side}`; c=`ankle_${side}`; }
    else if(joint==='hip'){ a=`shoulder_${side}`; b=`hip_${side}`; c=`knee_${side}`; }
    else return 0;
    
    const pA=kp[KP[a]], pB=kp[KP[b]], pC=kp[KP[c]];
    if(pA.score<0.3 || pB.score<0.3 || pC.score<0.3) return 0;
    
    const rad = Math.atan2(pC.y - pB.y, pC.x - pB.x) - Math.atan2(pA.y - pB.y, pA.x - pB.x);
    let deg = Math.abs(rad * 180.0 / Math.PI);
    return deg > 180 ? 360 - deg : deg;
  }

  function getLinearVel(kp, idx) {
      if(!prevKeypoints) return 0;
      const curr = kp[idx], prev = prevKeypoints[idx];
      const distPx = Math.sqrt(Math.pow(curr.x-prev.x, 2) + Math.pow(curr.y-prev.y, 2));
      const fps = detectedFPS || 60;
      return distPx * getPxToMeter() * fps;
  }

  function processKinetics(kp, dt, t) {
      if(!prevKeypoints || !currentParticipant) return null;
      
      const jName = document.getElementById('kinJoint').value;
      const side = document.getElementById('kinSide').value;
      const kpIdx = KP[`${jName}_${side}`];
      
      const curr = kp[kpIdx];
      const prev = prevKeypoints[kpIdx];

      let forceFilt = 0, momentFilt = 0;

      if(curr.score > 0.3 && prev.score > 0.3) {
          const scale = getPxToMeter();
          
          // 1. Acceleration
          const vx = (curr.x - prev.x) * scale / dt;
          const vy = (curr.y - prev.y) * scale / dt;
          const vTotal = Math.sqrt(vx*vx + vy*vy);
          const accel = vTotal / dt; // Instantaneous approx

          // 2. Mass
          let seg = 'thigh';
          if(jName === 'knee') seg = 'shank';
          if(jName === 'shoulder') seg = 'upperArm';
          if(jName === 'elbow') seg = 'forearm';
          
          const mass = currentParticipant.mass * (SEG_MASS[seg] || 0.1);
          const forceRaw = mass * accel;

          // 3. Torque Proxy (Lever arm 0.3m approx)
          const momentRaw = forceRaw * 0.3;

          // 4. Filter
          const hz = parseFloat(document.getElementById('cutoffHz').value);
          forceFilt = lowPass(getLastVal('forceFilt'), forceRaw, dt, hz);
          momentFilt = lowPass(getLastVal('momentFilt'), momentRaw, dt, hz);

          // Update UI
          document.getElementById('lblForce').innerText = forceFilt.toFixed(0) + " N";
          document.getElementById('lblMoment').innerText = momentFilt.toFixed(1) + " Nm";

          // Push Data
          pushData('forceRaw', t, forceRaw);
          pushData('forceFilt', t, forceFilt);
          pushData('momentRaw', t, momentRaw);
          pushData('momentFilt', t, momentFilt);
      }
      return { force: forceFilt, moment: momentFilt };
  }

  // --- Utilities ---
  function lowPass(prev, curr, dt, fc) {
      const rc = 1.0 / (2 * Math.PI * fc);
      const alpha = dt / (rc + dt);
      return prev + alpha * (curr - prev);
  }

  function pushData(key, t, v) {
    const win = parseInt(document.getElementById('windowSeconds').value);
    chartSeries[key].push({t, v});
    while(chartSeries[key].length > 0 && chartSeries[key][0].t < t - win) {
      chartSeries[key].shift();
    }
  }
  function getLastVal(key){ const a = chartSeries[key]; return a.length ? a[a.length-1].v : 0; }

  // --- Charts ---
  let lastChartDraw = 0;
  function throttleChartDraw(t) {
    if(t - lastChartDraw < 0.1) return; // 10fps UI update
    lastChartDraw = t;
    drawChart('chartForce', 'forceRaw', 'forceFilt', '#10b981');
    drawChart('chartMoment', 'momentRaw', 'momentFilt', '#ef4444');
  }

  function drawChart(id, rawKey, filtKey, color) {
    const c = document.getElementById(id);
    const ctx = c.getContext('2d');
    const w = c.width = c.clientWidth;
    const h = c.height = c.clientHeight;
    ctx.clearRect(0,0,w,h);
    
    // Grid
    ctx.strokeStyle="#eee"; ctx.beginPath(); ctx.moveTo(0,h/2); ctx.lineTo(w,h/2); ctx.stroke();
    
    const data = chartSeries[filtKey];
    if(data.length < 2) return;
    
    // Find max for scaling
    let max = 1; 
    data.forEach(d => { if(Math.abs(d.v) > max) max = Math.abs(d.v); });
    
    const win = parseInt(document.getElementById('windowSeconds').value);
    const now = data[data.length-1].t;

    ctx.strokeStyle = color; ctx.lineWidth=2; ctx.beginPath();
    data.forEach((pt, i) => {
       const x = ((win - (now - pt.t)) / win) * w;
       const y = h - ((pt.v / (max*1.2)) * (h/2) + h/2); // Center zero
       if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    });
    ctx.stroke();
  }

  // --- UI Helpers ---
  function addParticipant() {
    const name = document.getElementById('participantName').value;
    const m = parseFloat(document.getElementById('participantMass').value);
    const h = parseFloat(document.getElementById('participantHeight').value);
    if(name && m && h) {
       currentParticipant = { name, mass:m, height:h };
       const sel = document.getElementById('selectedParticipant');
       const opt = document.createElement('option');
       opt.text = name; opt.value = name;
       sel.add(opt); sel.value = name;
       showStatus(`Added ${name}`, 'success');
    }
  }

  function addMetric() {
    const type = document.getElementById('metricType').value;
    const joint = document.getElementById('metricJoint').value;
    const side = document.getElementById('metricSide').value;
    const id = `${type}_${joint}_${side}`;
    if(!selectedMetrics.find(m => m.id === id)){
        selectedMetrics.push({id, type, joint, side});
        renderMetricChips();
    }
  }
  function clearMetrics() { selectedMetrics = []; renderMetricChips(); }
  function renderMetricChips() {
     const chips = document.getElementById('metricChips');
     const panel = document.getElementById('selectedMetricsPanel');
     chips.innerHTML = ""; panel.innerHTML = "";
     selectedMetrics.forEach(m => {
        chips.innerHTML += `<div class="chip">${m.type} ${m.joint} ${m.side}</div>`;
        panel.innerHTML += `<div class="metric"><div class="t">${m.type} ${m.joint} ${m.side}</div><div class="v" id="val_${m.id}">--</div></div>`;
     });
  }

  function toggleCollapse(id) {
    const el = document.getElementById(id);
    el.classList.toggle('collapsed');
    document.getElementById(id+'_lbl').innerText = el.classList.contains('collapsed') ? "Expand" : "Collapse";
  }

  function togglePiP() { document.body.classList.toggle('pip-on'); }
  function showStatus(msg, type) {
     const el = document.getElementById('statusMessage');
     el.innerText = msg; el.className = `status-message status-${type}`;
     el.style.display = 'block';
     setTimeout(() => el.style.display='none', 3000);
  }

  // --- Recording & Export ---
  function toggleRecording() {
      const btn = document.getElementById('recordBtn');
      if(!isRecording) {
          isRecording = true;
          recordingData = [];
          btn.innerText = "Stop Recording";
          btn.className = "btn btn-danger";
          showStatus("Recording started...", "info");
      } else {
          isRecording = false;
          btn.innerText = "Start Recording";
          btn.className = "btn btn-success";
          showStatus(`Recording saved. ${recordingData.length} frames.`, "success");
      }
  }

  function recordFrame(t, kp, kin) {
      const frame = { time: t, kinForce: kin?.force||0, kinMoment: kin?.moment||0 };
      kp.forEach((p, i) => {
         frame[`kp_${i}_x`] = p.x;
         frame[`kp_${i}_y`] = p.y;
      });
      recordingData.push(frame);
  }

  function downloadData() {
      if(recordingData.length === 0) return showStatus("No data recorded.", "error");
      
      const ws = XLSX.utils.json_to_sheet(recordingData);
      const wb = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb, ws, "MotionData");
      XLSX.writeFile(wb, "sport_analysis.xlsx");
  }
</script>
</body>
</html>
