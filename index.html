<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <meta name="author" content="Ng Jun Wei">
  <meta name="copyright" content="¬© 2025 Ng Jun Wei. All rights reserved.">
  <title>Sport Performance Analyzer (iOS) + Joint-Driven Kinetics</title>

  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.11.0"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@2.1.0"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.3"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

  <style>
    * { margin:0; padding:0; box-sizing:border-box; }
    body{
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 14px;
      padding-bottom: 80px;
    }
    .container{
      max-width: 1400px;
      margin: 0 auto;
      background:#fff;
      border-radius: 18px;
      padding: 16px;
      box-shadow: 0 18px 55px rgba(0,0,0,0.22);
    }
    h1 { text-align:center; color:#667eea; margin-bottom:6px; font-size:2.05em; }
    .subtitle{ text-align:center; color:#666; margin-bottom:14px; font-size:1.02em; }

    .layout{
      display:grid;
      grid-template-columns: 1.08fr 0.92fr;
      gap: 14px;
      align-items:start;
    }
    @media (max-width: 980px){ .layout{ grid-template-columns: 1fr; } }

    .card{ background:#f8f9fa; border-radius: 14px; padding: 14px; }
    .form-grid{
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(190px, 1fr));
      gap: 10px;
      margin-top: 10px;
    }
    label{ font-weight: 850; margin-bottom: 6px; color:#333; display:block; }
    input, select{
      width:100%;
      padding: 10px;
      border: 2px solid #ddd;
      border-radius: 12px;
      font-size: 14px;
      background:#fff;
    }
    input:focus, select:focus{ outline:none; border-color:#667eea; }

    .btn{
      padding: 11px 14px;
      border: none;
      border-radius: 12px;
      font-size: 14px;
      font-weight: 900;
      cursor:pointer;
      margin: 8px 8px 0 0;
      transition: transform .15s, opacity .15s;
    }
    .btn:hover{ transform: translateY(-1px); }
    .btn:disabled{ background:#cfcfcf !important; cursor:not-allowed; opacity:.85; transform:none; }
    .btn-primary{ background:#667eea; color:#fff; }
    .btn-success{ background:#10b981; color:#fff; }
    .btn-danger { background:#ef4444; color:#fff; }
    .btn-ghost { background: rgba(102,126,234,0.12); color:#3b4bd6; }

    .status-message{
      display:none;
      text-align:center;
      padding: 10px 12px;
      border-radius: 12px;
      font-weight: 950;
      margin: 10px 0 14px 0;
    }
    .status-success{ background:#d1fae5; color:#065f46; }
    .status-error{ background:#fee2e2; color:#991b1b; }
    .status-info{ background:#dbeafe; color:#1e40af; }

    .sticky{ position: sticky; top: 8px; }
    @media (max-width: 980px){ .sticky{ top: 0; z-index: 50; position: static; } }

    .video-wrap{ position:relative; background:#000; border-radius: 14px; overflow:hidden; min-height: 200px; }
    video{ width:100%; height:auto; display:block; position:relative; z-index:1; }
    canvas#overlay{
      width:100%; height:100%; display:block;
      position:absolute; left:0; top:0;
      z-index:5; pointer-events:none;
    }
    .hud{
      position:absolute; top: 10px; right: 10px;
      z-index: 10;
      background: rgba(0,0,0,0.72);
      color:#fff;
      padding: 6px 10px;
      border-radius: 12px;
      font-size: 13px;
      font-weight: 950;
      display:flex;
      flex-direction: column;
      gap:6px;
      align-items:flex-end;
      max-width: 95%;
      white-space: pre-line;
    }
    .divider{ height:1px; background:#e9e9e9; margin: 12px 0; }
    .mini{ color:#666; font-size: .88em; line-height: 1.35; margin-top: 8px; }

    .metrics-grid{
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 10px;
      margin-top: 10px;
    }
    .metric{
      background:#fff;
      border-radius: 14px;
      padding: 12px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.06);
    }
    .metric .t{ color:#666; font-weight:850; font-size:.92em; margin-bottom: 6px; }
    .metric .v{ color:#667eea; font-weight: 1000; font-size: 1.55em; }
    .metric .s{ color:#666; font-weight: 850; font-size: .88em; margin-top: 6px; line-height: 1.25; }

    .chiplist{ margin-top: 10px; display:flex; flex-wrap:wrap; gap: 8px; }
    .chip{
      background:#fff;
      border-radius: 999px;
      padding: 6px 10px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.06);
      display:flex;
      align-items:center;
      gap: 10px;
      font-weight: 900;
      color:#333;
      font-size: 13px;
    }
    .chip button{
      border:none;
      background: rgba(239,68,68,0.12);
      color:#ef4444;
      font-weight: 1000;
      border-radius: 999px;
      padding: 4px 8px;
      cursor:pointer;
    }

    .charts-grid{ display:grid; grid-template-columns: 1fr; gap: 12px; margin-top: 10px; }
    .chart-card{
      background:#fff;
      border-radius: 14px;
      padding: 12px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.06);
    }
    .chart-title{
      display:flex;
      justify-content: space-between;
      align-items:center;
      gap: 10px;
      margin-bottom: 8px;
    }
    .chart-title b{ color:#222; }
    .chart-title span{ color:#666; font-weight: 850; font-size: .9em; }
    canvas.chart{
      width: 100%;
      height: 180px;
      display:block;
      border-radius: 12px;
      background: #fafafa;
    }

    .card-head{
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 6px;
    }
    .collapse-btn{
      display:inline-flex;
      align-items:center;
      gap: 8px;
      border:none;
      cursor:pointer;
      border-radius: 12px;
      padding: 10px 12px;
      font-weight: 1000;
      background: rgba(102,126,234,0.12);
      color:#3b4bd6;
    }
    .collapse-icon{
      width: 10px;
      height: 10px;
      border-right: 3px solid currentColor;
      border-bottom: 3px solid currentColor;
      transform: rotate(45deg);
      transition: transform .18s ease;
      margin-left: 2px;
    }
    .collapsed .collapse-icon{ transform: rotate(-45deg); }
    .collapsible{
      overflow: hidden;
      transition: max-height .22s ease, opacity .22s ease;
      max-height: 2500px;
      opacity: 1;
    }
    .collapsed .collapsible{
      max-height: 0px;
      opacity: 0;
      pointer-events: none;
    }

    footer{ margin-top: 14px; text-align:center; color:#666; font-weight: 850; font-size: 0.92em; }

    .pip-toggle{ display:none; margin-top: 10px; }
    @media (max-width: 980px) {
      .pip-toggle{ display:inline-block; }
      body.pip-on .sticky .card{
        position: fixed;
        left: 12px; right: 12px; bottom: 12px;
        z-index: 9999;
        padding: 10px;
        box-shadow: 0 18px 55px rgba(0,0,0,0.35);
        max-width: 520px;
        margin: 0 auto;
      }
      body.pip-on .container{ padding-bottom: 270px; }
    }
  </style>
</head>

<body>
<div class="container">
  <h1>üèÉ‚Äç‚ôÇÔ∏è Movement Kinetics Lab</h1>
  <p class="subtitle">Kalman-filtered kinematics ‚Ä¢ low-pass filtered kinetics ‚Ä¢ phase-based summary + recommendations (XLSX)</p>

  <div id="statusMessage" class="status-message"></div>

  <div class="layout">
    <div>
      <div class="card">
        <h3>Participant</h3>
        <div class="form-grid">
          <div><label>Name *</label><input id="participantName" placeholder="Enter name"></div>
          <div>
            <label>Sex *</label>
            <select id="participantSex"><option value="male">Male</option><option value="female">Female</option></select>
          </div>
          <div><label>Age *</label><input id="participantAge" type="number" value="25"></div>
          <div><label>Mass (kg) *</label><input id="participantMass" type="number" value="70"></div>
          <div><label>Height (cm) *</label><input id="participantHeight" type="number" value="175"></div>
        </div>
        <button class="btn btn-success" onclick="addParticipant(true)">Add / Update Participant</button>

        <div class="divider"></div>

        <div class="form-grid">
          <div>
            <label>Select Participant</label>
            <select id="selectedParticipant" onchange="onParticipantChange()"></select>
          </div>
          <div>
            <label>Motion Plane</label>
            <select id="motionPlane">
              <option value="sagittal" selected>Sagittal (side view)</option>
              <option value="frontal">Frontal (front view)</option>
            </select>
          </div>
        </div>

        <div class="divider"></div>

        <h3>Input Source</h3>
        <div class="form-grid">
          <div>
            <label>Source</label>
            <select id="inputSource">
              <option value="camera" selected>Live Camera</option>
              <option value="upload">Video Upload</option>
            </select>
          </div>
          <div>
            <label>FPS (Requested)</label>
            <select id="fpsSelection">
              <option value="30">30</option>
              <option value="60" selected>60</option>
              <option value="120">120 (best effort)</option>
              <option value="240">240 (best effort)</option>
            </select>
          </div>
          <div>
            <label>Camera</label>
            <select id="cameraFacing"><option value="environment">Back</option><option value="user">Front</option></select>
          </div>
          <div>
            <label>Kinetics low-pass cutoff (Hz)</label>
            <select id="cutoffHz">
              <option value="2">2</option>
              <option value="3">3</option>
              <option value="4">4</option>
              <option value="6" selected>6</option>
              <option value="10">10</option>
            </select>
          </div>
        </div>

        <div class="form-grid" style="margin-top:10px;">
          <div><label>Video File (Upload)</label><input id="videoUpload" type="file" accept="video/*"></div>
        </div>

        <button class="btn btn-primary" onclick="startInput()">Start (Camera / Upload)</button>
        <button class="btn btn-danger" onclick="stopInput()">Stop</button>
        <button class="btn btn-success" id="recordBtn" onclick="toggleRecording()" disabled>Start Recording</button>
        <button class="btn btn-ghost" onclick="snapshotPNG()" id="snapBtn" disabled>üì∏ Snapshot PNG</button>
        <button class="btn btn-primary pip-toggle" onclick="togglePiP()">üìå Pin Video (PiP)</button>

        <div class="divider"></div>

        <h3>Projectile Tracking</h3>
        <div class="form-grid">
          <div>
            <label>Mode</label>
            <select id="projMode"><option value="off" selected>Off</option><option value="coco">COCO-SSD Detect</option></select>
          </div>
          <div>
            <label>Class</label>
            <select id="projClassHint">
              <option value="sports ball" selected>Sports ball</option>
              <option value="frisbee">Frisbee</option>
              <option value="kite">Kite</option>
              <option value="bottle">Bottle</option>
              <option value="cup">Cup</option>
            </select>
          </div>
          <div>
            <label>Confidence</label>
            <select id="projMinScore">
              <option value="0.30">0.30</option>
              <option value="0.40" selected>0.40</option>
              <option value="0.50">0.50</option>
              <option value="0.60">0.60</option>
            </select>
          </div>
          <div>
            <label>Detect Rate</label>
            <select id="projEveryN">
              <option value="1">Every frame</option>
              <option value="2" selected>Every 2 frames</option>
              <option value="3">Every 3 frames</option>
              <option value="4">Every 4 frames</option>
            </select>
          </div>
        </div>

        <div class="divider"></div>

        <h3>Kinetics Driver</h3>
        <div class="form-grid">
          <div>
            <label>Driver Joint</label>
            <select id="kinJoint">
              <option value="hip">Hip</option>
              <option value="knee">Knee</option>
              <option value="shoulder">Shoulder</option>
              <option value="elbow">Elbow</option>
              <option value="wrist">Wrist (segment œâ)</option>
              <option value="ankle">Ankle (segment œâ)</option>
            </select>
          </div>
          <div>
            <label>Side</label>
            <select id="kinSide"><option value="R">Right</option><option value="L">Left</option></select>
          </div>
        </div>
        <p class="mini">
          Kinematics are Kalman-filtered. œâ in <b>[rad/s]</b>, angles exported in <b>[rad]</b>. Kinetics are low-pass filtered for visual clarity.
        </p>
      </div>

      <div class="card collapsible-card" id="displaySelectorCard" style="margin-top:12px;">
        <div class="card-head">
          <h3 style="margin:0;">Kinematics Selector</h3>
          <button class="collapse-btn" onclick="toggleCollapse('displaySelectorCard')">
            <span id="displaySelectorCard_lbl">Collapse</span><span class="collapse-icon"></span>
          </button>
        </div>
        <div class="collapsible">
          <div class="form-grid">
            <div>
              <label>Metric</label>
              <select id="metricType">
                <option value="angle">Angle [rad] (export)</option>
                <option value="angVel">Ang. Vel [rad/s]</option>
                <option value="linVel">Lin. Vel [m/s]</option>
              </select>
            </div>
            <div>
              <label>Joint / Segment</label>
              <select id="metricJoint">
                <option value="shoulder">Shoulder</option>
                <option value="elbow">Elbow</option>
                <option value="wrist">Wrist (segment)</option>
                <option value="hip">Hip</option>
                <option value="knee">Knee</option>
                <option value="ankle">Ankle (segment)</option>
              </select>
            </div>
            <div>
              <label>Side</label>
              <select id="metricSide"><option value="R">Right</option><option value="L">Left</option></select>
            </div>
          </div>
          <button class="btn btn-primary" onclick="addMetric()">Add</button>
          <button class="btn btn-danger" onclick="clearMetrics()">Clear</button>
          <div class="chiplist" id="metricChips"></div>

          <div class="divider"></div>
          <div class="metrics-grid" id="selectedMetricsPanel"></div>

          <div class="divider"></div>
          <div class="metric">
            <div class="t">Live overview (filtered)</div>
            <div class="s" id="liveInterpretation">‚Äî</div>
          </div>
        </div>
      </div>

      <div class="card" style="margin-top:12px;">
        <h3>Charts</h3>
        <div class="charts-grid">
          <div class="chart-card">
            <div class="chart-title">
              <b>Kinetics: Force‚ÄìTime [N] + Moment‚ÄìTime [Nm]</b>
              <span id="lblKinetics">F: 0 N | M: 0 Nm</span>
            </div>
            <canvas id="chartDual" class="chart"></canvas>
          </div>
        </div>
        <p class="mini">
          This chart shows the whole session window (rolling) and is low-pass filtered (cascaded) for smoothness.
        </p>
      </div>

      <div class="card" style="margin-top:12px;">
        <button class="btn btn-primary" onclick="downloadData()">üìä Download XLSX (Profile ‚Ä¢ Phase Summary + Recommendations ‚Ä¢ TimeSeries)</button>
      </div>
    </div>

    <div class="sticky" id="stickyVideo">
      <div class="card">
        <h3>Live View</h3>
        <div class="video-wrap">
          <video id="video" playsinline muted></video>
          <canvas id="overlay"></canvas>
          <div class="hud">
            <div id="fpsIndicator">FPS: 0</div>
            <small id="statusText">Ready</small>
            <small id="sourceText">Source: ‚Äî</small>
          </div>
        </div>
        <p class="mini">
          For stable kinematics: keep joints visible, avoid motion blur, use higher FPS and good lighting.
        </p>
      </div>
    </div>
  </div>

  <footer>¬© 2025 Ng Jun Wei. All rights reserved.</footer>
</div>

<script>
/* =========================
   Globals
========================= */
let detector=null, cocoModel=null;
let video=null, overlay=null, ctx=null;
let streamRef=null, animationId=null;

let participants=[], currentParticipant=null;
let isRecording=false;

let prevKeypoints=null;
let frameIndex=0;

let detectedFPS=0, framesInSecond=0;
let lastFPSUpdate=performance.now();

let selectedMetrics=[];
let lastProjectiles=[];
let prevProjState=null;

const FILTER_ORDER = 4;
let forceStages = new Array(FILTER_ORDER).fill(0);
let momentStages = new Array(FILTER_ORDER).fill(0);

// rolling chart buffers (keep last N seconds)
const rolling = {
  t: [],
  force: [],
  moment: []
};

let chartLastDraw=0;

const KP = {
  shoulder_L:5, shoulder_R:6, elbow_L:7, elbow_R:8, wrist_L:9, wrist_R:10,
  hip_L:11, hip_R:12, knee_L:13, knee_R:14, ankle_L:15, ankle_R:16
};

const SEG_MASS = { thigh:0.10, shank:0.0465, foot:0.0145, upperArm:0.028, forearm:0.016, hand:0.006, trunk:0.50 };
const SEG_K    = { thigh:0.323, shank:0.302, foot:0.475, upperArm:0.322, forearm:0.303, hand:0.628 };

// per-signal Kalman filter cache
const kf = new Map(); // key -> {x, P, Q, R, inited}

/* =========================
   Recording store
========================= */
let rec = resetRec();
let sessionMeta = {};

function resetRec(){
  return {
    fpsUsed: 60,
    n: 0,
    driver: "",
    plane: "sagittal",
    t: [],
    forceN: [],
    momentNm: [],
    driver_linVel: [],
    driver_angVel: [],
    driver_angle: [],
    driver_disp: [],
    proj_speed: [],
    metricsDefs: [],
    metrics: {} // id -> array
  };
}

/* =========================
   Init
========================= */
window.onload = async () => {
  video=document.getElementById('video');
  overlay=document.getElementById('overlay');
  ctx=overlay.getContext('2d');

  document.getElementById('participantName').value="Athlete 1";
  addParticipant(false);

  showStatus("Loading Neural Networks...", "info");
  try{
    await tf.ready();
    try { await tf.setBackend('webgl'); await tf.ready(); } catch(_) {}

    detector = await poseDetection.createDetector(
      poseDetection.SupportedModels.MoveNet,
      { modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING }
    );
    cocoModel = await cocoSsd.load();

    showStatus("Models Ready. Start Camera or Upload.", "success");
    setStatusText("Models ready");
  }catch(e){
    console.error(e);
    showStatus("Error loading models. Try reloading.", "error");
    setStatusText("Model load error");
  }
};

/* =========================
   Participant
========================= */
function addParticipant(showToast=true){
  const name=(document.getElementById('participantName').value||"").trim();
  const sex=document.getElementById('participantSex').value;
  const age=parseInt(document.getElementById('participantAge').value||"0");
  const mass=parseFloat(document.getElementById('participantMass').value||"0");
  const height=parseFloat(document.getElementById('participantHeight').value||"0");
  if(!name||!mass||!height||!age){ if(showToast) showStatus("Fill Name, Age, Mass, Height.", "error"); return; }

  const existing=participants.find(p=>p.name===name);
  const profile={name,sex,age,mass,height};
  if(existing) Object.assign(existing, profile);
  else participants.push(profile);

  const sel=document.getElementById('selectedParticipant');
  sel.innerHTML="";
  participants.forEach(p=>{
    const opt=document.createElement('option');
    opt.value=p.name; opt.textContent=p.name;
    sel.appendChild(opt);
  });
  sel.value=name;
  currentParticipant=profile;
  if(showToast) showStatus(`Participant set: ${name}`, "success");
}
function onParticipantChange(){
  const sel=document.getElementById('selectedParticipant');
  const p=participants.find(x=>x.name===sel.value);
  if(p) currentParticipant=p;
}

/* =========================
   Input
========================= */
async function startInput(){
  if(!detector) return showStatus("Wait for models to load.", "error");
  stopActive();
  resetSessionState();

  const src=document.getElementById('inputSource').value;
  const fpsReq=parseInt(document.getElementById('fpsSelection').value);
  const facing=document.getElementById('cameraFacing').value;

  sessionMeta={ source:src, fpsRequested:fpsReq, facing, startedAt:new Date().toISOString() };

  if(src==="camera") await startCameraInternal(fpsReq, facing);
  else await startUploadInternal();
}
async function startCameraInternal(fpsReq, facing){
  setStatusText("Starting camera...");
  setSourceText(`Source: Camera (${facing}, req ${fpsReq}fps)`);

  const constraints={
    video:{
      facingMode:facing,
      width:{ideal:1280},
      height:{ideal:720},
      frameRate:{ideal:fpsReq, max:fpsReq}
    },
    audio:false
  };

  try{
    streamRef=await navigator.mediaDevices.getUserMedia(constraints);
    video.srcObject=streamRef;
    video.onloadedmetadata=async()=>{
      await video.play();
      overlay.width=video.videoWidth||1280;
      overlay.height=video.videoHeight||720;

      if(facing==='user'){ video.style.transform="scaleX(-1)"; overlay.style.transform="scaleX(-1)"; }
      else { video.style.transform="none"; overlay.style.transform="none"; }

      enableRunButtons(true);
      setStatusText("Running");
      animationId=requestAnimationFrame(renderLoop);
      showStatus("Camera Active", "success");
    };
  }catch(err){
    console.error(err);
    showStatus("Camera Error: "+err.message, "error");
    setStatusText("Camera error");
  }
}
async function startUploadInternal(){
  const fileInput=document.getElementById('videoUpload');
  if(!fileInput.files.length) return showStatus("Select a video file first.", "error");
  const file=fileInput.files[0];
  const url=URL.createObjectURL(file);

  setStatusText("Loading video...");
  setSourceText(`Source: Upload (${file.name})`);

  video.srcObject=null;
  video.src=url;
  video.loop=true;
  video.muted=true;
  video.playsInline=true;

  video.onloadedmetadata=async()=>{
    try{
      await video.play();
      overlay.width=video.videoWidth||1280;
      overlay.height=video.videoHeight||720;

      video.style.transform="none";
      overlay.style.transform="none";

      enableRunButtons(true);
      setStatusText("Running");
      animationId=requestAnimationFrame(renderLoop);
      showStatus("Playing Upload", "success");
    }catch(e){
      console.error(e);
      showStatus("Upload playback error: "+e.message, "error");
      setStatusText("Upload error");
    }
  };
}
function stopInput(){
  stopActive();
  enableRunButtons(false);
  showStatus("Stopped", "info");
  setStatusText("Stopped");
  setSourceText("Source: ‚Äî");
}
function stopActive(){
  if(animationId) cancelAnimationFrame(animationId);
  animationId=null;

  if(streamRef){ try{ streamRef.getTracks().forEach(t=>t.stop()); }catch(_){} }
  streamRef=null;

  try{ video.pause(); }catch(_){}
  video.srcObject=null;

  if(ctx) ctx.clearRect(0,0,overlay.width,overlay.height);
}
function enableRunButtons(running){
  document.getElementById('recordBtn').disabled=!running;
  document.getElementById('snapBtn').disabled=!running;
}
function resetSessionState(){
  isRecording=false;
  rec=resetRec();

  prevKeypoints=null;
  frameIndex=0;

  prevProjState=null;
  lastProjectiles=[];

  forceStages=new Array(FILTER_ORDER).fill(0);
  momentStages=new Array(FILTER_ORDER).fill(0);

  kf.clear();

  rolling.t=[]; rolling.force=[]; rolling.moment=[];

  document.getElementById('lblKinetics').innerText="F: 0 N | M: 0 Nm";
  document.getElementById('liveInterpretation').innerText="‚Äî";
}

/* =========================
   Kalman filter (1D)
   - simple random-walk model x_k = x_{k-1} + w
========================= */
function kalman1D(key, z, Q, R){
  if(!isFinite(z)) return 0;
  let s = kf.get(key);
  if(!s){
    s = { x: z, P: 1, Q: Q, R: R, inited: true };
    kf.set(key, s);
    return s.x;
  }
  // predict
  s.P = s.P + s.Q;
  // update
  const K = s.P / (s.P + s.R);
  s.x = s.x + K * (z - s.x);
  s.P = (1 - K) * s.P;
  return s.x;
}
function kalmanParamsFor(type){
  // tuned defaults (light smoothing but stable for iPhone video)
  // Increase R for noisier signals, increase Q to follow rapid motion more.
  if(type==="angle")  return {Q: 1e-3, R: 5e-3};      // rad
  if(type==="angVel") return {Q: 5e-2, R: 2e-1};      // rad/s
  if(type==="linVel") return {Q: 2e-2, R: 1e-1};      // m/s
  if(type==="proj")   return {Q: 3e-2, R: 1.5e-1};    // m/s
  if(type==="force")  return {Q: 20,   R: 200};       // N (not used; kinetics uses low-pass)
  return {Q: 1e-3, R: 1e-2};
}

/* =========================
   Main loop
========================= */
async function renderLoop(){
  animationId=requestAnimationFrame(renderLoop);
  if(!video||video.paused||video.ended) return;

  framesInSecond++;
  const nowPerf=performance.now();
  if(nowPerf-lastFPSUpdate>=1000){
    detectedFPS=framesInSecond;
    framesInSecond=0;
    lastFPSUpdate=nowPerf;
    document.getElementById('fpsIndicator').innerText="FPS: "+detectedFPS;
  }

  frameIndex++;

  let kp=null;
  try{
    const poses=await detector.estimatePoses(video,{flipHorizontal:false});
    if(poses&&poses.length&&poses[0].keypoints) kp=poses[0].keypoints;
  }catch(_){}

  // projectile
  const projMode=document.getElementById('projMode').value;
  if(projMode==="coco" && cocoModel){
    const everyN=parseInt(document.getElementById('projEveryN').value);
    if(frameIndex%everyN===0){
      try{
        const preds=await cocoModel.detect(video);
        const cls=document.getElementById('projClassHint').value;
        const minScore=parseFloat(document.getElementById('projMinScore').value);
        lastProjectiles=preds.filter(p => p.class===cls && p.score>=minScore).sort((a,b)=>b.score-a.score).slice(0,1);
      }catch(_){}
    }
  }else lastProjectiles=[];

  // draw
  ctx.clearRect(0,0,overlay.width,overlay.height);
  if(kp) drawSkeleton(kp);
  drawProjectile(lastProjectiles);

  if(kp){
    const plane=document.getElementById('motionPlane').value;

    const proj = computeProjectileSpeed(lastProjectiles);
    const kin  = computeDriverKinematics(kp, plane);
    const kinets = computeDriverKinetics(kin);

    processSelectedMetrics(kp, plane);

    document.getElementById('lblKinetics').innerText =
      `F: ${(kinets.forceN||0).toFixed(0)} N | M: ${(kinets.momentNm||0).toFixed(6)} Nm`;

    const liveText = [
      `Plane: ${plane}`,
      `Driver: ${kin.driver}`,
      `v [m/s]: ${kin.linVel.toFixed(3)} | œâ [rad/s]: ${kin.angVel.toFixed(3)} | Œ∏ [rad]: ${kin.angleRad.toFixed(3)} | disp [m]: ${kin.disp.toFixed(3)}`,
      `Projectile speed [m/s]: ${proj.speed.toFixed(3)}`
    ].join("\n");
    document.getElementById('liveInterpretation').innerText = liveText;

    pushRollingKinetics(kinets, kin.fpsUsed);

    if(isRecording){
      recordSample(kin, kinets, proj, plane);
    }

    prevKeypoints=kp;
    setStatusText(isRecording ? "Recording..." : "Running");
  } else {
    setStatusText("No pose detected");
  }

  drawChartsThrottled();
}

/* =========================
   Drawing
========================= */
function drawSkeleton(kp){
  const minScore=0.30;
  ctx.lineWidth=3;
  ctx.strokeStyle="#00ff66";

  const skeleton=[
    [KP.shoulder_L, KP.shoulder_R],
    [KP.shoulder_L, KP.elbow_L], [KP.elbow_L, KP.wrist_L],
    [KP.shoulder_R, KP.elbow_R], [KP.elbow_R, KP.wrist_R],
    [KP.shoulder_L, KP.hip_L], [KP.shoulder_R, KP.hip_R],
    [KP.hip_L, KP.hip_R],
    [KP.hip_L, KP.knee_L], [KP.knee_L, KP.ankle_L],
    [KP.hip_R, KP.knee_R], [KP.knee_R, KP.ankle_R]
  ];

  skeleton.forEach(([i,j])=>{
    if(kp[i]?.score>minScore && kp[j]?.score>minScore){
      ctx.beginPath(); ctx.moveTo(kp[i].x,kp[i].y); ctx.lineTo(kp[j].x,kp[j].y); ctx.stroke();
    }
  });

  kp.forEach(p=>{
    if(p.score>minScore){
      ctx.beginPath(); ctx.arc(p.x,p.y,5,0,2*Math.PI);
      ctx.fillStyle="red"; ctx.fill();
    }
  });
}
function drawProjectile(projs){
  if(!projs||!projs.length) return;
  ctx.save();
  ctx.lineWidth=2;
  ctx.strokeStyle="orange";
  ctx.fillStyle="orange";
  ctx.font="14px system-ui, -apple-system, Segoe UI, Roboto, Arial";
  projs.forEach(p=>{
    const [x,y,w,h]=p.bbox;
    ctx.strokeRect(x,y,w,h);
    ctx.fillText(`${p.class} ${(p.score*100).toFixed(0)}%`, x, y>18?y-6:y+18);
  });
  ctx.restore();
}

/* =========================
   Helpers
========================= */
function getPxToMeter(){
  const hM=currentParticipant?(currentParticipant.height/100):1.75;
  const denom=Math.max(240, overlay.height*0.80);
  return hM/denom;
}
function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }
function round(x,dp){ if(!isFinite(x)) return 0; const p=Math.pow(10,dp); return Math.round(x*p)/p; }
function mean(arr){ if(!arr || !arr.length) return 0; return arr.reduce((s,x)=>s+(+x||0),0)/arr.length; }
function maxAbs(arr){ if(!arr || !arr.length) return 0; let m=0; arr.forEach(x=>{ const a=Math.abs(+x||0); if(a>m) m=a; }); return m; }
function lowPass(prev, curr, dt, fc){
  const rc = 1.0 / (2 * Math.PI * fc);
  const alpha = dt / (rc + dt);
  return prev + alpha * (curr - prev);
}
function cascadedLowPass(x, stages, dt, fc){
  let y=x;
  for(let i=0;i<stages.length;i++){
    stages[i]=lowPass(stages[i], y, dt, fc);
    y=stages[i];
  }
  return y;
}
function idxOf(joint, side){
  const k = `${joint}_${side}`;
  return KP[k] ?? null;
}
function unwrapAngleRad(curr, prev){
  let d = curr - prev;
  if(d > Math.PI) curr -= 2*Math.PI;
  if(d < -Math.PI) curr += 2*Math.PI;
  return curr;
}

/* =========================
   Angles / œâ (with Kalman)
========================= */
const angleState = new Map(); // key -> {prevRad, prevFiltRad}

function getJointAngleRad(kp, joint, side){
  const minScore=0.30;
  let a=null,b=null,c=null;

  if(joint==="elbow"){ a=idxOf("shoulder",side); b=idxOf("elbow",side); c=idxOf("wrist",side); }
  else if(joint==="knee"){ a=idxOf("hip",side); b=idxOf("knee",side); c=idxOf("ankle",side); }
  else if(joint==="hip"){ a=idxOf("shoulder",side); b=idxOf("hip",side); c=idxOf("knee",side); }
  else if(joint==="shoulder"){ a=idxOf("hip",side); b=idxOf("shoulder",side); c=idxOf("elbow",side); }
  else return NaN;

  const pA=kp[a], pB=kp[b], pC=kp[c];
  if(!pA||!pB||!pC) return NaN;
  if(pA.score<minScore||pB.score<minScore||pC.score<minScore) return NaN;

  const rad =
    Math.atan2(pC.y - pB.y, pC.x - pB.x) -
    Math.atan2(pA.y - pB.y, pA.x - pB.x);

  let ang = Math.abs(rad);
  if(ang > Math.PI) ang = 2*Math.PI - ang;
  return ang;
}

function getSegmentOrientationRad(kp, seg, side){
  const minScore=0.30;
  let a=null,b=null;
  if(seg==="forearm"){ a=idxOf("elbow",side); b=idxOf("wrist",side); }
  else if(seg==="shank"){ a=idxOf("knee",side); b=idxOf("ankle",side); }
  else return NaN;

  const pA=kp[a], pB=kp[b];
  if(!pA||!pB) return NaN;
  if(pA.score<minScore||pB.score<minScore) return NaN;

  return Math.atan2(pB.y - pA.y, pB.x - pA.x); // [-pi, pi]
}

function getFilteredAngleAndOmega(key, rawRad, dt){
  if(!isFinite(rawRad) || dt<=0) return {angleFilt:0, omegaFilt:0};

  const st = angleState.get(key) || {prevRad: rawRad, prevFiltRad: rawRad};

  // unwrap raw against previous raw
  const rawUnwrapped = unwrapAngleRad(rawRad, st.prevRad);

  // Kalman filter angle (rad)
  const {Q:Qa, R:Ra} = kalmanParamsFor("angle");
  const angleFilt = kalman1D(`kal_angle_${key}`, rawUnwrapped, Qa, Ra);

  // omega from filtered angle
  const omegaRaw = (angleFilt - st.prevFiltRad) / Math.max(1e-4, dt);

  // Kalman filter omega (rad/s)
  const {Q:Qw, R:Rw} = kalmanParamsFor("angVel");
  const omegaFilt = kalman1D(`kal_omega_${key}`, omegaRaw, Qw, Rw);

  st.prevRad = rawUnwrapped;
  st.prevFiltRad = angleFilt;
  angleState.set(key, st);

  return {angleFilt, omegaFilt};
}

function getLinearVelMpsRaw(kp, joint, side, dt){
  if(!prevKeypoints) return 0;
  const idx=idxOf(joint, side);
  if(idx==null) return 0;
  const curr=kp[idx], prev=prevKeypoints[idx];
  if(!curr||!prev||curr.score<0.30||prev.score<0.30) return 0;
  const s=getPxToMeter();
  const dx=(curr.x-prev.x)*s;
  const dy=(curr.y-prev.y)*s;
  return Math.hypot(dx,dy)/Math.max(1e-4, dt);
}

/* =========================
   Projectile speed (Kalman)
========================= */
function computeProjectileSpeed(projs){
  const out={speed:0, speedRaw:0};
  if(!projs||!projs.length){ prevProjState=null; return out; }

  const [x,y,w,h]=projs[0].bbox;
  const cx=x+w/2, cy=y+h/2;
  const s=getPxToMeter();
  const xM=cx*s, yM=cy*s;

  const fps = Math.max(1, detectedFPS || parseInt(document.getElementById("fpsSelection").value) || 60);
  const dt=1/fps;

  let sp=0;
  if(prevProjState){
    const vx=(xM-prevProjState.x)/dt;
    const vy=(yM-prevProjState.y)/dt;
    sp=Math.hypot(vx,vy);
  }
  prevProjState={x:xM,y:yM};
  out.speedRaw=sp;

  const {Q,R} = kalmanParamsFor("proj");
  out.speed = kalman1D("kal_proj_speed", sp, Q, R);
  return out;
}

/* =========================
   Driver kinematics (Kalman)
========================= */
let driverDisp=0;
let prevDriverXY=null;

function computeDriverKinematics(kp, plane){
  const jName=document.getElementById("kinJoint").value;
  const side=document.getElementById("kinSide").value;

  const fpsUsed = Math.max(1, detectedFPS || parseInt(document.getElementById("fpsSelection").value) || 60);
  const dt = 1/fpsUsed;

  let angleRadRaw=0;
  let angleKey=`driver_${jName}_${side}`;

  if(jName==="wrist"){
    const ori = getSegmentOrientationRad(kp, "forearm", side);
    angleRadRaw = isFinite(ori) ? ori : 0;
    angleKey=`driver_seg_forearm_${side}`;
  } else if(jName==="ankle"){
    const ori = getSegmentOrientationRad(kp, "shank", side);
    angleRadRaw = isFinite(ori) ? ori : 0;
    angleKey=`driver_seg_shank_${side}`;
  } else {
    const ang = getJointAngleRad(kp, jName, side);
    angleRadRaw = isFinite(ang) ? ang : 0;
    angleKey=`driver_joint_${jName}_${side}`;
  }

  const {angleFilt, omegaFilt} = getFilteredAngleAndOmega(angleKey, angleRadRaw, dt);

  const baseJoint = (jName==="wrist") ? "wrist" : (jName==="ankle" ? "ankle" : jName);
  const linRaw = getLinearVelMpsRaw(kp, baseJoint, side, dt);
  const {Q:Qv,R:Rv} = kalmanParamsFor("linVel");
  const linVel = kalman1D(`kal_driver_lin_${baseJoint}_${side}`, linRaw, Qv, Rv);

  // displacement: integrate filtered speed (stable, phase-friendly)
  driverDisp += Math.abs(linVel) * dt;

  // also keep a geometry-based disp (optional). We'll not double count; keep integration only.
  const idx = idxOf(baseJoint, side);
  const p = idx!=null ? kp[idx] : null;
  if(p && p.score>0.30){
    prevDriverXY={x:p.x,y:p.y};
  }

  return {
    driver: `${jName}_${side}`,
    linVel,
    linVelRaw: linRaw,
    angleRad: angleFilt,
    angleRadRaw,
    angVel: omegaFilt,
    disp: driverDisp,
    fpsUsed,
    plane
  };
}

/* =========================
   Driver kinetics (low-pass)
========================= */
function computeDriverKinetics(kin){
  if(!currentParticipant || !kin) return {forceN:0, momentNm:0};

  const hz=parseFloat(document.getElementById("cutoffHz").value);
  const dt=1/Math.max(1, kin.fpsUsed);

  const driverJoint = kin.driver.split("_")[0];

  let seg="thigh";
  if(driverJoint==="knee") seg="shank";
  if(driverJoint==="ankle") seg="foot";
  if(driverJoint==="shoulder") seg="upperArm";
  if(driverJoint==="elbow") seg="forearm";
  if(driverJoint==="wrist") seg="hand";

  const segMass = currentParticipant.mass * (SEG_MASS[seg] || 0.10);

  // use filtered linVel to compute accel (more stable)
  const prevV = rec.driver_linVel.length ? rec.driver_linVel[rec.driver_linVel.length-1] : kin.linVel;
  const accel = Math.abs(kin.linVel - prevV) / Math.max(1e-4, dt);
  const forceRaw = segMass * accel;

  // use filtered angVel to compute alpha
  const prevW = rec.driver_angVel.length ? rec.driver_angVel[rec.driver_angVel.length-1] : kin.angVel;
  const alpha = (kin.angVel - prevW) / Math.max(1e-4, dt);

  const L = estimateSegmentLengthM(seg);
  const k = SEG_K[seg] || 0.30;
  const I = segMass * Math.pow(k * L, 2);
  const momentRaw = I * alpha;

  const forceN = cascadedLowPass(forceRaw, forceStages, dt, hz);
  const momentNm = cascadedLowPass(momentRaw, momentStages, dt, hz);

  return { forceN, momentNm };
}
function estimateSegmentLengthM(seg){
  const h = currentParticipant ? (currentParticipant.height/100) : 1.75;
  const frac = { thigh:0.245, shank:0.246, foot:0.152, upperArm:0.186, forearm:0.146, hand:0.108, trunk:0.288 };
  return h * (frac[seg] || 0.20);
}

/* =========================
   Selected metrics (Kalman)
========================= */
function processSelectedMetrics(kp, plane){
  selectedMetrics.forEach(m=>{
    const v = computeMetricValueFiltered(kp, m);
    const el=document.getElementById(`val_${m.id}`);
    if(el) el.innerText = isFinite(v) ? v.toFixed(3) : "--";
  });
}

function computeMetricValueFiltered(kp, m){
  const side=m.side;

  const fpsUsed = Math.max(1, detectedFPS || parseInt(document.getElementById("fpsSelection").value) || 60);
  const dt = 1/fpsUsed;

  if(m.type==="linVel"){
    const baseJoint = (m.joint==="wrist") ? "wrist" : (m.joint==="ankle" ? "ankle" : m.joint);
    const raw = getLinearVelMpsRaw(kp, baseJoint, side, dt);
    const {Q,R} = kalmanParamsFor("linVel");
    return kalman1D(`kal_m_lin_${baseJoint}_${side}`, raw, Q, R);
  }

  if(m.type==="angle" || m.type==="angVel"){
    let rawRad=0;
    let key=`m_${m.joint}_${side}`;
    if(m.joint==="wrist"){
      const ori=getSegmentOrientationRad(kp,"forearm",side);
      rawRad=isFinite(ori)?ori:0;
      key=`m_seg_forearm_${side}`;
    } else if(m.joint==="ankle"){
      const ori=getSegmentOrientationRad(kp,"shank",side);
      rawRad=isFinite(ori)?ori:0;
      key=`m_seg_shank_${side}`;
    } else {
      const ang=getJointAngleRad(kp,m.joint,side);
      rawRad=isFinite(ang)?ang:0;
      key=`m_joint_${m.joint}_${side}`;
    }

    const {angleFilt, omegaFilt} = getFilteredAngleAndOmega(key, rawRad, dt);
    if(m.type==="angle") return angleFilt;    // radians live + export
    return omegaFilt;                         // rad/s
  }

  return 0;
}

/* =========================
   Rolling kinetics buffers + chart
========================= */
function pushRollingKinetics(kinets, fpsUsed){
  const dt=1/Math.max(1, fpsUsed);
  const t = rolling.t.length ? rolling.t[rolling.t.length-1] + dt : 0;
  rolling.t.push(t);
  rolling.force.push(kinets.forceN||0);
  rolling.moment.push(kinets.momentNm||0);

  // keep last 20 seconds always for visibility
  const WIN=20;
  while(rolling.t.length && rolling.t[0] < t - WIN){
    rolling.t.shift(); rolling.force.shift(); rolling.moment.shift();
  }
}
function drawChartsThrottled(){
  const now=performance.now()/1000;
  if(now-chartLastDraw < 0.10) return;
  chartLastDraw=now;
  drawDualAxisChart("chartDual", rolling.t, rolling.force, rolling.moment);
}
function drawDualAxisChart(canvasId, tArr, fArr, mArr){
  const c=document.getElementById(canvasId);
  const g=c.getContext("2d");
  const w=c.width=c.clientWidth;
  const h=c.height=c.clientHeight;

  g.clearRect(0,0,w,h);
  g.strokeStyle="#eee";
  g.beginPath(); g.moveTo(0,h/2); g.lineTo(w,h/2); g.stroke();

  if(tArr.length<2) return;
  const tMin=tArr[0], tMax=tArr[tArr.length-1];
  const fMax=Math.max(1, maxAbs(fArr));
  const mMax=Math.max(1e-6, maxAbs(mArr));

  // Force
  g.strokeStyle="#667eea"; g.lineWidth=2; g.beginPath();
  for(let i=0;i<tArr.length;i++){
    const x=((tArr[i]-tMin)/(tMax-tMin))*w;
    const y=h-((fArr[i]/(fMax*1.2))*(h/2)+h/2);
    if(i===0) g.moveTo(x,y); else g.lineTo(x,y);
  }
  g.stroke();

  // Moment
  g.strokeStyle="#ef4444"; g.lineWidth=2; g.beginPath();
  for(let i=0;i<tArr.length;i++){
    const x=((tArr[i]-tMin)/(tMax-tMin))*w;
    const y=h-((mArr[i]/(mMax*1.2))*(h/2)+h/2);
    if(i===0) g.moveTo(x,y); else g.lineTo(x,y);
  }
  g.stroke();

  g.fillStyle="#666";
  g.font="12px system-ui";
  g.fillText("Force [N] (blue)", 10, 14);
  const txt="Moment [Nm] (red)";
  g.fillText(txt, w - g.measureText(txt).width - 10, 14);
}

/* =========================
   Recording
========================= */
function toggleRecording(){
  const btn=document.getElementById("recordBtn");
  if(!isRecording){
    if(!currentParticipant) return showStatus("Set a participant first.", "error");

    isRecording=true;
    rec=resetRec();
    rec.fpsUsed = Math.max(1, detectedFPS || parseInt(document.getElementById("fpsSelection").value) || 60);
    rec.driver = `${document.getElementById("kinJoint").value}_${document.getElementById("kinSide").value}`;
    rec.plane = document.getElementById("motionPlane").value;

    rec.metricsDefs = selectedMetrics.map(m=>({ ...m, units: unitsFor(m) }));
    rec.metrics = {};
    rec.metricsDefs.forEach(m=> rec.metrics[m.id]=[]);

    // reset states
    angleState.clear();
    driverDisp=0;
    prevDriverXY=null;
    prevProjState=null;
    forceStages=new Array(FILTER_ORDER).fill(0);
    momentStages=new Array(FILTER_ORDER).fill(0);
    kf.clear();

    btn.textContent="Stop Recording";
    btn.className="btn btn-danger";
    showStatus("Recording started...", "info");
    setStatusText("Recording...");
  } else {
    isRecording=false;
    btn.textContent="Start Recording";
    btn.className="btn btn-success";
    showStatus(`Recording saved. ${rec.n} samples.`, "success");
    setStatusText("Running");
  }
}

function recordSample(kin, kinets, proj, plane){
  const i = rec.n;
  const t = i / rec.fpsUsed;

  rec.t.push(t);
  rec.forceN.push(kinets.forceN||0);
  rec.momentNm.push(kinets.momentNm||0);

  rec.driver_linVel.push(kin.linVel||0);
  rec.driver_angVel.push(kin.angVel||0);
  rec.driver_angle.push(kin.angleRad||0);
  rec.driver_disp.push(kin.disp||0);

  rec.proj_speed.push(proj.speed||0);

  // selected metrics (already Kalman-filtered)
  rec.metricsDefs.forEach(def=>{
    const v = computeMetricValueFiltered(prevKeypoints||[], def);
    rec.metrics[def.id].push(isFinite(v)?v:0);
  });

  rec.n++;
}

/* =========================
   Phase segmentation (event-based)
   - markers: peak projectile speed & peak driver œâ
========================= */
function segmentPhases(){
  const n=rec.n;
  if(n<10) return [{name:"Full", i0:0, i1:n-1, markers:"‚Äî"}];

  const peakProjIdx = argMax(rec.proj_speed);
  const peakWIdx = argMaxAbs(rec.driver_angVel);

  // small windows around events
  const w1 = Math.max(3, Math.floor(n*0.12));
  const w2 = Math.max(3, Math.floor(n*0.10));

  const accel0 = clampInt(Math.min(peakWIdx, peakProjIdx) - w1, 0, n-1);
  const accel1 = clampInt(Math.min(peakWIdx, peakProjIdx) + w1, 0, n-1);

  const release0 = clampInt(peakProjIdx - w2, 0, n-1);
  const release1 = clampInt(peakProjIdx + w2, 0, n-1);

  return [
    {name:"Preparation", i0:0, i1:Math.max(0, accel0-1), markers:`peakœâ@${peakWIdx}, peakVproj@${peakProjIdx}`},
    {name:"Acceleration", i0:accel0, i1:accel1, markers:`peakœâ@${peakWIdx}, peakVproj@${peakProjIdx}`},
    {name:"Release/Contact", i0:release0, i1:release1, markers:`peakVproj@${peakProjIdx}`},
    {name:"Follow-through", i0:Math.min(n-1, release1+1), i1:n-1, markers:`‚Äî`},
  ];
}
function clampInt(x,a,b){ return Math.max(a, Math.min(b, Math.round(x))); }
function argMax(arr){
  let best=0, bestV=-1;
  for(let i=0;i<(arr||[]).length;i++){
    const v=+arr[i]||0;
    if(v>bestV){ bestV=v; best=i; }
  }
  return best;
}
function argMaxAbs(arr){
  let best=0, bestV=-1;
  for(let i=0;i<(arr||[]).length;i++){
    const v=Math.abs(+arr[i]||0);
    if(v>bestV){ bestV=v; best=i; }
  }
  return best;
}
function slice(arr, ph){
  if(!arr||!arr.length) return [];
  return arr.slice(ph.i0, ph.i1+1);
}

/* =========================
   Recommendations (phase summary)
   - simple heuristics based on relative ratios & timing
========================= */
function buildPhaseRecommendation(phaseName, stats, global){
  // stats: {peakProj, peakW, avgW, peakAngle, avgAngle, peakV, avgV, peakF, avgF, peakM, avgM}
  // global: {peakProjIdx, peakWIdx, n, fps, plane}
  const recs=[];
  const flags=[];

  // timing (sequencing)
  const tProj = global.peakProjIdx / global.fps;
  const tW = global.peakWIdx / global.fps;
  const dt = tProj - tW;

  // efficiency ratios
  const wToProj = (stats.peakW > 1e-6) ? (stats.peakProj / stats.peakW) : 0; // higher means better transfer per œâ
  const forceToProj = (stats.peakF > 1e-6) ? (stats.peakProj / stats.peakF) : 0;

  // thresholds (generic; adjust later if you want sport-specific)
  const LOW_ANG = 0.6;      // rad (about 34 deg)
  const HIGH_MOM = 0.06;    // Nm proxy scale can be small; use relative checks too
  const LOW_W = 2.0;        // rad/s
  const LOW_PROJ = 2.0;     // m/s
  const BIG_SEQ = 0.08;     // s

  // phase-specific logic
  if(phaseName==="Preparation"){
    if(stats.peakAngle < LOW_ANG){
      flags.push("Low ROM");
      recs.push("Increase range-of-motion during wind-up (greater hip/shoulder separation and smoother loading).");
    }
    if(stats.avgW > stats.peakW*0.85 && stats.peakW>0){
      flags.push("Early high œâ");
      recs.push("Avoid spinning up too early; keep a controlled load then accelerate later.");
    }
  }

  if(phaseName==="Acceleration"){
    if(stats.peakW < LOW_W && stats.peakProj > LOW_PROJ){
      flags.push("Push-like transfer");
      recs.push("Projectile speed relies more on translation than rotation. Train rotational sequencing (proximal-to-distal) and faster segment œâ.");
    }
    if(stats.peakW >= LOW_W && stats.peakProj < LOW_PROJ){
      flags.push("Throw-like but low release speed");
      recs.push("Good rotational intent but poor transfer to projectile. Check timing, stiffness, and release mechanics.");
    }
    if(Math.abs(dt) > BIG_SEQ){
      flags.push("Sequencing offset");
      if(dt > 0){
        recs.push("Peak projectile speed occurs after peak œâ: consider maintaining angular acceleration closer to release (later peak œâ).");
      } else {
        recs.push("Peak projectile speed occurs before peak œâ: avoid 'late whip' without transfer; aim for earlier transfer to projectile.");
      }
    }
    if(wToProj < 0.6 && stats.peakW>LOW_W){
      flags.push("Energy leak");
      recs.push("High œâ but limited projectile speed gain. Consider trunk control, scapular stability, and a cleaner kinetic chain.");
    }
  }

  if(phaseName==="Release/Contact"){
    if(stats.peakF > (global.peakFAll*0.85) && stats.peakProj < (global.peakProjAll*0.85)){
      flags.push("High force, low speed");
      recs.push("High force near release but low projectile speed suggests inefficiency‚Äîimprove technique and stiffness at release.");
    }
    if(stats.peakM > (global.peakMAll*0.85) && stats.peakProj < (global.peakProjAll*0.85)){
      flags.push("High moment, low speed");
      recs.push("Excess torque without output‚Äîreduce joint stress by improving timing and reducing braking at the limb.");
    }
  }

  if(phaseName==="Follow-through"){
    if(stats.peakM > (global.peakMAll*0.90) && stats.avgProjDropFast){
      flags.push("Abrupt decel");
      recs.push("Abrupt deceleration: work on follow-through and eccentric control to reduce joint loading.");
    }
    if(stats.avgW > (global.avgWAll*1.1)){
      flags.push("Residual high œâ");
      recs.push("Residual high œâ in follow-through: add deceleration drills and trunk control to safely dissipate energy.");
    }
  }

  // plane-aware hint (light)
  if(global.plane==="frontal" && (phaseName==="Acceleration" || phaseName==="Release/Contact")){
    recs.push("Frontal view: watch lateral sway and pelvic drop; keep COM stable and avoid side-bending during force transfer.");
  }
  if(global.plane==="sagittal" && (phaseName==="Acceleration" || phaseName==="Release/Contact")){
    recs.push("Sagittal view: watch over-striding/early braking and trunk collapse; keep stiffness and stack trunk over base.");
  }

  // fallback
  if(!recs.length){
    flags.push("No major flags");
    recs.push("Maintain current pattern. Aim for smooth load ‚Üí strong acceleration ‚Üí clean transfer ‚Üí controlled follow-through.");
  }

  return { flags: flags.join("; "), recommendation: recs.join(" ") };
}

/* =========================
   XLSX export with recommendations
========================= */
function downloadData(){
  if(!rec.n) return showStatus("No recorded data.", "error");

  const phases=segmentPhases();

  // global markers
  const peakProjIdx = argMax(rec.proj_speed);
  const peakWIdx = argMaxAbs(rec.driver_angVel);
  const peakFAll = maxAbs(rec.forceN);
  const peakMAll = maxAbs(rec.momentNm);
  const peakProjAll = maxAbs(rec.proj_speed);
  const avgWAll = mean(rec.driver_angVel);

  const globalCtx = {
    peakProjIdx, peakWIdx, n: rec.n, fps: rec.fpsUsed,
    plane: rec.plane,
    peakFAll, peakMAll, peakProjAll, avgWAll
  };

  // profile
  const p=currentParticipant||{};
  const profileRows=[
    {field:"name", value:p.name||""},
    {field:"sex", value:p.sex||""},
    {field:"age", value:p.age||""},
    {field:"mass_kg", value:p.mass||""},
    {field:"height_cm", value:p.height||""},
    {field:"plane", value:rec.plane},
    {field:"driver", value:rec.driver},
    {field:"fps_used", value:rec.fpsUsed},
    {field:"samples", value:rec.n},
    {field:"event_marker_peak_proj_speed_sample", value:peakProjIdx},
    {field:"event_marker_peak_driver_angVel_sample", value:peakWIdx},
    {field:"notes", value:"Kinematics Kalman-filtered. œâ [rad/s]. Angles [rad]. Kinetics low-pass filtered (cascaded) for smooth force-time / moment-time."}
  ];

  // phase summary rows
  const rows=[];
  phases.forEach(ph=>{
    const driverV = slice(rec.driver_linVel, ph);
    const driverW = slice(rec.driver_angVel, ph);
    const driverA = slice(rec.driver_angle, ph);
    const driverD = slice(rec.driver_disp, ph);
    const projSp  = slice(rec.proj_speed, ph);
    const fArr    = slice(rec.forceN, ph);
    const mArr    = slice(rec.momentNm, ph);

    const stats = {
      peakProj: maxAbs(projSp),
      peakW: maxAbs(driverW),
      avgW: mean(driverW),
      peakAngle: maxAbs(driverA),
      avgAngle: mean(driverA),
      peakV: maxAbs(driverV),
      avgV: mean(driverV),
      peakF: maxAbs(fArr),
      avgF: mean(fArr),
      peakM: maxAbs(mArr),
      avgM: mean(mArr),
      // simple "drop fast" heuristic for follow-through:
      avgProjDropFast: (ph.name==="Follow-through" && projSp.length>2) ? (projSp[0] - projSp[projSp.length-1] > globalCtx.peakProjAll*0.35) : false
    };

    const recText = buildPhaseRecommendation(ph.name, stats, globalCtx);

    // driver and projectile summary
    rows.push({
      phase: ph.name,
      markers: ph.markers || "",
      metric: "driver_linVel [m/s]",
      avg: round(mean(driverV), 6),
      peak: round(maxAbs(driverV), 6),
      flags: "",
      recommendation: ""
    });
    rows.push({
      phase: ph.name,
      markers: ph.markers || "",
      metric: "driver_angVel [rad/s]",
      avg: round(mean(driverW), 6),
      peak: round(maxAbs(driverW), 6),
      flags: "",
      recommendation: ""
    });
    rows.push({
      phase: ph.name,
      markers: ph.markers || "",
      metric: "driver_angle [rad]",
      avg: round(mean(driverA), 6),
      peak: round(maxAbs(driverA), 6),
      flags: "",
      recommendation: ""
    });
    rows.push({
      phase: ph.name,
      markers: ph.markers || "",
      metric: "driver_disp [m]",
      avg: round(mean(driverD), 6),
      peak: round(maxAbs(driverD), 6),
      flags: "",
      recommendation: ""
    });
    rows.push({
      phase: ph.name,
      markers: ph.markers || "",
      metric: "projectile_speed [m/s]",
      avg: round(mean(projSp), 6),
      peak: round(maxAbs(projSp), 6),
      flags: recText.flags,
      recommendation: recText.recommendation
    });
    rows.push({
      phase: ph.name,
      markers: ph.markers || "",
      metric: "Force [N] (filtered)",
      avg: round(mean(fArr), 6),
      peak: round(maxAbs(fArr), 6),
      flags: "",
      recommendation: ""
    });
    rows.push({
      phase: ph.name,
      markers: ph.markers || "",
      metric: "Moment [Nm] (filtered)",
      avg: round(mean(mArr), 8),
      peak: round(maxAbs(mArr), 8),
      flags: "",
      recommendation: ""
    });

    // selected metrics summary (all)
    rec.metricsDefs.forEach(def=>{
      const arr = slice(rec.metrics[def.id], ph);
      const unit = unitsFor(def);
      rows.push({
        phase: ph.name,
        markers: ph.markers || "",
        metric: `${def.type}_${def.joint}_${def.side} ${unit}`,
        avg: round(mean(arr), 6),
        peak: round(maxAbs(arr), 6),
        flags: "",
        recommendation: ""
      });
    });
  });

  // time-series (discrete)
  const ts=[];
  for(let i=0;i<rec.n;i++){
    const r={
      sample: i,
      time_s: round(rec.t[i], 6),
      "Force[N](filt)": round(rec.forceN[i]||0, 6),
      "Moment[Nm](filt)": round(rec.momentNm[i]||0, 8),
      "driver_linVel[m/s](kal)": round(rec.driver_linVel[i]||0, 6),
      "driver_angVel[rad/s](kal)": round(rec.driver_angVel[i]||0, 6),
      "driver_angle[rad](kal)": round(rec.driver_angle[i]||0, 6),
      "driver_disp[m](int)": round(rec.driver_disp[i]||0, 6),
      "proj_speed[m/s](kal)": round(rec.proj_speed[i]||0, 6),
    };

    // selected metrics full series
    rec.metricsDefs.forEach(def=>{
      const val = (rec.metrics[def.id] && rec.metrics[def.id][i]!=null) ? rec.metrics[def.id][i] : 0;
      if(def.type==="angle") r[`${def.id}[rad]`] = round(val, 6);
      else if(def.type==="angVel") r[`${def.id}[rad/s]`] = round(val, 6);
      else r[`${def.id}[m/s]`] = round(val, 6);
    });

    ts.push(r);
  }

  const wb=XLSX.utils.book_new();
  XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet(profileRows), "1_Profile");
  XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet(rows), "2_Phase_Summary");
  XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet(ts), "3_TimeSeries");

  XLSX.writeFile(wb, `analysis_${(p.name||"participant").replace(/\s+/g,"_")}_${Date.now()}.xlsx`);
  showStatus("Exported XLSX (Phase Summary includes recommendations).", "success");
}

/* =========================
   UI metric selection
========================= */
function unitsFor(def){
  if(def.type==="linVel") return "[m/s]";
  if(def.type==="angVel") return "[rad/s]";
  if(def.type==="angle") return "[rad]";
  return "";
}
function addMetric(){
  const type=document.getElementById('metricType').value;
  const joint=document.getElementById('metricJoint').value;
  const side=document.getElementById('metricSide').value;
  const id=`${type}_${joint}_${side}`;
  if(!selectedMetrics.find(m=>m.id===id)){
    selectedMetrics.push({id,type,joint,side});
    renderMetricChips();
  }
}
function removeMetric(id){ selectedMetrics=selectedMetrics.filter(m=>m.id!==id); renderMetricChips(); }
function clearMetrics(){ selectedMetrics=[]; renderMetricChips(); }

function renderMetricChips(){
  const chips=document.getElementById('metricChips');
  const panel=document.getElementById('selectedMetricsPanel');
  chips.innerHTML=""; panel.innerHTML="";
  selectedMetrics.forEach(m=>{
    const label = (m.type==="angVel") ? `${m.type} ${m.joint} ${m.side} [rad/s]`
                 : (m.type==="linVel") ? `${m.type} ${m.joint} ${m.side} [m/s]`
                 : `${m.type} ${m.joint} ${m.side} [rad]`;

    const chip=document.createElement('div');
    chip.className="chip";
    chip.innerHTML=`${label} <button onclick="removeMetric('${m.id}')">‚úï</button>`;
    chips.appendChild(chip);

    const card=document.createElement('div');
    card.className="metric";
    card.innerHTML=`
      <div class="t">${label}</div>
      <div class="v" id="val_${m.id}">--</div>
      <div class="s">${metricHint(m)}</div>
    `;
    panel.appendChild(card);
  });
}
function metricHint(m){
  if(m.type==="linVel") return "Kalman-filtered linear velocity [m/s].";
  if(m.type==="angVel") return "Kalman-filtered angular velocity [rad/s] derived from filtered angle.";
  if(m.type==="angle") return "Kalman-filtered angle [rad].";
  return "";
}

/* =========================
   Snapshot
========================= */
function snapshotPNG(){
  if(!video || video.paused) return showStatus("Start Camera/Upload first.", "error");
  const c=document.createElement('canvas');
  const w=overlay.width, h=overlay.height;
  c.width=w; c.height=h;
  const g=c.getContext('2d');
  try{ g.drawImage(video,0,0,w,h); }catch(_){}
  try{ g.drawImage(overlay,0,0,w,h); }catch(_){}
  const a=document.createElement('a');
  a.href=c.toDataURL("image/png");
  a.download=`snapshot_${Date.now()}.png`;
  a.click();
}

/* =========================
   Collapsible + PiP + status
========================= */
function toggleCollapse(id){
  const el=document.getElementById(id);
  el.classList.toggle('collapsed');
  document.getElementById(id+'_lbl').innerText = el.classList.contains('collapsed') ? "Expand" : "Collapse";
}
function togglePiP(){ document.body.classList.toggle('pip-on'); }

function showStatus(msg,type){
  const el=document.getElementById('statusMessage');
  el.innerText=msg;
  el.className=`status-message status-${type}`;
  el.style.display='block';
  setTimeout(()=>el.style.display='none', 3000);
}
function setStatusText(t){ document.getElementById('statusText').innerText=t; }
function setSourceText(t){ document.getElementById('sourceText').innerText=t; }
</script>
</body>
</html>
