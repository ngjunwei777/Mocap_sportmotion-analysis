<!--
¬© 2025 Ng Jun Wei
All rights reserved.

This source code and associated assets are proprietary.
Unauthorized copying, modification, distribution, or use is prohibited
without prior written permission from Ng Jun Wei.
-->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <meta name="author" content="Ng Jun Wei">
  <meta name="copyright" content="¬© 2025 Ng Jun Wei. All rights reserved.">
  <title>Sport Performance Analyzer (iOS) + Projectile</title>

  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.11.0"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@2.1.0"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.3"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

  <style>
    * { margin:0; padding:0; box-sizing:border-box; }
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 14px;
    }
    .container {
      max-width: 1400px;
      margin: 0 auto;
      background: #fff;
      border-radius: 18px;
      padding: 16px;
      box-shadow: 0 18px 55px rgba(0,0,0,0.22);
    }
    h1 { text-align:center; color:#667eea; margin-bottom:6px; font-size:2.05em; }
    .subtitle { text-align:center; color:#666; margin-bottom:14px; font-size:1.02em; }

    .layout {
      display:grid;
      grid-template-columns: 1.08fr 0.92fr;
      gap: 14px;
      align-items:start;
    }
    @media (max-width: 980px) { .layout { grid-template-columns: 1fr; } }

    .card {
      background:#f8f9fa;
      border-radius: 14px;
      padding: 14px;
    }

    .form-grid {
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(190px, 1fr));
      gap: 10px;
      margin-top: 10px;
    }
    label { font-weight: 850; margin-bottom: 6px; color:#333; display:block; }
    input, select {
      width:100%;
      padding: 10px;
      border: 2px solid #ddd;
      border-radius: 12px;
      font-size: 14px;
      background:#fff;
    }
    input:focus, select:focus { outline:none; border-color:#667eea; }

    .btn {
      padding: 11px 14px;
      border: none;
      border-radius: 12px;
      font-size: 14px;
      font-weight: 900;
      cursor:pointer;
      margin: 8px 8px 0 0;
      transition: transform .15s, opacity .15s;
    }
    .btn:hover { transform: translateY(-1px); }
    .btn:disabled { background:#cfcfcf !important; cursor:not-allowed; opacity:.85; transform:none; }
    .btn-primary { background:#667eea; color:#fff; }
    .btn-success { background:#10b981; color:#fff; }
    .btn-danger  { background:#ef4444; color:#fff; }

    .status-message{
      display:none;
      text-align:center;
      padding: 10px 12px;
      border-radius: 12px;
      font-weight: 950;
      margin: 10px 0 14px 0;
    }
    .status-success { background:#d1fae5; color:#065f46; }
    .status-error { background:#fee2e2; color:#991b1b; }
    .status-info { background:#dbeafe; color:#1e40af; }

    .sticky { position: sticky; top: 8px; }
    @media (max-width: 980px) { .sticky { top: 0; z-index: 50; } }

    .video-wrap {
      position:relative;
      background:#000;
      border-radius: 14px;
      overflow:hidden;
    }
    video {
      width:100%;
      height:auto;
      display:block;
      position:relative;
      z-index:1;
      transform: translateZ(0);
      -webkit-transform: translateZ(0);
    }
    canvas#overlay {
      width:100%;
      height:auto;
      display:block;
      position:absolute;
      left:0; top:0;
      z-index:5;
      pointer-events:none;
    }
    .hud {
      position:absolute;
      top: 10px; right: 10px;
      z-index: 10;
      background: rgba(0,0,0,0.72);
      color:#fff;
      padding: 6px 10px;
      border-radius: 12px;
      font-size: 13px;
      font-weight: 950;
      display:flex;
      flex-direction: column;
      gap:6px;
      align-items:flex-end;
      max-width: 95%;
    }
    .hud small { font-weight: 850; opacity: .92; }

    .divider { height:1px; background:#e9e9e9; margin: 12px 0; }
    .mini { color:#666; font-size: .88em; line-height: 1.35; margin-top: 8px; }

    .metrics-grid{
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 10px;
      margin-top: 10px;
    }
    .metric{
      background:#fff;
      border-radius: 14px;
      padding: 12px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.06);
    }
    .metric .t{ color:#666; font-weight:850; font-size:.92em; margin-bottom: 6px; }
    .metric .v{ color:#667eea; font-weight: 1000; font-size: 1.55em; }
    .unit{ color:#999; font-weight: 900; font-size: .75em; margin-left: 6px; }

    .chiplist { margin-top: 10px; display:flex; flex-wrap:wrap; gap: 8px; }
    .chip {
      background:#fff;
      border-radius: 999px;
      padding: 8px 10px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.06);
      display:flex;
      align-items:center;
      gap: 10px;
      font-weight: 900;
      color:#333;
      font-size: 13px;
    }
    .chip button {
      border:none;
      background: rgba(239,68,68,0.12);
      color:#ef4444;
      font-weight: 1000;
      border-radius: 999px;
      padding: 4px 8px;
      cursor:pointer;
    }

    .charts-grid { display:grid; grid-template-columns: 1fr; gap: 12px; margin-top: 10px; }
    .chart-card{
      background:#fff;
      border-radius: 14px;
      padding: 12px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.06);
    }
    .chart-title{
      display:flex;
      justify-content: space-between;
      align-items:center;
      gap: 10px;
      margin-bottom: 8px;
    }
    .chart-title b{ color:#222; }
    .chart-title span{ color:#666; font-weight: 850; font-size: .9em; }

    canvas.chart{
      width: 100%;
      height: 150px;
      display:block;
      border-radius: 12px;
      background: #fafafa;
    }

    .participants-list .item{
      background:#fff;
      border-radius: 14px;
      padding: 12px;
      margin-top: 10px;
      display:flex;
      justify-content: space-between;
      gap: 12px;
      align-items:center;
      box-shadow: 0 2px 10px rgba(0,0,0,0.06);
    }

    footer {
      margin-top: 14px;
      text-align:center;
      color:#666;
      font-weight: 850;
      font-size: 0.92em;
    }
  </style>
</head>

<body>
<div class="container">
  <h1>üèÉ‚Äç‚ôÇÔ∏è Sport Performance Analyzer</h1>
  <p class="subtitle">iOS-safe pose overlay ‚Ä¢ selectable metrics ‚Ä¢ filtered force/moment ‚Ä¢ projectile tracking</p>

  <div id="statusMessage" class="status-message"></div>

  <div class="layout">
    <!-- LEFT -->
    <div>
      <div class="card">
        <h3>Participant</h3>
        <div class="form-grid">
          <div>
            <label for="participantName">Name *</label>
            <input id="participantName" placeholder="Enter name">
          </div>
          <div>
            <label for="participantSex">Sex *</label>
            <select id="participantSex">
              <option value="">Select</option>
              <option value="male">Male</option>
              <option value="female">Female</option>
              <option value="other">Other</option>
            </select>
          </div>
          <div>
            <label for="participantAge">Age *</label>
            <input id="participantAge" type="number" min="5" max="120" placeholder="Age">
          </div>
          <div>
            <label for="participantMass">Mass (kg) *</label>
            <input id="participantMass" type="number" min="20" max="300" step="0.1" placeholder="kg">
          </div>
          <div>
            <label for="participantHeight">Height (cm) *</label>
            <input id="participantHeight" type="number" min="50" max="250" step="0.1" placeholder="cm">
          </div>
        </div>
        <button class="btn btn-success" onclick="addParticipant()">Add Participant</button>

        <div class="divider"></div>

        <label for="selectedParticipant">Select Participant for Recording</label>
        <select id="selectedParticipant"></select>

        <div class="form-grid">
          <div>
            <label for="fpsSelection">Requested FPS</label>
            <select id="fpsSelection">
              <option value="30">30 FPS</option>
              <option value="60">60 FPS</option>
              <option value="120">120 FPS</option>
              <option value="240">240 FPS</option>
            </select>
          </div>
          <div>
            <label for="cameraFacing">Camera</label>
            <select id="cameraFacing">
              <option value="environment">Back</option>
              <option value="user">Front</option>
            </select>
          </div>
          <div>
            <label for="planeSelection">Plane</label>
            <select id="planeSelection">
              <option value="sagittal">Sagittal</option>
              <option value="frontal">Frontal</option>
              <option value="transverse">Transverse (2D proxy)</option>
            </select>
          </div>
          <div>
            <label for="windowSeconds">Chart Window</label>
            <select id="windowSeconds">
              <option value="5">5s</option>
              <option value="10" selected>10s</option>
              <option value="15">15s</option>
              <option value="20">20s</option>
            </select>
          </div>
          <div>
            <label for="cutoffHz">Low-pass Cutoff (Hz)</label>
            <select id="cutoffHz">
              <option value="2">2 Hz (very smooth)</option>
              <option value="4">4 Hz</option>
              <option value="6" selected>6 Hz (balanced)</option>
              <option value="8">8 Hz</option>
              <option value="12">12 Hz (less smooth)</option>
            </select>
          </div>
        </div>

        <div class="divider"></div>

        <h3>Projectile Tracking</h3>
        <div class="form-grid">
          <div>
            <label for="projMode">Mode</label>
            <select id="projMode">
              <option value="off" selected>Off</option>
              <option value="auto">Auto (COCO ‚Üí fallback)</option>
              <option value="coco">Object Detect (COCO-SSD)</option>
              <option value="motion">Motion Tracker (fallback)</option>
            </select>
          </div>
          <div>
            <label for="projClassHint">Class Hint</label>
            <select id="projClassHint">
              <option value="sports ball" selected>Sports ball</option>
              <option value="any">Any object (largest moving)</option>
            </select>
          </div>
          <div>
            <label for="projTrail">Trail length (frames)</label>
            <select id="projTrail">
              <option value="10">10</option>
              <option value="20" selected>20</option>
              <option value="30">30</option>
              <option value="50">50</option>
            </select>
          </div>
        </div>

        <button class="btn btn-primary" onclick="startCamera()">Start Camera</button>
        <button class="btn btn-primary" onclick="stopCamera()">Stop Camera</button>
        <button class="btn btn-success" id="recordBtn" onclick="startRecording()" disabled>Start Recording</button>
        <button class="btn btn-danger" id="stopBtn" onclick="stopRecording()" disabled>Stop Recording</button>
      </div>

      <div class="card" style="margin-top: 12px;">
        <h3>Display Selector (Angles & Velocities)</h3>
        <div class="form-grid">
          <div>
            <label for="metricType">Metric</label>
            <select id="metricType">
              <option value="angle">Angle (¬∞)</option>
              <option value="angVel">Angular Velocity (¬∞/s)</option>
              <option value="linVel">Linear Velocity (m/s)</option>
            </select>
          </div>
          <div>
            <label for="metricJoint">Joint</label>
            <select id="metricJoint">
              <option value="shoulder">Shoulder</option>
              <option value="elbow">Elbow</option>
              <option value="wrist">Wrist</option>
              <option value="hip">Hip</option>
              <option value="knee">Knee</option>
              <option value="ankle">Ankle</option>
              <option value="neck">Neck</option>
            </select>
          </div>
          <div>
            <label for="metricSide">Side</label>
            <select id="metricSide">
              <option value="R">Right (R)</option>
              <option value="L">Left (L)</option>
            </select>
          </div>
        </div>
        <button class="btn btn-primary" onclick="addMetric()">Add to Display</button>
        <button class="btn btn-danger" onclick="clearMetrics()">Clear</button>

        <div class="chiplist" id="metricChips"></div>

        <div class="divider"></div>

        <h3>Selected Metrics (Real-time)</h3>
        <div class="metrics-grid" id="selectedMetricsPanel"></div>
      </div>

      <div class="card" style="margin-top: 12px;">
        <h3>Kinetics Charts (Real-time)</h3>
        <div class="charts-grid">
          <div class="chart-card">
            <div class="chart-title">
              <b>Force‚ÄìTime |F| (N)</b>
              <span id="lblForce">0.0 N</span>
            </div>
            <canvas id="chartForce" class="chart"></canvas>
          </div>

          <div class="chart-card">
            <div class="chart-title">
              <b>Moment‚ÄìTime œÑz (N¬∑m)</b>
              <span id="lblMoment">0.00 N¬∑m</span>
            </div>
            <canvas id="chartMoment" class="chart"></canvas>
          </div>
        </div>
      </div>

      <div class="card participants-list" style="margin-top: 12px;">
        <h3>Participants (<span id="participantCount">0</span>/10)</h3>
        <div id="participantsList"></div>
        <button class="btn btn-primary" onclick="downloadData()">üìä Download All Data (XLSX)</button>
      </div>
    </div>

    <!-- RIGHT -->
    <div class="sticky">
      <div class="card">
        <h3>Sticky Video (Always Visible)</h3>
        <div class="video-wrap">
          <video id="video" playsinline muted></video>
          <canvas id="overlay"></canvas>
          <div class="hud">
            <div><span id="fpsIndicator">FPS: 0</span></div>
            <small id="negotiatedInfo">‚Äî</small>
            <small id="projInfo">Projectile: ‚Äî</small>
          </div>
        </div>
      </div>
    </div>
  </div>

  <footer>¬© 2025 Ng Jun Wei. All rights reserved.</footer>
</div>

<script>
  // ======================
  // Globals
  // ======================
  let detector = null;
  let cocoModel = null;

  let video = null;
  let overlay = null;
  let ctx = null;
  let animationId = null;
  let streamRef = null;

  let isRecording = false;
  let recordingFrames = [];
  let participants = [];
  let currentParticipant = null;

  let detectedFPS = 0;
  let frameCount = 0;
  let lastFPSUpdate = Date.now();

  let prevFrame = null; // pose/COM state

  // Impulse accumulators
  let impulse_Ns = 0;
  let angImpulse_Nms = 0;
  let lastImpulseT = null;

  // Filter state
  let filt = { force: null, moment: null };
  let lastFilterT = null;

  // Selected metrics
  let selectedMetrics = []; // {id,type,joint,side}

  // --- Angular velocity smoothing state (stable œâ)
  const angState = { map: new Map() };
  const MAX_OMEGA_DEG_S = 900;   // clamp spikes
  const MAX_DTHETA_DEG = 45;     // clamp per-frame delta before dt division

  // Projectile tracking state
  const proj = {
    px: null,
    m_prev: null,
    t_prev: null,
    speed: 0,
    trail: [],
    lastDetectT: 0,
    motionCanvas: null,
    motionCtx: null,
    prevGray: null
  };

  // MoveNet keypoint indices
  const KP = {
    nose: 0,
    left_eye: 1, right_eye: 2,
    left_ear: 3, right_ear: 4,
    shoulder_L: 5, shoulder_R: 6,
    elbow_L: 7, elbow_R: 8,
    wrist_L: 9, wrist_R: 10,
    hip_L: 11, hip_R: 12,
    knee_L: 13, knee_R: 14,
    ankle_L: 15, ankle_R: 16
  };

  const JOINT_LABELS = [
    "nose","left_eye","right_eye","left_ear","right_ear",
    "shoulder_L","shoulder_R","elbow_L","elbow_R","wrist_L","wrist_R",
    "hip_L","hip_R","knee_L","knee_R","ankle_L","ankle_R"
  ];

  const SKELETON = [
    [KP.shoulder_L, KP.shoulder_R],
    [KP.shoulder_L, KP.elbow_L],
    [KP.elbow_L, KP.wrist_L],
    [KP.shoulder_R, KP.elbow_R],
    [KP.elbow_R, KP.wrist_R],
    [KP.shoulder_L, KP.hip_L],
    [KP.shoulder_R, KP.hip_R],
    [KP.hip_L, KP.hip_R],
    [KP.hip_L, KP.knee_L],
    [KP.knee_L, KP.ankle_L],
    [KP.hip_R, KP.knee_R],
    [KP.knee_R, KP.ankle_R],
  ];

  // ======================
  // Helpers
  // ======================
  function showStatus(message, type) {
    const el = document.getElementById('statusMessage');
    el.className = `status-message status-${type}`;
    el.textContent = message;
    el.style.display = 'block';
    setTimeout(() => { el.style.display = 'none'; }, 3200);
  }

  function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }

  function clampScore(kp, thr=0.3) {
    return kp && typeof kp.score === "number" && kp.score >= thr;
  }

  function midpoint(a,b) {
    return { x:(a.x+b.x)/2, y:(a.y+b.y)/2, score: Math.min(a.score??0, b.score??0) };
  }

  function deg(rad){ return rad * 180 / Math.PI; }

  function calcAngle(p1,p2,p3) {
    const r = Math.atan2(p3.y-p2.y, p3.x-p2.x) - Math.atan2(p1.y-p2.y, p1.x-p2.x);
    let a = Math.abs(deg(r));
    if (a>180) a = 360-a;
    return a;
  }

  function segmentAngleDeg(a, b) {
    return deg(Math.atan2(b.y - a.y, b.x - a.x));
  }

  function unwrapDeltaDeg(curr, prev) {
    let d = curr - prev;
    d = ((d + 180) % 360) - 180;
    return d;
  }

  function vecSub(a,b){ return {x:a.x-b.x, y:a.y-b.y}; }
  function vecMul(a,s){ return {x:a.x*s, y:a.y*s}; }
  function vecLen(a){ return Math.sqrt(a.x*a.x + a.y*a.y); }
  function crossZ(a,b){ return a.x*b.y - a.y*b.x; }

  function drawText(text, x, y) {
    ctx.font = '14px system-ui, -apple-system, Segoe UI, Arial';
    ctx.fillStyle = 'rgba(0,0,0,0.65)';
    ctx.fillText(text, x+1, y+1);
    ctx.fillStyle = '#ffffff';
    ctx.fillText(text, x, y);
  }

  function pxToMetersScale() {
    const h_m = currentParticipant ? (currentParticipant.height / 100) : 1.70;
    const px = overlay ? overlay.height : 720;
    return h_m / px;
  }

  function resizeOverlayToVideo() {
    const vw = video.videoWidth || 0;
    const vh = video.videoHeight || 0;
    if (vw && vh) {
      if (overlay.width !== vw) overlay.width = vw;
      if (overlay.height !== vh) overlay.height = vh;
    }
  }

  function updateFPS() {
    frameCount++;
    const now = Date.now();
    if (now - lastFPSUpdate >= 1000) {
      detectedFPS = frameCount;
      document.getElementById('fpsIndicator').textContent = `FPS: ${detectedFPS}`;
      frameCount = 0;
      lastFPSUpdate = now;
    }
  }

  function getCutoffHz() { return parseFloat(document.getElementById("cutoffHz").value); }
  function getWindowSec() { return parseInt(document.getElementById("windowSeconds").value, 10); }

  // Confidence gate for segment-based angular velocity
  function segConfidenceOK(jointsPx, side, segKey) {
    const s = side;
    const j = jointsPx;
    const has = (k) => j[k] && (j[k].score == null || j[k].score >= 0.30);

    if (segKey === "upperArm") return has(`shoulder_${s}`) && has(`elbow_${s}`);
    if (segKey === "forearm")  return has(`elbow_${s}`) && has(`wrist_${s}`);
    if (segKey === "thigh")    return has(`hip_${s}`) && has(`knee_${s}`);
    if (segKey === "shank")    return has(`knee_${s}`) && has(`ankle_${s}`);
    if (segKey === "trunk")    return has("neck") && has("hip_L") && has("hip_R");
    return false;
  }

  // ======================
  // Metric selection UI
  // ======================
  function metricLabel(m) {
    const type = m.type === "angle" ? "Angle" : (m.type === "angVel" ? "AngVel" : "LinVel");
    const unit = m.type === "angle" ? "¬∞" : (m.type === "angVel" ? "¬∞/s" : "m/s");
    return `${type} ‚Ä¢ ${m.joint.toUpperCase()}_${m.side} (${unit})`;
  }

  function addMetric() {
    const type = document.getElementById("metricType").value;
    const joint = document.getElementById("metricJoint").value;
    const side = document.getElementById("metricSide").value;

    const id = `${type}:${joint}:${side}`;
    if (selectedMetrics.some(x => x.id === id)) {
      showStatus("That metric is already selected.", "info");
      return;
    }

    selectedMetrics.push({ id, type, joint, side });
    renderMetricUI();
  }

  function removeMetric(id) {
    selectedMetrics = selectedMetrics.filter(m => m.id !== id);
    renderMetricUI();
  }

  function clearMetrics() {
    selectedMetrics = [];
    renderMetricUI();
  }

  function renderMetricUI() {
    const chips = document.getElementById("metricChips");
    chips.innerHTML = selectedMetrics.map(m => `
      <div class="chip">
        <span>${metricLabel(m)}</span>
        <button onclick="removeMetric('${m.id}')">Remove</button>
      </div>
    `).join("");

    const panel = document.getElementById("selectedMetricsPanel");
    panel.innerHTML = selectedMetrics.map(m => `
      <div class="metric">
        <div class="t">${metricLabel(m)}</div>
        <div class="v" id="val_${m.id.replaceAll(':','_')}">0</div>
      </div>
    `).join("");

    if (!selectedMetrics.length) {
      panel.innerHTML = `<div class="mini">No metrics selected yet. Use the selector above to add angles/velocities.</div>`;
    }
  }

  // ======================
  // Low-pass filter (1st order IIR)
  // ======================
  function lowPass(prevY, x, dt, fc) {
    if (prevY == null) return x;
    const RC = 1 / (2 * Math.PI * fc);
    const alpha = dt / (RC + dt);
    return prevY + alpha * (x - prevY);
  }

  // ======================
  // Charts
  // ======================
  const chartSeries = {
    forceRaw: [],
    forceFilt: [],
    momentRaw: [],
    momentFilt: []
  };

  function pushSeries(name, t, v) {
    const win = getWindowSec();
    const arr = chartSeries[name];
    arr.push({t, v});
    const tMin = t - win;
    while (arr.length && arr[0].t < tMin) arr.shift();
  }

  function sizeChartCanvas(c) {
    const dpr = window.devicePixelRatio || 1;
    const cssW = c.clientWidth;
    const cssH = c.clientHeight;
    const w = Math.floor(cssW * dpr);
    const h = Math.floor(cssH * dpr);
    if (c.width !== w || c.height !== h) { c.width = w; c.height = h; }
    return { w, h };
  }

  function drawDualLineChart(canvasId, rawName, filtName, yLabel) {
    const c = document.getElementById(canvasId);
    const g = c.getContext("2d");
    const {w,h} = sizeChartCanvas(c);

    g.clearRect(0,0,w,h);
    g.fillStyle = "#fafafa";
    g.fillRect(0,0,w,h);

    g.strokeStyle = "rgba(0,0,0,0.08)";
    g.lineWidth = 1;
    for (let i=1;i<=4;i++){
      const y = (h*i)/5;
      g.beginPath(); g.moveTo(0,y); g.lineTo(w,y); g.stroke();
    }

    const raw = chartSeries[rawName];
    const fil = chartSeries[filtName];
    if (!raw.length) return;

    const t0 = raw[0].t;
    const t1 = raw[raw.length-1].t;
    const dt = Math.max(1e-6, t1 - t0);

    let minV = raw[0].v, maxV = raw[0].v;
    for (const p of raw) { if (p.v < minV) minV = p.v; if (p.v > maxV) maxV = p.v; }
    for (const p of fil) { if (p.v < minV) minV = p.v; if (p.v > maxV) maxV = p.v; }
    if (minV === maxV) { minV -= 1; maxV += 1; }
    const pad = 0.08 * (maxV - minV);
    minV -= pad; maxV += pad;

    function mapX(t){ return ((t - t0) / dt) * w; }
    function mapY(v){ return h - ((v - minV) / (maxV - minV)) * h; }

    // raw faint
    g.strokeStyle = "rgba(120,120,120,0.35)";
    g.lineWidth = 2;
    g.beginPath();
    for (let i=0;i<raw.length;i++){
      const x = mapX(raw[i].t);
      const y = mapY(raw[i].v);
      if (i===0) g.moveTo(x,y); else g.lineTo(x,y);
    }
    g.stroke();

    // filtered bold color
    g.strokeStyle = (canvasId === "chartForce")
      ? "rgba(16,185,129,0.95)"
      : "rgba(239,68,68,0.95)";
    g.lineWidth = 3.5;
    g.beginPath();
    for (let i=0;i<fil.length;i++){
      const x = mapX(fil[i].t);
      const y = mapY(fil[i].v);
      if (i===0) g.moveTo(x,y); else g.lineTo(x,y);
    }
    g.stroke();

    g.fillStyle = "rgba(0,0,0,0.55)";
    g.font = "12px system-ui, -apple-system, Segoe UI, Arial";
    g.fillText(`${maxV.toFixed(2)}`, 8, 14);
    g.fillText(`${minV.toFixed(2)}`, 8, h - 6);
    g.fillText(yLabel, w - 90, 14);
  }

  let lastChartDrawT = 0;
  function throttleChartDraw(t) {
    if (t - lastChartDrawT < 1/15) return;
    lastChartDrawT = t;
    drawDualLineChart("chartForce", "forceRaw", "forceFilt", "N");
    drawDualLineChart("chartMoment", "momentRaw", "momentFilt", "N¬∑m");
  }

  // ======================
  // Model init (iOS)
  // ======================
  async function initializePoseDetection() {
    try { await tf.setBackend('webgl'); await tf.ready(); }
    catch (e) { try { await tf.setBackend('wasm'); await tf.ready(); } catch (_) {} }

    const model = window.poseDetection.SupportedModels.MoveNet;
    detector = await window.poseDetection.createDetector(model, {
      modelType: window.poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING
    });
  }

  async function initializeCoco() {
    if (cocoModel) return;
    showStatus("Loading projectile detector‚Ä¶", "info");
    cocoModel = await cocoSsd.load();
    showStatus("Projectile detector loaded ‚úÖ", "success");
  }

  // ======================
  // Camera
  // ======================
  async function startCamera() {
    try {
      video = document.getElementById("video");
      overlay = document.getElementById("overlay");
      ctx = overlay.getContext("2d");

      const reqFps = parseInt(document.getElementById("fpsSelection").value, 10);
      const facingMode = document.getElementById("cameraFacing").value;

      video.setAttribute("playsinline", "");
      video.muted = true;
      video.autoplay = true;

      showStatus("Starting camera‚Ä¶", "info");

      const stream = await navigator.mediaDevices.getUserMedia({
        audio: false,
        video: {
          facingMode: { ideal: facingMode },
          width: { ideal: 1280 },
          height: { ideal: 720 }
        }
      });

      streamRef = stream;
      video.srcObject = stream;

      await new Promise(res => video.onloadedmetadata = () => res());

      const track = stream.getVideoTracks()[0];
      if (track && track.applyConstraints) {
        try { await track.applyConstraints({ frameRate: { ideal: reqFps, max: reqFps } }); } catch (_) {}
      }

      await video.play();
      resizeOverlayToVideo();

      const settings = track && track.getSettings ? track.getSettings() : {};
      document.getElementById("negotiatedInfo").textContent =
        `${settings.width || video.videoWidth}√ó${settings.height || video.videoHeight} ‚Ä¢ req ${reqFps}fps ‚Ä¢ got ${settings.frameRate || "?"}fps`;

      if (!detector) {
        showStatus("Loading pose model‚Ä¶", "info");
        await initializePoseDetection();
      }

      // projectile model if needed
      const mode = document.getElementById("projMode").value;
      if (mode === "coco" || mode === "auto") await initializeCoco();
      ensureMotionTrackerInit();

      document.getElementById("recordBtn").disabled = false;

      // reset states
      prevFrame = null;
      impulse_Ns = 0; angImpulse_Nms = 0; lastImpulseT = null;
      filt.force = null; filt.moment = null; lastFilterT = null;
      for (const k of Object.keys(chartSeries)) chartSeries[k] = [];

      // clear angular smoothing state (important!)
      angState.map.clear();

      resetProjectileState();

      showStatus("Ready ‚úÖ", "success");

      if (animationId) cancelAnimationFrame(animationId);
      loop();

    } catch (err) {
      console.error(err);
      showStatus("Camera error: " + (err.message || err), "error");
    }
  }

  function stopCamera() {
    if (animationId) cancelAnimationFrame(animationId);
    animationId = null;

    if (video) { video.pause(); video.srcObject = null; }
    if (streamRef) { streamRef.getTracks().forEach(t => t.stop()); streamRef = null; }

    document.getElementById("recordBtn").disabled = true;
    document.getElementById("stopBtn").disabled = true;

    isRecording = false;
    currentParticipant = null;

    showStatus("Camera stopped.", "info");
  }

  // ======================
  // Overlay drawing (always on)
  // ======================
  function drawOverlayAlways(kps, neck) {
    ctx.lineWidth = 4;
    ctx.strokeStyle = "rgba(255,0,0,0.95)";
    for (const [i,j] of SKELETON) {
      const a = kps[i], b = kps[j];
      if (clampScore(a) && clampScore(b)) {
        ctx.beginPath();
        ctx.moveTo(a.x, a.y);
        ctx.lineTo(b.x, b.y);
        ctx.stroke();
      }
    }

    for (let i=0;i<kps.length;i++){
      const kp = kps[i];
      if (!clampScore(kp)) continue;
      ctx.beginPath();
      ctx.arc(kp.x, kp.y, 6, 0, Math.PI*2);
      ctx.fillStyle = "rgba(0,255,0,0.95)";
      ctx.fill();
      drawText(JOINT_LABELS[i], kp.x + 8, kp.y - 8);
    }
    if (neck) {
      ctx.beginPath();
      ctx.arc(neck.x, neck.y, 7, 0, Math.PI*2);
      ctx.fillStyle = "rgba(0,200,255,0.95)";
      ctx.fill();
      drawText("neck", neck.x + 8, neck.y - 8);
    }
  }

  // ======================
  // Pose mapping
  // ======================
  function buildJointsPx(kps, neck) {
    const pick = (idx) => {
      const kp = kps[idx];
      return clampScore(kp) ? {x:kp.x, y:kp.y, score:kp.score} : null;
    };
    return {
      shoulder_R: pick(KP.shoulder_R),
      shoulder_L: pick(KP.shoulder_L),
      elbow_R: pick(KP.elbow_R),
      elbow_L: pick(KP.elbow_L),
      wrist_R: pick(KP.wrist_R),
      wrist_L: pick(KP.wrist_L),
      hip_R: pick(KP.hip_R),
      hip_L: pick(KP.hip_L),
      knee_R: pick(KP.knee_R),
      knee_L: pick(KP.knee_L),
      ankle_R: pick(KP.ankle_R),
      ankle_L: pick(KP.ankle_L),
      neck: neck ? {x:neck.x, y:neck.y, score: neck.score ?? 0.5} : null
    };
  }

  function computeCOMpx(jpx) {
    const shR = jpx.shoulder_R, shL = jpx.shoulder_L;
    const hpR = jpx.hip_R, hpL = jpx.hip_L;
    const okSh = shR && shL;
    const okHp = hpR && hpL;

    if (okSh && okHp) {
      const shMid = midpoint(shL, shR);
      const hpMid = midpoint(hpL, hpR);
      return { x: shMid.x*0.4 + hpMid.x*0.6, y: shMid.y*0.4 + hpMid.y*0.6 };
    }
    if (okHp) {
      const hpMid = midpoint(hpL, hpR);
      return { x: hpMid.x, y: hpMid.y };
    }
    if (hpR) return { x: hpR.x, y: hpR.y };
    return null;
  }

  function computeAngles(jpx, side) {
    const s = side;
    const sh = jpx[`shoulder_${s}`], el = jpx[`elbow_${s}`], wr = jpx[`wrist_${s}`];
    const hp = jpx[`hip_${s}`], kn = jpx[`knee_${s}`], an = jpx[`ankle_${s}`];
    const neck = jpx.neck;

    const out = { shoulder:null, elbow:null, wrist:null, hip:null, knee:null, ankle:null, neck:null };

    if (el && sh && hp) out.shoulder = calcAngle(el, sh, hp);
    if (sh && el && wr) out.elbow = calcAngle(sh, el, wr);

    if (el && wr) {
      const a = Math.abs(segmentAngleDeg(el, wr));
      out.wrist = a > 180 ? 360 - a : a;
    }

    if (sh && hp && kn) out.hip = calcAngle(sh, hp, kn);
    if (hp && kn && an) out.knee = calcAngle(hp, kn, an);

    if (kn && an) {
      const a = Math.abs(segmentAngleDeg(kn, an));
      out.ankle = a > 180 ? 360 - a : a;
    }

    if (neck && jpx.hip_L && jpx.hip_R) {
      const hpMid = midpoint(jpx.hip_L, jpx.hip_R);
      const torso = { x: hpMid.x - neck.x, y: hpMid.y - neck.y };
      const ang = Math.abs(deg(Math.atan2(torso.x, torso.y)));
      out.neck = ang;
    }

    return out;
  }

  function computeSegmentAnglesForAngVel(jpx, side) {
    const s = side;
    const sh = jpx[`shoulder_${s}`], el = jpx[`elbow_${s}`], wr = jpx[`wrist_${s}`];
    const hp = jpx[`hip_${s}`], kn = jpx[`knee_${s}`], an = jpx[`ankle_${s}`];
    const neck = jpx.neck;

    return {
      upperArm: (sh && el) ? segmentAngleDeg(sh, el) : null,
      forearm:  (el && wr) ? segmentAngleDeg(el, wr) : null,
      thigh:    (hp && kn) ? segmentAngleDeg(hp, kn) : null,
      shank:    (kn && an) ? segmentAngleDeg(kn, an) : null,
      trunk:    (neck && jpx.hip_L && jpx.hip_R) ? segmentAngleDeg(neck, midpoint(jpx.hip_L, jpx.hip_R)) : null
    };
  }

  function computeJointLinearVel_mps(joints_m, prevJoints_m, dt, key) {
    const a = joints_m[key], b = prevJoints_m[key];
    if (!a || !b || dt <= 0) return null;
    const v = vecMul(vecSub(a,b), 1/dt);
    return vecLen(v); // m/s only
  }

  // ======================
  // Projectile tracking
  // ======================
  function resetProjectileState() {
    proj.px = null;
    proj.m_prev = null;
    proj.t_prev = null;
    proj.speed = 0;
    proj.trail = [];
    proj.lastDetectT = 0;
    proj.prevGray = null;
    document.getElementById("projInfo").textContent = "Projectile: ‚Äî";
  }

  function ensureMotionTrackerInit() {
    if (proj.motionCanvas) return;
    proj.motionCanvas = document.createElement("canvas");
    proj.motionCtx = proj.motionCanvas.getContext("2d", { willReadFrequently: true });
  }

  async function detectProjectileCOCO(t) {
    if (!cocoModel) return null;
    if (t - proj.lastDetectT < 0.2) return null; // 5Hz
    proj.lastDetectT = t;

    const preds = await cocoModel.detect(video);
    if (!preds || !preds.length) return null;

    const hint = document.getElementById("projClassHint").value;
    let cand = preds;

    if (hint !== "any") cand = preds.filter(p => p.class === hint);
    if (!cand.length) cand = preds;

    let best = null;
    let bestScore = -Infinity;
    for (const p of cand) {
      const [x,y,w,h] = p.bbox;
      const score = (p.score ?? 0) * Math.sqrt(Math.max(1, w*h));
      if (score > bestScore) { bestScore = score; best = p; }
    }
    if (!best || best.score < 0.35) return null;

    const [x,y,w,h] = best.bbox;
    return { x: x + w/2, y: y + h/2 };
  }

  function trackProjectileMotion() {
    ensureMotionTrackerInit();
    const mc = proj.motionCanvas;
    const mctx = proj.motionCtx;

    const w = video.videoWidth || 0;
    const h = video.videoHeight || 0;
    if (!w || !h) return null;

    const dw = 320;
    const dh = Math.round((h / w) * dw);
    mc.width = dw;
    mc.height = dh;

    mctx.drawImage(video, 0, 0, dw, dh);
    const img = mctx.getImageData(0, 0, dw, dh);
    const data = img.data;

    const gray = new Uint8Array(dw * dh);
    for (let i=0, j=0; i<data.length; i+=4, j++){
      const r=data[i], g=data[i+1], b=data[i+2];
      gray[j] = (0.299*r + 0.587*g + 0.114*b) | 0;
    }

    if (!proj.prevGray) {
      proj.prevGray = gray;
      return null;
    }

    const thr = 22;
    let sumX=0, sumY=0, count=0;

    for (let y=0; y<dh; y++){
      const row = y*dw;
      for (let x=0; x<dw; x++){
        const idx = row + x;
        const d = Math.abs(gray[idx] - proj.prevGray[idx]);
        if (d > thr) {
          sumX += x;
          sumY += y;
          count++;
        }
      }
    }

    proj.prevGray = gray;

    if (count < 120) return null;

    const cx = sumX / count;
    const cy = sumY / count;

    const px = cx * (w / dw);
    const py = cy * (h / dh);
    return { x: px, y: py };
  }

  function updateProjectileKinematics(t, posPx, scale_m_per_px) {
    if (!posPx) return;

    const maxTrail = parseInt(document.getElementById("projTrail").value, 10);
    proj.trail.push({x: posPx.x, y: posPx.y});
    while (proj.trail.length > maxTrail) proj.trail.shift();

    const m = { x: posPx.x * scale_m_per_px, y: posPx.y * scale_m_per_px };

    if (proj.m_prev && proj.t_prev != null) {
      const dt = t - proj.t_prev;
      if (dt > 1e-4 && dt < 0.5) {
        const v = vecMul(vecSub(m, proj.m_prev), 1/dt);
        proj.speed = vecLen(v);
      }
    }

    proj.px = posPx;
    proj.m_prev = m;
    proj.t_prev = t;
  }

  function drawProjectileOverlay() {
    if (!proj.px) return;

    ctx.lineWidth = 3;
    ctx.strokeStyle = "rgba(255,255,255,0.65)";
    ctx.beginPath();
    for (let i=0; i<proj.trail.length; i++){
      const p = proj.trail[i];
      if (i===0) ctx.moveTo(p.x, p.y);
      else ctx.lineTo(p.x, p.y);
    }
    ctx.stroke();

    ctx.beginPath();
    ctx.arc(proj.px.x, proj.px.y, 8, 0, Math.PI*2);
    ctx.fillStyle = "rgba(255, 165, 0, 0.95)";
    ctx.fill();
    drawText(`Projectile v ${proj.speed.toFixed(2)} m/s`, proj.px.x + 12, proj.px.y - 10);

    document.getElementById("projInfo").textContent =
      `Projectile: ${proj.speed.toFixed(2)} m/s`;
  }

  // ======================
  // Selected metrics computation (stable œâ)
  // ======================
  function computeSelectedMetricValues({dt, jointsPx, joints_m, angR, angL, segR, segL, prevFrame}) {
    const out = {};
    for (const m of selectedMetrics) {
      const side = m.side;
      const sideAngles = (side === "R") ? angR : angL;
      const sideSeg = (side === "R") ? segR : segL;

      let val = null;

      if (m.type === "angle") {
        val = sideAngles[m.joint] ?? null;

      } else if (m.type === "angVel") {
        // Stable angular velocity:
        // filter segment angle Œ∏ first, then œâ = dŒ∏/dt; clamp + filter œâ
        if (!prevFrame || !dt || dt <= 0.005 || dt > 0.08) {
          val = null;
        } else {
          const map = {
            shoulder: "upperArm",
            elbow: "forearm",
            wrist: "forearm",
            hip: "thigh",
            knee: "shank",
            ankle: "shank",
            neck: "trunk"
          };
          const segKey = map[m.joint];

          if (!segConfidenceOK(jointsPx, m.side, segKey)) {
            val = null;
          } else {
            const currTheta = sideSeg[segKey];
            const prevTheta = (side === "R")
              ? (prevFrame.segAnglesR ? prevFrame.segAnglesR[segKey] : null)
              : (prevFrame.segAnglesL ? prevFrame.segAnglesL[segKey] : null);

            if (currTheta == null || prevTheta == null) {
              val = null;
            } else {
              let dTheta = unwrapDeltaDeg(currTheta, prevTheta);
              dTheta = clamp(dTheta, -MAX_DTHETA_DEG, MAX_DTHETA_DEG);

              const st = angState.map.get(m.id) || { prevThetaF: null, omegaF: null };

              const fcTheta = getCutoffHz();
              const thetaPred = (st.prevThetaF == null) ? currTheta : (st.prevThetaF + dTheta);
              const thetaF = lowPass(st.prevThetaF, thetaPred, dt, fcTheta);

              let omega = 0;
              if (st.prevThetaF != null) omega = (thetaF - st.prevThetaF) / dt;
              omega = clamp(omega, -MAX_OMEGA_DEG_S, MAX_OMEGA_DEG_S);

              const fcOmega = Math.max(2, fcTheta * 0.6);
              const omegaF = lowPass(st.omegaF, omega, dt, fcOmega);

              angState.map.set(m.id, { prevThetaF: thetaF, omegaF });
              val = omegaF;
            }
          }
        }

      } else if (m.type === "linVel") {
        if (!prevFrame || !dt || dt <= 1e-4 || dt > 0.2) val = null;
        else {
          const jointKey = (m.joint === "neck") ? "neck" : `${m.joint}_${m.side}`;
          val = computeJointLinearVel_mps(joints_m, prevFrame.joints_m, dt, jointKey);
        }
      }

      out[m.id] = val;
    }
    return out;
  }

  function drawSelectedLabels(values, jointsPx) {
    let count = 0;
    for (const m of selectedMetrics) {
      if (count > 8) break;
      const v = values[m.id];
      if (v == null) continue;

      const unit = (m.type === "angle") ? "¬∞" : (m.type === "angVel") ? "¬∞/s" : "m/s";
      const symbol = (m.type === "angle") ? "A" : (m.type === "angVel") ? "œâ" : "v";

      let anchor = null;
      if (m.joint === "neck") anchor = jointsPx.neck;
      else anchor = jointsPx[`${m.joint}_${m.side}`];
      if (!anchor) continue;

      drawText(`${m.joint.toUpperCase()}_${m.side} ${symbol} ${v.toFixed(2)} ${unit}`, anchor.x + 10, anchor.y + 18);
      count++;
    }
  }

  // ======================
  // Main loop
  // ======================
  async function loop() {
    try {
      if (!video || video.readyState < 2 || !detector) {
        animationId = requestAnimationFrame(loop);
        return;
      }

      resizeOverlayToVideo();
      ctx.clearRect(0,0,overlay.width, overlay.height);

      const poses = await detector.estimatePoses(video);
      const t = performance.now() / 1000;
      const scale = pxToMetersScale();

      // Projectile update
      const projMode = document.getElementById("projMode").value;
      let projPos = null;

      if (projMode !== "off") {
        if (projMode === "coco" || projMode === "auto") {
          projPos = await detectProjectileCOCO(t);
        }
        if (!projPos && (projMode === "motion" || projMode === "auto")) {
          projPos = trackProjectileMotion();
        }
        if (projPos) updateProjectileKinematics(t, projPos, scale);
      }

      if (poses && poses.length) {
        const kps = poses[0].keypoints;

        const shL = kps[KP.shoulder_L], shR = kps[KP.shoulder_R];
        const neck = (clampScore(shL) && clampScore(shR)) ? midpoint(shL, shR) : null;

        drawOverlayAlways(kps, neck);

        const jointsPx = buildJointsPx(kps, neck);
        const comPx = computeCOMpx(jointsPx);

        if (comPx) {
          ctx.beginPath();
          ctx.arc(comPx.x, comPx.y, 7, 0, Math.PI*2);
          ctx.fillStyle = "rgba(255,255,0,0.95)";
          ctx.fill();
          drawText("COM", comPx.x + 8, comPx.y - 8);
        }

        // convert joints to meters
        const joints_m = {};
        for (const k of Object.keys(jointsPx)) {
          const p = jointsPx[k];
          joints_m[k] = p ? { x: p.x * scale, y: p.y * scale } : null;
        }
        const com_m = comPx ? { x: comPx.x * scale, y: comPx.y * scale } : null;

        const angR = computeAngles(jointsPx, "R");
        const angL = computeAngles(jointsPx, "L");
        const segR = computeSegmentAnglesForAngVel(jointsPx, "R");
        const segL = computeSegmentAnglesForAngVel(jointsPx, "L");

        // kinetics from COM acceleration
        let forceMag = 0;
        let momentZ = 0;

        const mass = currentParticipant ? currentParticipant.mass : 70;
        let v_com = {x:0,y:0};

        const dt = prevFrame ? (t - prevFrame.t) : 0;

        if (prevFrame && com_m && prevFrame.com_m && dt > 1e-4 && dt < 0.2) {
          const d = vecSub(com_m, prevFrame.com_m);
          v_com = vecMul(d, 1/dt);

          const dv = vecSub(v_com, prevFrame.v_com || {x:0,y:0});
          const a_com = vecMul(dv, 1/dt);

          const F = { x: mass * a_com.x, y: mass * a_com.y };
          forceMag = vecLen(F);

          if (joints_m.hip_L && joints_m.hip_R) {
            const hpMid_m = { x:(joints_m.hip_L.x + joints_m.hip_R.x)/2, y:(joints_m.hip_L.y + joints_m.hip_R.y)/2 };
            const r = vecSub(hpMid_m, com_m);
            momentZ = crossZ(r, F);
          }

          // impulses during recording
          if (isRecording) {
            if (lastImpulseT != null) {
              const dtI = t - lastImpulseT;
              if (dtI > 1e-4 && dtI < 0.2) {
                impulse_Ns += forceMag * dtI;
                angImpulse_Nms += momentZ * dtI;
              }
            }
            lastImpulseT = t;
          }
        }

        // filtering for charts
        let dtF = 0;
        if (lastFilterT != null) dtF = t - lastFilterT;
        lastFilterT = t;

        const fc = getCutoffHz();
        const fFilt = (dtF > 0) ? lowPass(filt.force, forceMag, dtF, fc) : forceMag;
        const mFilt = (dtF > 0) ? lowPass(filt.moment, momentZ, dtF, fc) : momentZ;
        filt.force = fFilt;
        filt.moment = mFilt;

        pushSeries("forceRaw", t, forceMag);
        pushSeries("forceFilt", t, fFilt);
        pushSeries("momentRaw", t, momentZ);
        pushSeries("momentFilt", t, mFilt);

        document.getElementById("lblForce").textContent = `${fFilt.toFixed(1)} N`;
        document.getElementById("lblMoment").textContent = `${mFilt.toFixed(2)} N¬∑m`;

        throttleChartDraw(t);

        // Selected metrics
        const values = computeSelectedMetricValues({
          dt, jointsPx, joints_m, angR, angL, segR, segL, prevFrame
        });

        for (const m of selectedMetrics) {
          const elId = "val_" + m.id.replaceAll(":","_");
          const el = document.getElementById(elId);
          if (!el) continue;
          const v = values[m.id];
          const unit = (m.type === "angle") ? "¬∞" : (m.type === "angVel") ? "¬∞/s" : "m/s";
          el.innerHTML = (v == null ? "N/A" : `${v.toFixed(2)}<span class="unit">${unit}</span>`);
        }

        drawSelectedLabels(values, jointsPx);

        // Projectile overlay (draw on top)
        if (projMode !== "off") drawProjectileOverlay();

        // Recording frame
        if (isRecording && currentParticipant) {
          recordingFrames.push({
            t_ms: Date.now(),
            t_s: t,
            fpsDetected: detectedFPS,
            plane: document.getElementById("planeSelection").value,
            cutoffHz: getCutoffHz(),

            forceRaw_N: forceMag,
            forceFilt_N: fFilt,
            momentRaw_Nm: momentZ,
            momentFilt_Nm: mFilt,

            impulse_Ns,
            angImpulse_Nms,

            projectile_px: proj.px ? {x: proj.px.x, y: proj.px.y} : null,
            projectile_speed_mps: projMode !== "off" ? proj.speed : 0,

            selected: values,
            joints: jointsPx
          });
        }

        // prevFrame update
        prevFrame = {
          t, joints_m, com_m, v_com,
          segAnglesR: segR,
          segAnglesL: segL
        };
      } else {
        if (projMode !== "off") drawProjectileOverlay();
      }

      updateFPS();
      animationId = requestAnimationFrame(loop);

    } catch (e) {
      console.error("Loop error:", e);
      showStatus("Runtime error (recovering)‚Ä¶", "error");
      animationId = requestAnimationFrame(loop);
    }
  }

  // ======================
  // Recording
  // ======================
  function startRecording() {
    const selectedId = document.getElementById("selectedParticipant").value;
    if (!selectedId) { showStatus("Select a participant first!", "error"); return; }
    currentParticipant = participants.find(p => String(p.id) === String(selectedId));
    if (!currentParticipant) { showStatus("Participant not found.", "error"); return; }

    isRecording = true;
    recordingFrames = [];

    impulse_Ns = 0; angImpulse_Nms = 0; lastImpulseT = null;

    // reset angular smoothing on new recording
    angState.map.clear();

    document.getElementById("recordBtn").disabled = true;
    document.getElementById("stopBtn").disabled = false;

    showStatus(`Recording for ${currentParticipant.name}‚Ä¶`, "info");
  }

  function stopRecording() {
    if (isRecording && currentParticipant && recordingFrames.length) {
      currentParticipant.recordings.push({
        timestamp: new Date().toISOString(),
        fpsDetected: detectedFPS,
        plane: document.getElementById("planeSelection").value,
        cutoffHz: getCutoffHz(),
        windowSec: getWindowSec(),
        projMode: document.getElementById("projMode").value,
        projHint: document.getElementById("projClassHint").value,
        selectedMetrics: [...selectedMetrics],
        frames: recordingFrames
      });
      updateParticipantsList();
      showStatus(`Saved ‚úÖ ${recordingFrames.length} frames`, "success");
    } else {
      showStatus("Stopped (no frames saved).", "info");
    }

    isRecording = false;
    recordingFrames = [];
    currentParticipant = null;

    document.getElementById("recordBtn").disabled = false;
    document.getElementById("stopBtn").disabled = true;
  }

  // ======================
  // Participants
  // ======================
  function addParticipant() {
    if (participants.length >= 10) { showStatus("Max 10 participants.", "error"); return; }
    const name = document.getElementById('participantName').value.trim();
    const sex = document.getElementById('participantSex').value;
    const age = document.getElementById('participantAge').value;
    const mass = document.getElementById('participantMass').value;
    const height = document.getElementById('participantHeight').value;

    if (!name || !sex || !age || !mass || !height) { showStatus("Fill all participant fields.", "error"); return; }

    participants.push({
      id: Date.now(),
      name, sex,
      age: parseInt(age,10),
      mass: parseFloat(mass),
      height: parseFloat(height),
      recordings: []
    });

    clearParticipantForm();
    updateParticipantsList();
    showStatus(`Added "${name}" ‚úÖ`, "success");
  }

  function clearParticipantForm() {
    document.getElementById('participantName').value = '';
    document.getElementById('participantSex').value = '';
    document.getElementById('participantAge').value = '';
    document.getElementById('participantMass').value = '';
    document.getElementById('participantHeight').value = '';
  }

  function updateParticipantsList() {
    document.getElementById("participantCount").textContent = participants.length;

    const list = document.getElementById("participantsList");
    list.innerHTML = participants.map(p => `
      <div class="item">
        <div>
          <b>${p.name}</b> ‚Äî ${p.sex}, ${p.age}y, ${p.mass}kg, ${p.height}cm
          <div style="color:#666; font-weight:850; font-size:.88em; margin-top:4px;">
            Recordings: ${p.recordings.length}
          </div>
        </div>
        <button class="btn btn-danger" onclick="removeParticipant(${p.id})">Remove</button>
      </div>
    `).join("");

    const sel = document.getElementById("selectedParticipant");
    sel.innerHTML = `<option value="">Select a participant</option>` +
      participants.map(p => `<option value="${p.id}">${p.name}</option>`).join("");
  }

  function removeParticipant(id) {
    participants = participants.filter(p => p.id !== id);
    updateParticipantsList();
    showStatus("Participant removed.", "info");
  }

  // ======================
  // XLSX Export
  // ======================
  function avg(arr) { return arr.length ? arr.reduce((a,b)=>a+b,0)/arr.length : 0; }
  function max(arr) { return arr.length ? Math.max(...arr) : 0; }

  function downloadData() {
    if (!participants.length) { showStatus("No participants to export!", "error"); return; }
    const wb = XLSX.utils.book_new();

    participants.forEach(p => {
      const rows = [];
      rows.push(["Participant Information"]);
      rows.push(["Name", p.name]);
      rows.push(["Sex", p.sex]);
      rows.push(["Age", p.age]);
      rows.push(["Mass (kg)", p.mass]);
      rows.push(["Height (cm)", p.height]);
      rows.push([]);
      rows.push(["Recordings", p.recordings.length]);

      p.recordings.forEach((rec, ridx) => {
        rows.push([]);
        rows.push([`Recording ${ridx+1}`, rec.timestamp]);
        rows.push(["Plane", rec.plane]);
        rows.push(["Detected FPS", rec.fpsDetected]);
        rows.push(["Low-pass cutoff (Hz)", rec.cutoffHz]);
        rows.push(["Projectile Mode", rec.projMode]);
        rows.push(["Projectile Hint", rec.projHint]);

        const F = rec.frames.map(f => f.forceFilt_N ?? 0);
        const M = rec.frames.map(f => f.momentFilt_Nm ?? 0);

        const avgForce = avg(F);
        const avgMoment = avg(M);

        const finalImpulse = rec.frames.length ? (rec.frames[rec.frames.length-1].impulse_Ns ?? 0) : 0;
        const finalAngImpulse = rec.frames.length ? (rec.frames[rec.frames.length-1].angImpulse_Nms ?? 0) : 0;

        const projSpeeds = rec.frames.map(f => f.projectile_speed_mps ?? 0).filter(v => v > 0);
        const avgProj = avg(projSpeeds);
        const maxProj = max(projSpeeds);

        rows.push(["Average Force (N)", Number(avgForce.toFixed(3))]);
        rows.push(["Average Moment œÑz (N¬∑m)", Number(avgMoment.toFixed(3))]);
        rows.push(["Total Impulse ‚à´|F|dt (N¬∑s)", Number(finalImpulse.toFixed(3))]);
        rows.push(["Total Angular Impulse ‚à´œÑdt (N¬∑m¬∑s)", Number(finalAngImpulse.toFixed(3))]);
        rows.push(["Projectile Avg Speed (m/s)", Number(avgProj.toFixed(3))]);
        rows.push(["Projectile Max Speed (m/s)", Number(maxProj.toFixed(3))]);

        rows.push([]);
        rows.push(["Calculation Used"]);
        rows.push(["Force", "|F| = m¬∑|a_COM|"]);
        rows.push(["Impulse", "Impulse = Œ£ |F|¬∑dt"]);
        rows.push(["Moment", "œÑz = r √ó F (2D z-component), r = pelvis_mid - COM"]);
        rows.push(["Angular Impulse", "Angular Impulse = Œ£ œÑ¬∑dt"]);
        rows.push(["Projectile Speed", "v = |Œîx|/Œît, x in meters using scale = (height_m / video_px_height)"]);

        rows.push([]);
        rows.push(["Selected Metrics"]);
        (rec.selectedMetrics || []).forEach(m => rows.push([`${m.type}:${m.joint}:${m.side}`]));
        rows.push([]);

        const header = [
          "Frame","t_ms","t_s","fpsDetected","plane",
          "forceRaw_N","forceFilt_N","momentRaw_Nm","momentFilt_Nm",
          "impulse_Ns","angImpulse_Nms",
          "projectile_x_px","projectile_y_px","projectile_speed_mps",
          "selectedMetrics_JSON"
        ];
        rows.push(header);

        rec.frames.forEach((f, i) => {
          rows.push([
            i, f.t_ms, Number((f.t_s ?? 0).toFixed(4)), f.fpsDetected, f.plane,
            Number((f.forceRaw_N ?? 0).toFixed(4)),
            Number((f.forceFilt_N ?? 0).toFixed(4)),
            Number((f.momentRaw_Nm ?? 0).toFixed(4)),
            Number((f.momentFilt_Nm ?? 0).toFixed(4)),
            Number((f.impulse_Ns ?? 0).toFixed(4)),
            Number((f.angImpulse_Nms ?? 0).toFixed(4)),
            f.projectile_px ? Number(f.projectile_px.x.toFixed(2)) : "N/A",
            f.projectile_px ? Number(f.projectile_px.y.toFixed(2)) : "N/A",
            Number((f.projectile_speed_mps ?? 0).toFixed(4)),
            JSON.stringify(f.selected || {})
          ]);
        });
      });

      const ws = XLSX.utils.aoa_to_sheet(rows);
      XLSX.utils.book_append_sheet(wb, ws, p.name.substring(0,31));
    });

    XLSX.writeFile(wb, `sport_performance_${new Date().toISOString().split("T")[0]}.xlsx`);
    showStatus("Exported XLSX ‚úÖ", "success");
  }

  // ======================
  // Boot
  // ======================
  window.addEventListener("load", () => {
    renderMetricUI();
    updateParticipantsList();
    showStatus("Ready. Add participant ‚Üí select metrics ‚Üí Start Camera.", "info");
  });
</script>
</body>
</html>
