<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <meta name="author" content="Ng Jun Wei">
  <meta name="copyright" content="¬© 2025 Ng Jun Wei. All rights reserved.">
  <title>Sport Performance Analyzer (iOS) + Joint-Driven Kinetics</title>

  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.11.0"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@2.1.0"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.3"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

  <style>
    * { margin:0; padding:0; box-sizing:border-box; }
    body{
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 14px;
      padding-bottom: 80px;
    }
    .container{
      max-width: 1400px;
      margin: 0 auto;
      background:#fff;
      border-radius: 18px;
      padding: 16px;
      box-shadow: 0 18px 55px rgba(0,0,0,0.22);
    }
    h1 { text-align:center; color:#667eea; margin-bottom:6px; font-size:2.05em; }
    .subtitle{ text-align:center; color:#666; margin-bottom:14px; font-size:1.02em; }

    .layout{
      display:grid;
      grid-template-columns: 1.08fr 0.92fr;
      gap: 14px;
      align-items:start;
    }
    @media (max-width: 980px){ .layout{ grid-template-columns: 1fr; } }

    .card{ background:#f8f9fa; border-radius: 14px; padding: 14px; }
    .form-grid{
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(190px, 1fr));
      gap: 10px;
      margin-top: 10px;
    }
    label{ font-weight: 850; margin-bottom: 6px; color:#333; display:block; }
    input, select{
      width:100%;
      padding: 10px;
      border: 2px solid #ddd;
      border-radius: 12px;
      font-size: 14px;
      background:#fff;
    }
    input:focus, select:focus{ outline:none; border-color:#667eea; }

    .btn{
      padding: 11px 14px;
      border: none;
      border-radius: 12px;
      font-size: 14px;
      font-weight: 900;
      cursor:pointer;
      margin: 8px 8px 0 0;
      transition: transform .15s, opacity .15s;
    }
    .btn:hover{ transform: translateY(-1px); }
    .btn:disabled{ background:#cfcfcf !important; cursor:not-allowed; opacity:.85; transform:none; }
    .btn-primary{ background:#667eea; color:#fff; }
    .btn-success{ background:#10b981; color:#fff; }
    .btn-danger { background:#ef4444; color:#fff; }
    .btn-ghost { background: rgba(102,126,234,0.12); color:#3b4bd6; }

    .status-message{
      display:none;
      text-align:center;
      padding: 10px 12px;
      border-radius: 12px;
      font-weight: 950;
      margin: 10px 0 14px 0;
    }
    .status-success{ background:#d1fae5; color:#065f46; }
    .status-error{ background:#fee2e2; color:#991b1b; }
    .status-info{ background:#dbeafe; color:#1e40af; }

    .sticky{ position: sticky; top: 8px; }
    @media (max-width: 980px){ .sticky{ top: 0; z-index: 50; position: static; } }

    .video-wrap{ position:relative; background:#000; border-radius: 14px; overflow:hidden; min-height: 200px; }
    video{ width:100%; height:auto; display:block; position:relative; z-index:1; }
    canvas#overlay{
      width:100%; height:100%; display:block;
      position:absolute; left:0; top:0;
      z-index:5; pointer-events:none;
    }
    .hud{
      position:absolute; top: 10px; right: 10px;
      z-index: 10;
      background: rgba(0,0,0,0.72);
      color:#fff;
      padding: 6px 10px;
      border-radius: 12px;
      font-size: 13px;
      font-weight: 950;
      display:flex;
      flex-direction: column;
      gap:6px;
      align-items:flex-end;
      max-width: 95%;
      white-space: pre-line;
    }
    .divider{ height:1px; background:#e9e9e9; margin: 12px 0; }
    .mini{ color:#666; font-size: .88em; line-height: 1.35; margin-top: 8px; }

    .metrics-grid{
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 10px;
      margin-top: 10px;
    }
    .metric{
      background:#fff;
      border-radius: 14px;
      padding: 12px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.06);
    }
    .metric .t{ color:#666; font-weight:850; font-size:.92em; margin-bottom: 6px; }
    .metric .v{ color:#667eea; font-weight: 1000; font-size: 1.55em; }
    .metric .s{ color:#666; font-weight: 850; font-size: .88em; margin-top: 6px; line-height: 1.25; }

    .chiplist{ margin-top: 10px; display:flex; flex-wrap:wrap; gap: 8px; }
    .chip{
      background:#fff;
      border-radius: 999px;
      padding: 6px 10px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.06);
      display:flex;
      align-items:center;
      gap: 10px;
      font-weight: 900;
      color:#333;
      font-size: 13px;
    }
    .chip button{
      border:none;
      background: rgba(239,68,68,0.12);
      color:#ef4444;
      font-weight: 1000;
      border-radius: 999px;
      padding: 4px 8px;
      cursor:pointer;
    }

    .charts-grid{ display:grid; grid-template-columns: 1fr; gap: 12px; margin-top: 10px; }
    .chart-card{
      background:#fff;
      border-radius: 14px;
      padding: 12px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.06);
    }
    .chart-title{
      display:flex;
      justify-content: space-between;
      align-items:center;
      gap: 10px;
      margin-bottom: 8px;
    }
    .chart-title b{ color:#222; }
    .chart-title span{ color:#666; font-weight: 850; font-size: .9em; }
    canvas.chart{
      width: 100%;
      height: 170px;
      display:block;
      border-radius: 12px;
      background: #fafafa;
    }

    .card-head{
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 6px;
    }
    .collapse-btn{
      display:inline-flex;
      align-items:center;
      gap: 8px;
      border:none;
      cursor:pointer;
      border-radius: 12px;
      padding: 10px 12px;
      font-weight: 1000;
      background: rgba(102,126,234,0.12);
      color:#3b4bd6;
    }
    .collapse-icon{
      width: 10px;
      height: 10px;
      border-right: 3px solid currentColor;
      border-bottom: 3px solid currentColor;
      transform: rotate(45deg);
      transition: transform .18s ease;
      margin-left: 2px;
    }
    .collapsed .collapse-icon{ transform: rotate(-45deg); }
    .collapsible{
      overflow: hidden;
      transition: max-height .22s ease, opacity .22s ease;
      max-height: 2000px;
      opacity: 1;
    }
    .collapsed .collapsible{
      max-height: 0px;
      opacity: 0;
      pointer-events: none;
    }

    footer{ margin-top: 14px; text-align:center; color:#666; font-weight: 850; font-size: 0.92em; }

    .pip-toggle{ display:none; margin-top: 10px; }
    @media (max-width: 980px) {
      .pip-toggle{ display:inline-block; }
      body.pip-on .sticky .card{
        position: fixed;
        left: 12px; right: 12px; bottom: 12px;
        z-index: 9999;
        padding: 10px;
        box-shadow: 0 18px 55px rgba(0,0,0,0.35);
        max-width: 520px;
        margin: 0 auto;
      }
      body.pip-on .container{ padding-bottom: 270px; }
    }
  </style>
</head>

<body>
<div class="container">
  <h1>üèÉ‚Äç‚ôÇÔ∏è Movement Kinetics Lab</h1>
  <p class="subtitle">Skill inference via CV heuristics ‚Ä¢ projectile kinematics exported ‚Ä¢ œâ in [rad/s], angles exported in [rad]</p>

  <div id="statusMessage" class="status-message"></div>

  <div class="layout">
    <div>
      <div class="card">
        <h3>Participant</h3>
        <div class="form-grid">
          <div><label>Name *</label><input id="participantName" placeholder="Enter name"></div>
          <div>
            <label>Sex *</label>
            <select id="participantSex"><option value="male">Male</option><option value="female">Female</option></select>
          </div>
          <div><label>Age *</label><input id="participantAge" type="number" value="25"></div>
          <div><label>Mass (kg) *</label><input id="participantMass" type="number" value="70"></div>
          <div><label>Height (cm) *</label><input id="participantHeight" type="number" value="175"></div>
        </div>
        <button class="btn btn-success" onclick="addParticipant()">Add / Update Participant</button>

        <div class="divider"></div>

        <label>Select Participant</label>
        <select id="selectedParticipant" onchange="onParticipantChange()"></select>

        <div class="divider"></div>

        <h3>Input Source</h3>
        <div class="form-grid">
          <div>
            <label>Source</label>
            <select id="inputSource">
              <option value="camera" selected>Live Camera</option>
              <option value="upload">Video Upload</option>
            </select>
          </div>
          <div>
            <label>FPS (Requested)</label>
            <select id="fpsSelection">
              <option value="30">30</option>
              <option value="60" selected>60</option>
              <option value="120">120 (best effort)</option>
              <option value="240">240 (best effort)</option>
            </select>
          </div>
          <div>
            <label>Camera</label>
            <select id="cameraFacing"><option value="environment">Back</option><option value="user">Front</option></select>
          </div>
          <div>
            <label>Window (s)</label>
            <select id="windowSeconds"><option value="5">5s</option><option value="10" selected>10s</option></select>
          </div>
          <div>
            <label>Low-pass cutoff (Hz)</label>
            <select id="cutoffHz">
              <option value="2">2</option>
              <option value="3">3</option>
              <option value="4">4</option>
              <option value="6" selected>6</option>
              <option value="10">10</option>
            </select>
          </div>
        </div>

        <div class="form-grid" style="margin-top:10px;">
          <div><label>Video File (Upload)</label><input id="videoUpload" type="file" accept="video/*"></div>
        </div>

        <button class="btn btn-primary" onclick="startInput()">Start (Camera / Upload)</button>
        <button class="btn btn-danger" onclick="stopInput()">Stop</button>
        <button class="btn btn-success" id="recordBtn" onclick="toggleRecording()" disabled>Start Recording</button>
        <button class="btn btn-ghost" onclick="snapshotPNG()" id="snapBtn" disabled>üì∏ Snapshot PNG</button>
        <button class="btn btn-primary pip-toggle" onclick="togglePiP()">üìå Pin Video (PiP)</button>

        <div class="divider"></div>

        <h3>Projectile Tracking</h3>
        <div class="form-grid">
          <div>
            <label>Mode</label>
            <select id="projMode"><option value="off" selected>Off</option><option value="coco">COCO-SSD Detect</option></select>
          </div>
          <div>
            <label>Class</label>
            <select id="projClassHint">
              <option value="sports ball" selected>Sports ball</option>
              <option value="frisbee">Frisbee</option>
              <option value="kite">Kite</option>
              <option value="bottle">Bottle</option>
              <option value="cup">Cup</option>
              <option value="person">Person</option>
            </select>
          </div>
          <div>
            <label>Confidence</label>
            <select id="projMinScore">
              <option value="0.30">0.30</option>
              <option value="0.40" selected>0.40</option>
              <option value="0.50">0.50</option>
              <option value="0.60">0.60</option>
            </select>
          </div>
          <div>
            <label>Detect Rate</label>
            <select id="projEveryN">
              <option value="1">Every frame</option>
              <option value="2" selected>Every 2 frames</option>
              <option value="3">Every 3 frames</option>
              <option value="4">Every 4 frames</option>
            </select>
          </div>
        </div>

        <div class="divider"></div>

        <h3>Kinetics Driver</h3>
        <div class="form-grid">
          <div>
            <label>Driver Joint</label>
            <select id="kinJoint">
              <option value="hip">Hip</option><option value="knee">Knee</option>
              <option value="shoulder">Shoulder</option><option value="elbow">Elbow</option>
              <option value="ankle">Ankle</option>
              <option value="wrist">Wrist</option>
            </select>
          </div>
          <div>
            <label>Side</label>
            <select id="kinSide"><option value="R">Right</option><option value="L">Left</option></select>
          </div>
        </div>
        <p class="mini">œâ computed as ŒîŒ∏(rad)/Œît ‚Üí [rad/s]. Angles exported in [rad]. Projectile kinematics exported in [m], [m/s], [m/s¬≤].</p>
      </div>

      <div class="card collapsible-card" id="displaySelectorCard" style="margin-top:12px;">
        <div class="card-head">
          <h3 style="margin:0;">Display Selector</h3>
          <button class="collapse-btn" onclick="toggleCollapse('displaySelectorCard')">
            <span id="displaySelectorCard_lbl">Collapse</span><span class="collapse-icon"></span>
          </button>
        </div>
        <div class="collapsible">
          <div class="form-grid">
            <div>
              <label>Metric</label>
              <select id="metricType">
                <option value="angle">Angle [deg]</option>
                <option value="angVel">Ang. Vel [rad/s]</option>
                <option value="linVel">Lin. Vel [m/s]</option>
              </select>
            </div>
            <div>
              <label>Joint</label>
              <select id="metricJoint">
                <option value="shoulder">Shoulder</option>
                <option value="elbow">Elbow</option>
                <option value="wrist">Wrist</option>
                <option value="hip">Hip</option>
                <option value="knee">Knee</option>
                <option value="ankle">Ankle</option>
              </select>
            </div>
            <div>
              <label>Side</label>
              <select id="metricSide"><option value="R">Right</option><option value="L">Left</option></select>
            </div>
          </div>
          <button class="btn btn-primary" onclick="addMetric()">Add</button>
          <button class="btn btn-danger" onclick="clearMetrics()">Clear</button>
          <div class="chiplist" id="metricChips"></div>
          <div class="divider"></div>
          <div class="metrics-grid" id="selectedMetricsPanel"></div>

          <div class="divider"></div>
          <div class="metric">
            <div class="t">Live CV interpretation</div>
            <div class="s" id="liveInterpretation">‚Äî</div>
          </div>
        </div>
      </div>

      <div class="card" style="margin-top:12px;">
        <h3>Real-time Kinetics (Dual axis)</h3>
        <div class="charts-grid">
          <div class="chart-card">
            <div class="chart-title">
              <b>Force‚ÄìTime [N] + Moment‚ÄìTime [Nm]</b>
              <span id="lblKinetics">F: 0 N | M: 0 Nm</span>
            </div>
            <canvas id="chartDual" class="chart"></canvas>
          </div>
        </div>
      </div>

      <div class="card" style="margin-top:12px;">
        <button class="btn btn-primary" onclick="downloadData()">üìä Download XLSX (Profile ‚Ä¢ Kinematics ‚Ä¢ Projectile ‚Ä¢ Kinetics ‚Ä¢ Technical Model)</button>
      </div>
    </div>

    <div class="sticky" id="stickyVideo">
      <div class="card">
        <h3>Live View</h3>
        <div class="video-wrap">
          <video id="video" playsinline muted></video>
          <canvas id="overlay"></canvas>
          <div class="hud">
            <div id="fpsIndicator">FPS: 0</div>
            <small id="statusText">Ready</small>
            <small id="sourceText">Source: ‚Äî</small>
          </div>
        </div>
        <p class="mini">
          CV skill inference is heuristic: best results with tripod, good lighting, and projectile clearly visible.
        </p>
      </div>
    </div>
  </div>

  <footer>¬© 2025 Ng Jun Wei. All rights reserved.</footer>
</div>

<script>
/* =========================
   Globals
========================= */
let detector=null, cocoModel=null;
let video=null, overlay=null, ctx=null;
let streamRef=null, animationId=null;

let participants=[], currentParticipant=null;
let isRecording=false;
let sessionMeta={};

let prevFrameTS=0;
let prevKeypoints=null;
let frameIndex=0;

let prevAngleDriverDeg=null;
let prevAngleMapDeg=new Map();

let prevDriverPos=null;
let cumDisp=0;

let prevProjState=null;     // for projectile vel/acc
let lastProjectiles=[];

let detectedFPS=0, framesInSecond=0;
let lastFPSUpdate=performance.now();

let selectedMetrics=[];

const FILTER_ORDER = 4;
let forceStages = new Array(FILTER_ORDER).fill(0);
let momentStages = new Array(FILTER_ORDER).fill(0);

const chartSeries = { force:[], moment:[] };
let lastChartDraw=0;

const KP = {
  shoulder_L:5, shoulder_R:6, elbow_L:7, elbow_R:8, wrist_L:9, wrist_R:10,
  hip_L:11, hip_R:12, knee_L:13, knee_R:14, ankle_L:15, ankle_R:16
};

const SEG_MASS = { thigh:0.10, shank:0.0465, foot:0.0145, upperArm:0.028, forearm:0.016, hand:0.006, trunk:0.50 };
const SEG_K = { thigh:0.323, shank:0.302, foot:0.475, upperArm:0.322, forearm:0.303, hand:0.628 };

let rec = resetRec();

/* =========================
   Init
========================= */
window.onload = async () => {
  video=document.getElementById('video');
  overlay=document.getElementById('overlay');
  ctx=overlay.getContext('2d');

  document.getElementById('participantName').value="Athlete 1";
  addParticipant(true);

  showStatus("Loading Neural Networks...", "info");
  try{
    await tf.ready();
    try { await tf.setBackend('webgl'); await tf.ready(); } catch(_) {}

    detector = await poseDetection.createDetector(
      poseDetection.SupportedModels.MoveNet,
      { modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING }
    );
    cocoModel = await cocoSsd.load();

    showStatus("Models Ready. Start Camera or Upload.", "success");
    setStatusText("Models ready");
  }catch(e){
    console.error(e);
    showStatus("Error loading models. Try reloading.", "error");
    setStatusText("Model load error");
  }
};

/* =========================
   Participant
========================= */
function addParticipant(silent=false){
  const name=(document.getElementById('participantName').value||"").trim();
  const sex=document.getElementById('participantSex').value;
  const age=parseInt(document.getElementById('participantAge').value||"0");
  const mass=parseFloat(document.getElementById('participantMass').value||"0");
  const height=parseFloat(document.getElementById('participantHeight').value||"0");
  if(!name||!mass||!height||!age){ if(!silent) showStatus("Fill Name, Age, Mass, Height.", "error"); return; }

  const existing=participants.find(p=>p.name===name);
  const profile={name,sex,age,mass,height};
  if(existing) Object.assign(existing, profile);
  else participants.push(profile);

  const sel=document.getElementById('selectedParticipant');
  sel.innerHTML="";
  participants.forEach(p=>{
    const opt=document.createElement('option');
    opt.value=p.name; opt.textContent=p.name;
    sel.appendChild(opt);
  });
  sel.value=name;
  currentParticipant=profile;
  if(!silent) showStatus(`Participant set: ${name}`, "success");
}
function onParticipantChange(){
  const sel=document.getElementById('selectedParticipant');
  const p=participants.find(x=>x.name===sel.value);
  if(p) currentParticipant=p;
}

/* =========================
   Input
========================= */
async function startInput(){
  if(!detector) return showStatus("Wait for models to load.", "error");
  stopActive();
  resetSessionState();

  const src=document.getElementById('inputSource').value;
  const fpsReq=parseInt(document.getElementById('fpsSelection').value);
  const facing=document.getElementById('cameraFacing').value;

  sessionMeta={ source:src, fpsRequested:fpsReq, facing, startedAt:new Date().toISOString() };

  if(src==="camera") await startCameraInternal(fpsReq, facing);
  else await startUploadInternal();
}
async function startCameraInternal(fpsReq, facing){
  setStatusText("Starting camera...");
  setSourceText(`Source: Camera (${facing}, req ${fpsReq}fps)`);

  const constraints={
    video:{
      facingMode:facing,
      width:{ideal:1280},
      height:{ideal:720},
      frameRate:{ideal:fpsReq, max:fpsReq}
    },
    audio:false
  };

  try{
    streamRef=await navigator.mediaDevices.getUserMedia(constraints);
    video.srcObject=streamRef;
    video.onloadedmetadata=async()=>{
      await video.play();
      overlay.width=video.videoWidth||1280;
      overlay.height=video.videoHeight||720;

      if(facing==='user'){ video.style.transform="scaleX(-1)"; overlay.style.transform="scaleX(-1)"; }
      else { video.style.transform="none"; overlay.style.transform="none"; }

      enableRunButtons(true);
      setStatusText("Running");
      animationId=requestAnimationFrame(renderLoop);
      showStatus("Camera Active", "success");
    };
  }catch(err){
    console.error(err);
    showStatus("Camera Error: "+err.message, "error");
    setStatusText("Camera error");
  }
}
async function startUploadInternal(){
  const fileInput=document.getElementById('videoUpload');
  if(!fileInput.files.length) return showStatus("Select a video file first.", "error");
  const file=fileInput.files[0];
  const url=URL.createObjectURL(file);

  setStatusText("Loading video...");
  setSourceText(`Source: Upload (${file.name})`);

  video.srcObject=null;
  video.src=url;
  video.loop=true;
  video.muted=true;
  video.playsInline=true;

  video.onloadedmetadata=async()=>{
    try{
      await video.play();
      overlay.width=video.videoWidth||1280;
      overlay.height=video.videoHeight||720;

      video.style.transform="none";
      overlay.style.transform="none";

      enableRunButtons(true);
      setStatusText("Running");
      animationId=requestAnimationFrame(renderLoop);
      showStatus("Playing Upload", "success");
    }catch(e){
      console.error(e);
      showStatus("Upload playback error: "+e.message, "error");
      setStatusText("Upload error");
    }
  };
}
function stopInput(){
  stopActive();
  enableRunButtons(false);
  showStatus("Stopped", "info");
  setStatusText("Stopped");
  setSourceText("Source: ‚Äî");
}
function stopActive(){
  if(animationId) cancelAnimationFrame(animationId);
  animationId=null;

  if(streamRef){ try{ streamRef.getTracks().forEach(t=>t.stop()); }catch(_){} }
  streamRef=null;

  try{ video.pause(); }catch(_){}
  video.srcObject=null;

  if(ctx) ctx.clearRect(0,0,overlay.width,overlay.height);
}
function enableRunButtons(running){
  document.getElementById('recordBtn').disabled=!running;
  document.getElementById('snapBtn').disabled=!running;
}
function resetSessionState(){
  isRecording=false;
  rec=resetRec();

  prevFrameTS=0;
  prevKeypoints=null;
  frameIndex=0;

  prevAngleDriverDeg=null;
  prevAngleMapDeg.clear();

  prevDriverPos=null;
  cumDisp=0;

  prevProjState=null;
  lastProjectiles=[];

  chartSeries.force=[]; chartSeries.moment=[];
  lastChartDraw=0;

  forceStages=new Array(FILTER_ORDER).fill(0);
  momentStages=new Array(FILTER_ORDER).fill(0);

  document.getElementById('lblKinetics').innerText="F: 0 N | M: 0 Nm";
  document.getElementById('liveInterpretation').innerText="‚Äî";
}

/* =========================
   Recording store (includes projectile kinematics)
========================= */
function resetRec(){
  return {
    t:[],
    driverLinVel_mps:[],
    driverAngVel_rads:[],
    driverAngle_rad:[],
    driverDisp_m:[],
    forceFilt_N:[],
    momentFilt_Nm:[],

    // projectile kinematics
    projValid:[],
    projX_m:[], projY_m:[],
    projVx_mps:[], projVy_mps:[],
    projSpeed_mps:[],
    projAx_mps2:[], projAy_mps2:[],
    projAccel_mps2:[],
    projAngle_deg:[],

    // skill inference helpers
    effectorName:[],     // "wrist_R" / "ankle_L" etc
    effectorDist_m:[],   // distance from projectile to effector
    inferredSkill:[],    // per-frame guess (for debugging/export)

    metricsDefs:[],
    metrics:{}, // id -> array
  };
}

/* =========================
   Main loop
========================= */
async function renderLoop(ts){
  animationId=requestAnimationFrame(renderLoop);
  if(!video||video.paused||video.ended) return;

  framesInSecond++;
  const nowPerf=performance.now();
  if(nowPerf-lastFPSUpdate>=1000){
    detectedFPS=framesInSecond;
    framesInSecond=0;
    lastFPSUpdate=nowPerf;
    document.getElementById('fpsIndicator').innerText="FPS: "+detectedFPS;
  }

  frameIndex++;
  const tSec=(ts||performance.now())/1000;
  const dt=prevFrameTS?clamp(tSec-prevFrameTS, 1/240, 0.2):(1/60);
  prevFrameTS=tSec;

  let kp=null;
  try{
    const poses=await detector.estimatePoses(video,{flipHorizontal:false});
    if(poses&&poses.length&&poses[0].keypoints) kp=poses[0].keypoints;
  }catch(_){}

  // projectile
  const projMode=document.getElementById('projMode').value;
  if(projMode==="coco" && cocoModel){
    const everyN=parseInt(document.getElementById('projEveryN').value);
    if(frameIndex%everyN===0){
      try{
        const preds=await cocoModel.detect(video);
        const cls=document.getElementById('projClassHint').value;
        const minScore=parseFloat(document.getElementById('projMinScore').value);
        lastProjectiles=preds.filter(p=>p.class===cls && p.score>=minScore).sort((a,b)=>b.score-a.score).slice(0,2);
      }catch(_){}
    }
  }else lastProjectiles=[];

  // draw
  ctx.clearRect(0,0,overlay.width,overlay.height);
  if(kp) drawSkeleton(kp);
  drawProjectile(lastProjectiles, dt);

  if(kp){
    processSelectedMetrics(kp, dt);

    const projState = computeProjectileKinematics(lastProjectiles, dt);
    const kin = processDriverKinematics(kp, dt);
    const kinets = processDriverKinetics(dt, tSec, kin);

    const skill = inferSkillFromCV(kp, projState, kin);
    const liveText = buildLiveInterpretation(kin, kinets, projState, skill);
    document.getElementById('liveInterpretation').innerText = liveText;

    if(isRecording) recordFrame(tSec, kp, dt, kin, kinets, projState, skill);

    prevKeypoints=kp;
    setStatusText("Running");
  } else {
    setStatusText("No pose detected (framing/lighting)");
  }

  throttleChartDraw(tSec);
}

/* =========================
   Drawing
========================= */
function drawSkeleton(kp){
  const minScore=0.30;
  ctx.lineWidth=3;
  ctx.strokeStyle="#00ff66";

  const skeleton=[
    [KP.shoulder_L, KP.shoulder_R],
    [KP.shoulder_L, KP.elbow_L], [KP.elbow_L, KP.wrist_L],
    [KP.shoulder_R, KP.elbow_R], [KP.elbow_R, KP.wrist_R],
    [KP.shoulder_L, KP.hip_L], [KP.shoulder_R, KP.hip_R],
    [KP.hip_L, KP.hip_R],
    [KP.hip_L, KP.knee_L], [KP.knee_L, KP.ankle_L],
    [KP.hip_R, KP.knee_R], [KP.knee_R, KP.ankle_R]
  ];

  skeleton.forEach(([i,j])=>{
    if(kp[i]?.score>minScore && kp[j]?.score>minScore){
      ctx.beginPath(); ctx.moveTo(kp[i].x,kp[i].y); ctx.lineTo(kp[j].x,kp[j].y); ctx.stroke();
    }
  });

  kp.forEach(p=>{
    if(p.score>minScore){
      ctx.beginPath(); ctx.arc(p.x,p.y,5,0,2*Math.PI);
      ctx.fillStyle="red"; ctx.fill();
    }
  });
}

function drawProjectile(projs){
  if(!projs||!projs.length) return;
  ctx.save();
  ctx.lineWidth=2;
  ctx.strokeStyle="orange";
  ctx.fillStyle="orange";
  ctx.font="14px system-ui, -apple-system, Segoe UI, Roboto, Arial";

  projs.forEach(p=>{
    const [x,y,w,h]=p.bbox;
    ctx.strokeRect(x,y,w,h);
    ctx.fillText(`${p.class} ${(p.score*100).toFixed(0)}%`, x, y>18?y-6:y+18);
  });
  ctx.restore();
}

/* =========================
   Scale / indices
========================= */
function getPxToMeter(){
  const hM=currentParticipant?(currentParticipant.height/100):1.75;
  const denom=Math.max(240, overlay.height*0.80);
  return hM/denom;
}
function getJointIndex(joint, side){
  const map={
    shoulder_R:KP.shoulder_R, shoulder_L:KP.shoulder_L,
    elbow_R:KP.elbow_R, elbow_L:KP.elbow_L,
    wrist_R:KP.wrist_R, wrist_L:KP.wrist_L,
    hip_R:KP.hip_R, hip_L:KP.hip_L,
    knee_R:KP.knee_R, knee_L:KP.knee_L,
    ankle_R:KP.ankle_R, ankle_L:KP.ankle_L
  };
  const key=`${joint}_${side}`;
  return (key in map)?map[key]:null;
}

/* =========================
   Selected metrics
========================= */
function processSelectedMetrics(kp, dt){
  selectedMetrics.forEach(m=>{
    const v=computeMetricValue(kp, m, dt);
    const el=document.getElementById(`val_${m.id}`);
    if(el) el.innerText=isFinite(v)?v.toFixed(3):"--";
  });
}

function computeMetricValue(kp, m, dt){
  if(m.type==="angle") return getJointAngleDeg(kp, m.joint, m.side);
  if(m.type==="linVel"){
    const idx=getJointIndex(m.joint, m.side);
    return idx==null?NaN:getLinearVelMps(kp, idx, dt);
  }
  if(m.type==="angVel"){
    const angDeg=getJointAngleDeg(kp, m.joint, m.side);
    const prevDeg=prevAngleMapDeg.get(m.id);
    prevAngleMapDeg.set(m.id, angDeg);
    if(prevDeg==null || !isFinite(prevDeg) || !isFinite(angDeg)) return 0;

    let dDeg=angDeg-prevDeg;
    if(dDeg>180) dDeg-=360;
    if(dDeg<-180) dDeg+=360;

    const dRad = dDeg * Math.PI / 180;
    return dRad / Math.max(1e-4, dt); // rad/s
  }
  return NaN;
}

function getJointAngleDeg(kp, joint, side){
  const minScore=0.30;
  let a=null,b=null,c=null;

  if(joint==="elbow"){ a=`shoulder_${side}`; b=`elbow_${side}`; c=`wrist_${side}`; }
  else if(joint==="knee"){ a=`hip_${side}`; b=`knee_${side}`; c=`ankle_${side}`; }
  else if(joint==="hip"){ a=`shoulder_${side}`; b=`hip_${side}`; c=`knee_${side}`; }
  else if(joint==="shoulder"){ a=`hip_${side}`; b=`shoulder_${side}`; c=`elbow_${side}`; }
  else if(joint==="ankle"){ a=`knee_${side}`; b=`ankle_${side}`; c=`foot_${side}`; return NaN; } // not supported (no foot kp in MoveNet)
  else return NaN;

  const pA=kp[getJointIndex(a.split("_")[0], a.split("_")[1])];
  const pB=kp[getJointIndex(b.split("_")[0], b.split("_")[1])];
  const pC=kp[getJointIndex(c.split("_")[0], c.split("_")[1])];
  if(!pA||!pB||!pC) return NaN;
  if(pA.score<minScore||pB.score<minScore||pC.score<minScore) return NaN;

  const rad =
    Math.atan2(pC.y - pB.y, pC.x - pB.x) -
    Math.atan2(pA.y - pB.y, pA.x - pB.x);

  let deg = Math.abs(rad * 180.0 / Math.PI);
  if(deg > 180) deg = 360 - deg;
  return deg;
}

function getLinearVelMps(kp, idx, dt){
  if(!prevKeypoints || !kp[idx] || !prevKeypoints[idx]) return 0;
  const curr=kp[idx], prev=prevKeypoints[idx];
  if(curr.score<0.30 || prev.score<0.30) return 0;
  const scale=getPxToMeter();
  const dx=(curr.x-prev.x)*scale;
  const dy=(curr.y-prev.y)*scale;
  return Math.hypot(dx,dy)/Math.max(1e-4, dt);
}

/* =========================
   Driver kinematics
========================= */
function processDriverKinematics(kp, dt){
  const jName=document.getElementById('kinJoint').value;
  const side=document.getElementById('kinSide').value;
  const idx=getJointIndex(jName, side);
  if(idx==null) return null;

  const p=kp[idx];
  if(!p || p.score<0.30) return null;

  const v_mps = getLinearVelMps(kp, idx, dt);

  const angDeg = getJointAngleDeg(kp, jName, side);
  let w_radps = 0;
  if(prevAngleDriverDeg != null && isFinite(prevAngleDriverDeg) && isFinite(angDeg)){
    let dDeg = angDeg - prevAngleDriverDeg;
    if(dDeg>180) dDeg-=360;
    if(dDeg<-180) dDeg+=360;
    w_radps = (dDeg * Math.PI/180) / Math.max(1e-4, dt);
  }
  prevAngleDriverDeg = angDeg;

  const scale=getPxToMeter();
  if(prevDriverPos && prevDriverPos.ok){
    const dx=(p.x-prevDriverPos.x)*scale;
    const dy=(p.y-prevDriverPos.y)*scale;
    cumDisp += Math.hypot(dx,dy);
  }
  prevDriverPos={x:p.x,y:p.y,ok:true};

  return {
    driver: `${jName}_${side}`,
    v_mps,
    angle_rad: (isFinite(angDeg)?angDeg:0) * Math.PI/180,
    angVel_radps: w_radps,
    disp_m: cumDisp
  };
}

/* =========================
   Projectile kinematics (position/velocity/acceleration)
========================= */
function computeProjectileKinematics(projs, dt){
  const out={
    valid:false,
    x_m:0, y_m:0,
    vx_mps:0, vy_mps:0,
    ax_mps2:0, ay_mps2:0,
    speed_mps:0, accel_mps2:0,
    angle_deg:0
  };
  if(!projs || !projs.length){
    prevProjState=null;
    return out;
  }

  const best=projs[0];
  const [x,y,w,h]=best.bbox;
  const cx=x+w/2, cy=y+h/2;

  const s=getPxToMeter();
  out.valid=true;
  out.x_m = cx*s;
  out.y_m = cy*s;

  // velocity
  if(prevProjState && prevProjState.valid){
    const vx=(out.x_m - prevProjState.x_m)/Math.max(1e-4, dt);
    const vy=(out.y_m - prevProjState.y_m)/Math.max(1e-4, dt);
    // mild smoothing
    const a=0.35;
    out.vx_mps = a*vx + (1-a)*(prevProjState.vx_mps||0);
    out.vy_mps = a*vy + (1-a)*(prevProjState.vy_mps||0);
  }

  out.speed_mps = Math.hypot(out.vx_mps, out.vy_mps);

  // acceleration
  if(prevProjState && prevProjState.valid){
    const ax=(out.vx_mps - (prevProjState.vx_mps||0))/Math.max(1e-4, dt);
    const ay=(out.vy_mps - (prevProjState.vy_mps||0))/Math.max(1e-4, dt);
    const a2=0.35;
    out.ax_mps2 = a2*ax + (1-a2)*(prevProjState.ax_mps2||0);
    out.ay_mps2 = a2*ay + (1-a2)*(prevProjState.ay_mps2||0);
  }
  out.accel_mps2 = Math.hypot(out.ax_mps2, out.ay_mps2);

  out.angle_deg = Math.atan2(-out.vy_mps, out.vx_mps)*180/Math.PI;

  prevProjState = { ...out };
  return out;
}

/* =========================
   Kinetics (extra low-pass smoothing)
========================= */
function processDriverKinetics(dt, tSec, kin){
  if(!currentParticipant || !kin) return null;

  const driverJoint = kin.driver.split("_")[0];

  let seg="thigh";
  if(driverJoint==="knee") seg="shank";
  if(driverJoint==="ankle") seg="foot";
  if(driverJoint==="shoulder") seg="upperArm";
  if(driverJoint==="elbow") seg="forearm";
  if(driverJoint==="wrist") seg="hand";

  const segMass = currentParticipant.mass * (SEG_MASS[seg] || 0.10);

  const prevV = rec.driverLinVel_mps.length ? rec.driverLinVel_mps[rec.driverLinVel_mps.length-1] : kin.v_mps;
  const accel = Math.abs(kin.v_mps - prevV) / Math.max(1e-4, dt);
  const forceRaw = segMass * accel;

  const prevW = rec.driverAngVel_rads.length ? rec.driverAngVel_rads[rec.driverAngVel_rads.length-1] : kin.angVel_radps;
  const alpha = (kin.angVel_radps - prevW) / Math.max(1e-4, dt); // rad/s^2

  const L = estimateSegmentLengthM(seg);
  const k = SEG_K[seg] || 0.30;
  const I = segMass * Math.pow(k * L, 2);
  const momentRaw = I * alpha;

  const hz = parseFloat(document.getElementById('cutoffHz').value);

  const forceFilt = cascadedLowPass(forceRaw, forceStages, dt, hz);
  const momentFilt = cascadedLowPass(momentRaw, momentStages, dt, hz);

  document.getElementById('lblKinetics').innerText =
    `F: ${forceFilt.toFixed(0)} N | M: ${momentFilt.toFixed(3)} Nm`;

  pushChart('force', tSec, forceFilt);
  pushChart('moment', tSec, momentFilt);

  return { forceFilt_N: forceFilt, momentFilt_Nm: momentFilt };
}
function estimateSegmentLengthM(seg){
  const h = currentParticipant ? (currentParticipant.height/100) : 1.75;
  const frac = { thigh:0.245, shank:0.246, foot:0.152, upperArm:0.186, forearm:0.146, hand:0.108, trunk:0.288 };
  return h * (frac[seg] || 0.20);
}
function lowPass(prev, curr, dt, fc){
  const rc = 1.0 / (2 * Math.PI * fc);
  const alpha = dt / (rc + dt);
  return prev + alpha * (curr - prev);
}
function cascadedLowPass(x, stages, dt, fc){
  let y = x;
  for(let i=0;i<stages.length;i++){
    stages[i] = lowPass(stages[i], y, dt, fc);
    y = stages[i];
  }
  return y;
}

/* =========================
   CV Skill Inference (heuristics)
   - Uses projectile + closest effector (wrist/ankle)
   - Uses whether both wrists are near (two-hand)
========================= */
function inferSkillFromCV(kp, proj, kin){
  if(!proj.valid){
    return { skill:"No projectile / Unknown", confidence:0.2, effector:"‚Äî", dist_m:null, rationale:"No reliable projectile track." };
  }

  const s=getPxToMeter();
  const joints=[
    {name:"wrist_R", idx:KP.wrist_R},
    {name:"wrist_L", idx:KP.wrist_L},
    {name:"ankle_R", idx:KP.ankle_R},
    {name:"ankle_L", idx:KP.ankle_L},
  ];

  const px = proj.x_m / s, py = proj.y_m / s; // back to pixel for distance by kp coords
  const dists=[];
  joints.forEach(j=>{
    const p=kp[j.idx];
    if(p && p.score>0.30){
      const dx=(p.x-px)*s;
      const dy=(p.y-py)*s;
      dists.push({name:j.name, d:Math.hypot(dx,dy)});
    }
  });
  dists.sort((a,b)=>a.d-b.d);
  const best=dists.length?dists[0]:{name:"‚Äî",d:999};

  // check two-hand proximity
  const wr = dists.find(x=>x.name==="wrist_R")?.d ?? 999;
  const wl = dists.find(x=>x.name==="wrist_L")?.d ?? 999;
  const bothHandsNear = (wr<0.20 && wl<0.20); // 20 cm threshold (scaled)
  const ankleNear = best.name.startsWith("ankle") && best.d < 0.25;
  const wristNear = best.name.startsWith("wrist") && best.d < 0.25;

  // timing cue: high œâ (rotation) + wrist near -> throw/strike
  const w = Math.abs(kin?.angVel_radps||0);
  const vproj = proj.speed_mps;

  let skill="Unknown projectile skill";
  let confidence=0.35;
  let rationale="Projectile tracked, but pattern unclear.";

  if(ankleNear){
    skill="Kick (instep/strike)";
    confidence=0.75;
    rationale="Projectile closest to ankle during event window ‚Üí likely foot contact skill.";
  } else if(bothHandsNear){
    skill="Two-hand shot / throw";
    confidence=0.70;
    rationale="Both wrists near projectile ‚Üí likely two-hand release/shot.";
  } else if(wristNear && w>6){
    // differentiate throw vs strike via projectile angle and ‚Äúhand-path‚Äù
    if(vproj>0 && proj.angle_deg>-20 && proj.angle_deg<70){
      skill="Overhand throw / pitch";
      confidence=0.72;
      rationale="Projectile closest to wrist with high joint œâ ‚Üí likely throw-like skill.";
    } else {
      skill="Strike / swing (bat/racket-like proxy)";
      confidence=0.60;
      rationale="Wrist contact + high œâ, but projectile direction suggests strike/swing timing.";
    }
  } else if(wristNear){
    skill="Underhand toss / gentle throw";
    confidence=0.55;
    rationale="Projectile closest to wrist but œâ is low ‚Üí likely toss/placement.";
  }

  return { skill, confidence, effector: best.name, dist_m: best.d, rationale };
}

/* =========================
   Live interpretation
========================= */
function buildLiveInterpretation(kin, kinets, proj, skill){
  const parts=[];
  parts.push(`Skill guess: ${skill.skill} (conf ${skill.confidence.toFixed(2)})`);
  parts.push(`Effector: ${skill.effector} dist ${skill.dist_m!=null?skill.dist_m.toFixed(3):"‚Äî"} m`);
  if(kin){
    parts.push(`Driver: ${kin.driver}`);
    parts.push(`v [m/s]: ${kin.v_mps.toFixed(3)} | œâ [rad/s]: ${kin.angVel_radps.toFixed(3)} | Œ∏ [rad]: ${kin.angle_rad.toFixed(3)} | disp [m]: ${kin.disp_m.toFixed(3)}`);
  }
  if(proj.valid){
    parts.push(`Projectile: speed [m/s] ${proj.speed_mps.toFixed(3)} | angle [deg] ${proj.angle_deg.toFixed(1)} | a [m/s¬≤] ${proj.accel_mps2.toFixed(2)}`);
  }
  if(kinets){
    parts.push(`Force [N]: ${kinets.forceFilt_N.toFixed(0)} | Moment [Nm]: ${kinets.momentFilt_Nm.toFixed(4)}`);
  }
  parts.push(`Why: ${skill.rationale}`);
  return parts.join("\n");
}

/* =========================
   Recording
========================= */
function toggleRecording(){
  const btn=document.getElementById('recordBtn');
  if(!isRecording){
    if(!currentParticipant) return showStatus("Set a participant first.", "error");
    isRecording=true;

    rec=resetRec();
    rec.metricsDefs = selectedMetrics.map(m => ({...m, units: metricUnits(m.type)}));
    rec.metrics = {};
    rec.metricsDefs.forEach(m => rec.metrics[m.id] = []);

    prevAngleDriverDeg=null;
    prevAngleMapDeg.clear();

    prevDriverPos=null;
    cumDisp=0;

    prevProjState=null;

    forceStages=new Array(FILTER_ORDER).fill(0);
    momentStages=new Array(FILTER_ORDER).fill(0);

    btn.textContent="Stop Recording";
    btn.className="btn btn-danger";
    showStatus("Recording started...", "info");
    setStatusText("Recording...");
  } else {
    isRecording=false;
    btn.textContent="Start Recording";
    btn.className="btn btn-success";
    showStatus(`Recording saved. ${rec.t.length} samples.`, "success");
    setStatusText("Running");
  }
}

function recordFrame(tSec, kp, dt, kin, kinets, proj, skill){
  if(!kin) return;

  rec.t.push(tSec);

  rec.driverLinVel_mps.push(kin.v_mps || 0);
  rec.driverAngVel_rads.push(kin.angVel_radps || 0);
  rec.driverAngle_rad.push(kin.angle_rad || 0);
  rec.driverDisp_m.push(kin.disp_m || 0);

  rec.forceFilt_N.push(kinets?.forceFilt_N || 0);
  rec.momentFilt_Nm.push(kinets?.momentFilt_Nm || 0);

  // projectile
  rec.projValid.push(proj.valid?1:0);
  rec.projX_m.push(proj.valid?proj.x_m:0);
  rec.projY_m.push(proj.valid?proj.y_m:0);
  rec.projVx_mps.push(proj.valid?proj.vx_mps:0);
  rec.projVy_mps.push(proj.valid?proj.vy_mps:0);
  rec.projSpeed_mps.push(proj.valid?proj.speed_mps:0);
  rec.projAx_mps2.push(proj.valid?proj.ax_mps2:0);
  rec.projAy_mps2.push(proj.valid?proj.ay_mps2:0);
  rec.projAccel_mps2.push(proj.valid?proj.accel_mps2:0);
  rec.projAngle_deg.push(proj.valid?proj.angle_deg:0);

  // skill inference logging
  rec.effectorName.push(skill.effector||"‚Äî");
  rec.effectorDist_m.push(isFinite(skill.dist_m)?skill.dist_m:0);
  rec.inferredSkill.push(skill.skill||"Unknown");

  // selected metrics
  if(rec.metricsDefs && rec.metrics){
    rec.metricsDefs.forEach(m=>{
      let val = computeMetricValue(kp, m, dt);
      if(!isFinite(val)) val = 0;
      rec.metrics[m.id].push(val);
    });
  }
}

/* =========================
   Snapshot
========================= */
function snapshotPNG(){
  if(!video || video.paused) return showStatus("Start Camera/Upload first.", "error");
  const c=document.createElement('canvas');
  const w=overlay.width, h=overlay.height;
  c.width=w; c.height=h;
  const g=c.getContext('2d');
  try{ g.drawImage(video,0,0,w,h); }catch(_){}
  try{ g.drawImage(overlay,0,0,w,h); }catch(_){}

  const a=document.createElement('a');
  a.href=c.toDataURL("image/png");
  a.download=`snapshot_${Date.now()}.png`;
  a.click();
}

/* =========================
   Phases (skill-aware event segmentation)
   Events:
   - peak projectile speed
   - peak driver œâ
   - inferred "release/contact": when effector distance increases sharply while projectile valid
========================= */
function segmentPhases(rec){
  const n=rec.t.length;
  if(n<12) return { events:{}, list:[{name:"Full",i0:0,i1:n-1}] };

  const peakProjIdx = argMaxAbsWhere(rec.projSpeed_mps, rec.projValid);
  const peakProjSpeed = peakProjIdx>=0?Math.abs(rec.projSpeed_mps[peakProjIdx]):0;

  const peakAngVelIdx = argMaxAbs(rec.driverAngVel_rads);
  const peakAngVel = Math.abs(rec.driverAngVel_rads[peakAngVelIdx]||0);

  // release/contact: big rise in effector distance
  let releaseIdx = -1;
  for(let i=2;i<n;i++){
    if((rec.projValid[i]||0)!==1) continue;
    const d0=rec.effectorDist_m[i-1]||0;
    const d1=rec.effectorDist_m[i]||0;
    if(d1-d0 > 0.06){ // 6 cm jump = separation event
      releaseIdx = i;
      break;
    }
  }
  if(releaseIdx<0) releaseIdx = (peakProjIdx>=0?peakProjIdx:peakAngVelIdx);

  const wRel=Math.max(3, Math.floor(n*0.08));
  const wAng=Math.max(3, Math.floor(n*0.10));

  const prepEnd = clampInt(Math.min(releaseIdx, peakAngVelIdx)-2, 0, n-1);

  const phases = [
    { name:"Preparation", i0:0, i1:prepEnd },
    { name:"Acceleration", i0:clampInt(peakAngVelIdx-wAng,0,n-1), i1:clampInt(peakAngVelIdx+wAng,0,n-1) },
    { name:"Release/Contact", i0:clampInt(releaseIdx-wRel,0,n-1), i1:clampInt(releaseIdx+wRel,0,n-1) },
    { name:"Follow-through", i0:clampInt(releaseIdx+wRel,0,n-1), i1:n-1 }
  ];

  return {
    events:{ peakProjIdx, peakProjSpeed, peakAngVelIdx, peakAngVel, releaseIdx },
    list: phases
  };
}

/* =========================
   XLSX Export (adds projectile summary)
========================= */
function downloadData(){
  if(!rec.t.length) return showStatus("No recorded data. Press Start Recording first.", "error");

  const profile=currentParticipant || participants[0] || {name:"",sex:"",age:"",mass:"",height:""};
  const driver = `${document.getElementById('kinJoint').value}_${document.getElementById('kinSide').value}`;
  const phasesObj = segmentPhases(rec);

  // Skill (overall): majority vote
  const skillOverall = mode(rec.inferredSkill);

  // 1) Profile
  const profileRows = [
    { field:"name", value: profile.name },
    { field:"sex", value: profile.sex },
    { field:"age", value: profile.age },
    { field:"mass_kg", value: profile.mass },
    { field:"height_cm", value: profile.height },
    { field:"driver_joint", value: driver },
    { field:"skill_inferred_overall", value: skillOverall },
    { field:"source", value: sessionMeta.source || "" },
    { field:"camera_facing", value: sessionMeta.facing || "" },
    { field:"fps_requested", value: sessionMeta.fpsRequested || "" },
    { field:"fps_detected_est", value: detectedFPS || "" },
    { field:"started_at", value: sessionMeta.startedAt || "" },
    { field:"notes", value:"œâ in [rad/s]. Angles/ROM exported as [rad]. Projectile motion exported. Kinetics are simplified proxies (trend)."}
  ];

  // 2) Kinematics summary (driver + selected metrics)
  const kinSummaryRows = [];
  kinSummaryRows.push(driverSummary("Overall", driver, {i0:0,i1:rec.t.length-1}, phasesObj, skillOverall));
  phasesObj.list.forEach(ph => kinSummaryRows.push(driverSummary(ph.name, driver, ph, phasesObj, skillOverall)));

  if(rec.metricsDefs && rec.metricsDefs.length){
    kinSummaryRows.push({ phase:"‚Äî", driver_joint:"‚Äî", metric_name:"Selected metrics (phase summaries below)", metric_unit:"", metric_peak:"", metric_avg:"", metric_ROM_if_angle_rad:"" });
    rec.metricsDefs.forEach(def=>{
      kinSummaryRows.push(metricSummary(def, "Overall", {i0:0,i1:rec.t.length-1}));
      phasesObj.list.forEach(ph=>kinSummaryRows.push(metricSummary(def, ph.name, ph)));
    });
  }

  // 2b) Kinematics time-series (includes projectile kinematics)
  const kinTSRows=[];
  for(let i=0;i<rec.t.length;i++){
    const row={
      "time_s": round(rec.t[i],4),
      "driver_linVel[m/s]": round(rec.driverLinVel_mps[i]||0,6),
      "driver_angVel[rad/s]": round(rec.driverAngVel_rads[i]||0,6),
      "driver_angle[rad]": round(rec.driverAngle_rad[i]||0,6),
      "driver_disp[m]": round(rec.driverDisp_m[i]||0,6),

      "projectile_valid[0/1]": rec.projValid[i]||0,
      "proj_x[m]": round(rec.projX_m[i]||0,6),
      "proj_y[m]": round(rec.projY_m[i]||0,6),
      "proj_vx[m/s]": round(rec.projVx_mps[i]||0,6),
      "proj_vy[m/s]": round(rec.projVy_mps[i]||0,6),
      "proj_speed[m/s]": round(rec.projSpeed_mps[i]||0,6),
      "proj_ax[m/s^2]": round(rec.projAx_mps2[i]||0,6),
      "proj_ay[m/s^2]": round(rec.projAy_mps2[i]||0,6),
      "proj_accel[m/s^2]": round(rec.projAccel_mps2[i]||0,6),
      "proj_angle[deg]": round(rec.projAngle_deg[i]||0,3),

      "effector": rec.effectorName[i]||"‚Äî",
      "effector_dist[m]": round(rec.effectorDist_m[i]||0,6),
      "skill_guess": rec.inferredSkill[i]||"Unknown"
    };

    if(rec.metricsDefs && rec.metrics){
      rec.metricsDefs.forEach(def=>{
        const val = (rec.metrics[def.id] && rec.metrics[def.id][i]!=null) ? rec.metrics[def.id][i] : 0;
        if(def.type==="angle") row[`${def.id}[rad]`] = round((val*Math.PI/180),6);
        else if(def.type==="angVel") row[`${def.id}[rad/s]`] = round(val,6);
        else row[`${def.id}[m/s]`] = round(val,6);
      });
    }

    kinTSRows.push(row);
  }

  // 2c) Projectile summary by phase
  const projSummaryRows=[];
  projSummaryRows.push(projectileSummary("Overall", {i0:0,i1:rec.t.length-1}));
  phasesObj.list.forEach(ph=>projSummaryRows.push(projectileSummary(ph.name, ph)));

  // 3) Kinetics time-series
  const kineticsRows = rec.t.map((t,i)=>({
    "time_s": round(t,4),
    "Force_filt[N]": round(rec.forceFilt_N[i]||0,6),
    "Moment_filt[Nm]": round(rec.momentFilt_Nm[i]||0,8)
  }));

  // 4) Technical model / recommendations (skill-aware)
  const modelRows = buildTechnicalModel(skillOverall, driver, phasesObj);

  const wb=XLSX.utils.book_new();
  XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet(profileRows), "1_Profile");
  XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet(kinSummaryRows), "2_Kinematics_Summary");
  XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet(kinTSRows), "2b_Kinematics_TimeSeries");
  XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet(projSummaryRows), "2c_Projectile_Summary");
  XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet(kineticsRows), "3_Kinetics_ForceMoment_Time");
  XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet(modelRows), "4_Technical_Model");

  const fname=`sport_analysis_${(profile.name||"participant").replace(/\s+/g,"_")}_${Date.now()}.xlsx`;
  XLSX.writeFile(wb, fname);
  showStatus("XLSX exported (skill-aware phases + projectile kinematics).", "success");
}

/* =========================
   Summary helpers
========================= */
function driverSummary(label, driver, ph, phasesObj, skillOverall){
  const i0=ph.i0, i1=ph.i1;
  const tt=rec.t.slice(i0,i1+1);
  const dur=tt.length?(tt[tt.length-1]-tt[0]):0;

  const v = rec.driverLinVel_mps.slice(i0,i1+1);
  const w = rec.driverAngVel_rads.slice(i0,i1+1);
  const ang = rec.driverAngle_rad.slice(i0,i1+1);
  const disp = rec.driverDisp_m.slice(i0,i1+1);

  const rom = ang.length?(Math.max(...ang)-Math.min(...ang)):0;
  const dispNet = disp.length?(disp[disp.length-1]-disp[0]):0;

  const projSpeed = rec.projSpeed_mps.slice(i0,i1+1);
  const projOk = rec.projValid.slice(i0,i1+1);
  let peakProj=0;
  for(let i=0;i<projSpeed.length;i++){
    if((projOk[i]||0)===1) peakProj=Math.max(peakProj, Math.abs(projSpeed[i]||0));
  }

  const ev = phasesObj.events||{};
  const note = (label==="Overall")
    ? `Skill inferred: ${skillOverall}. Events: peakProjSpeed=${round(ev.peakProjSpeed,3)}m/s@${ev.peakProjIdx}, peakœâ=${round(ev.peakAngVel,3)}rad/s@${ev.peakAngVelIdx}, release/contact@${ev.releaseIdx}`
    : "";

  return {
    phase: label,
    driver_joint: driver,
    duration_s: round(dur,3),
    "peak_linVel[m/s]": round(maxAbs(v),6),
    "avg_linVel[m/s]": round(mean(v),6),
    "peak_angVel[rad/s]": round(maxAbs(w),6),
    "avg_angVel[rad/s]": round(mean(w),6),
    "ROM_angDisp[rad]": round(rom,6),
    "avg_angle[rad]": round(mean(ang),6),
    "displacement[m]": round(dispNet,6),
    "peak_projectile_speed[m/s]": round(peakProj,6),
    notes: note
  };
}

function metricSummary(def, label, ph){
  const i0=ph.i0, i1=ph.i1;
  const arr = rec.metrics[def.id] ? rec.metrics[def.id].slice(i0,i1+1) : [];
  const tt  = rec.t.slice(i0,i1+1);
  const dur = tt.length?(tt[tt.length-1]-tt[0]):0;

  let series = arr;
  let unit = def.type==="linVel"?"m/s":(def.type==="angVel"?"rad/s":"rad");
  if(def.type==="angle"){
    series = arr.map(x => (x||0) * Math.PI/180);
  }

  const peak=maxAbs(series);
  const avg=mean(series);
  const rom = (def.type==="angle" && series.length) ? (Math.max(...series)-Math.min(...series)) : "";

  return {
    phase: label,
    driver_joint: "selected_metric",
    duration_s: round(dur,3),
    metric_name: `${def.type}_${def.joint}_${def.side}`,
    metric_unit: `[${unit}]`,
    metric_peak: round(peak,6),
    metric_avg: round(avg,6),
    metric_ROM_if_angle_rad: (def.type==="angle") ? round(rom,6) : ""
  };
}

function projectileSummary(label, ph){
  const i0=ph.i0, i1=ph.i1;
  const ok = rec.projValid.slice(i0,i1+1);
  const sp = rec.projSpeed_mps.slice(i0,i1+1);
  const ang = rec.projAngle_deg.slice(i0,i1+1);
  const acc = rec.projAccel_mps2.slice(i0,i1+1);

  let spVals=[], angVals=[], accVals=[];
  for(let i=0;i<ok.length;i++){
    if((ok[i]||0)===1){
      spVals.push(Math.abs(sp[i]||0));
      angVals.push(ang[i]||0);
      accVals.push(Math.abs(acc[i]||0));
    }
  }

  return {
    phase: label,
    projectile_samples: spVals.length,
    "peak_speed[m/s]": round(maxAbs(spVals),6),
    "avg_speed[m/s]": round(mean(spVals),6),
    "avg_launch_angle[deg]": round(mean(angVals),3),
    "peak_accel[m/s^2]": round(maxAbs(accVals),6),
    "avg_accel[m/s^2]": round(mean(accVals),6)
  };
}

/* =========================
   Technical model (skill-aware)
========================= */
function buildTechnicalModel(skillOverall, driver, phasesObj){
  const ev=phasesObj.events||{};
  const peakV = maxAbs(rec.driverLinVel_mps);
  const peakW = maxAbs(rec.driverAngVel_rads);
  const rom = rec.driverAngle_rad.length?(Math.max(...rec.driverAngle_rad)-Math.min(...rec.driverAngle_rad)):0;
  const dispNet = rec.driverDisp_m.length?(rec.driverDisp_m[rec.driverDisp_m.length-1]-rec.driverDisp_m[0]):0;
  const peakF = maxAbs(rec.forceFilt_N);
  const peakM = maxAbs(rec.momentFilt_Nm);

  const peakProj = (ev.peakProjSpeed!=null)?ev.peakProjSpeed:maxAbsWhere(rec.projSpeed_mps, rec.projValid);
  const avgProjAng = mean(rec.projAngle_deg.filter((_,i)=>rec.projValid[i]===1));

  const rows=[];
  rows.push({ section:"Skill inference", item:"Skill (CV heuristic)", value: skillOverall });
  rows.push({ section:"Event markers", item:"Peak projectile speed [m/s]", value: round(peakProj,6) });
  rows.push({ section:"Event markers", item:"Peak driver œâ [rad/s]", value: round(ev.peakAngVel||peakW,6) });
  rows.push({ section:"Event markers", item:"Release/contact index", value: ev.releaseIdx ?? "" });
  rows.push({ section:"Projectile", item:"Average launch angle [deg]", value: round(avgProjAng||0,3) });

  rows.push({ section:"Kinematics", item:"Driver joint", value: driver });
  rows.push({ section:"Kinematics", item:"Peak v [m/s]", value: round(peakV,6) });
  rows.push({ section:"Kinematics", item:"Peak œâ [rad/s]", value: round(peakW,6) });
  rows.push({ section:"Kinematics", item:"ROM [rad]", value: round(rom,6) });
  rows.push({ section:"Kinematics", item:"Displacement [m]", value: round(dispNet,6) });

  rows.push({ section:"Kinetics", item:"Peak Force (filtered) [N]", value: round(peakF,3) });
  rows.push({ section:"Kinetics", item:"Peak Moment (filtered) [Nm]", value: round(peakM,6) });

  const recos = buildRecommendations(skillOverall, {peakV, peakW, rom, dispNet, peakF, peakM, peakProj, avgProjAng, ev});
  recos.forEach((t,i)=>rows.push({ section:"Recommendations", item:`R${i+1}`, value:t }));

  rows.push({ section:"Notes", item:"Method", value:"Skill inference uses projectile + closest effector (ankle/wrist) + œâ magnitude. Use as guidance, not diagnosis." });
  return rows;
}

function buildRecommendations(skill, x){
  const out=[];
  const {peakW, peakProj, avgProjAng, peakM, peakF} = x;

  if(skill.includes("Kick")){
    out.push("Kick: prioritize proximal-to-distal sequencing (hip ‚Üí knee ‚Üí ankle). If peak œâ is low, work on swing speed + stiffness at contact.");
    out.push("Projectile: if launch angle is inconsistent, adjust foot contact point and approach angle; aim repeatable launch angle for your target (low drive vs loft).");
    out.push("Training: banded hip flexor swings, A-skips ‚Üí fast leg cycles, resisted instep strikes, and decel (hamstring eccentrics) to control follow-through.");
  } else if(skill.includes("Overhand throw") || skill.includes("pitch")){
    out.push("Throw: aim for earlier trunk rotation and a clean hand-path; peak œâ should typically occur just before peak projectile speed (release).");
    out.push("If Moment spikes (high Nm), add eccentric decel + scapular stability work; keep shoulder/elbow loads controlled.");
    out.push("Training: med-ball rotational throws, step-behind throws, cuff/scap circuits, decel drills (catch-and-stick), progressive intent throwing.");
  } else if(skill.includes("Two-hand")){
    out.push("Two-hand release: improve timing of knee/hip extension with arm extension; avoid late arm-only push.");
    out.push("Projectile: if angle too high/low, cue 'finish to target' and adjust release height; monitor peak speed vs consistency.");
    out.push("Training: jump-to-reach sequencing drills, tempo reps (70‚Äì85%), then intent reps; core anti-extension/anti-rotation for stability.");
  } else if(skill.includes("Strike") || skill.includes("swing")){
    out.push("Strike/swing: build rotational speed but keep contact timing consistent‚Äîpeak hand speed should align close to contact/release.");
    out.push("Projectile: if speed is high but angle is off, adjust bat/racket path and contact point; focus on repeatable launch angle windows.");
    out.push("Training: rotational med-ball slams, cable rotations, overloaded/underloaded swings, and braking strength (obliques/hips) to reduce late collapse.");
  } else {
    out.push("Unknown skill: keep the approach event-based‚Äîuse peak projectile speed and peak œâ to check sequencing.");
    out.push("If peak Force/Moment are noisy, increase lighting, stabilize camera, and ensure projectile is large in frame. Consider using higher FPS uploads.");
  }

  // Generic safety cues
  if(peakM > 3) out.push("High Moment trend: add eccentric control + reduce late snap; progress volume gradually.");
  if(peakF > 300) out.push("High Force trend: check technique and braking; consider softer contact strategy and strength for deceleration.");
  if(peakProj > 0 && (avgProjAng > 80 || avgProjAng < -20)) out.push("Projectile angle extreme: likely tracking/plane issue‚Äîreposition camera perpendicular to motion plane and keep projectile visible.");

  return out.slice(0,8);
}

/* =========================
   Charts
========================= */
function pushChart(key, t, v){
  const win=parseInt(document.getElementById('windowSeconds').value);
  chartSeries[key].push({t, v});
  while(chartSeries[key].length && chartSeries[key][0].t < t-win) chartSeries[key].shift();
}
function throttleChartDraw(t){
  if(t-lastChartDraw < 0.1) return;
  lastChartDraw = t;
  drawDualAxisChart('chartDual');
}
function drawDualAxisChart(id){
  const c=document.getElementById(id);
  const g=c.getContext('2d');
  const w=c.width=c.clientWidth;
  const h=c.height=c.clientHeight;
  g.clearRect(0,0,w,h);

  g.strokeStyle="#eee";
  g.beginPath(); g.moveTo(0,h/2); g.lineTo(w,h/2); g.stroke();

  const fData = chartSeries.force;
  const mData = chartSeries.moment;
  if(!fData.length || !mData.length) return;

  const win=parseInt(document.getElementById('windowSeconds').value);
  const now = Math.max(fData[fData.length-1].t, mData[mData.length-1].t);

  let fMax=1, mMax=1;
  fData.forEach(d=>{ fMax=Math.max(fMax, Math.abs(d.v)); });
  mData.forEach(d=>{ mMax=Math.max(mMax, Math.abs(d.v)); });

  g.strokeStyle="#667eea"; g.lineWidth=2; g.beginPath();
  fData.forEach((pt,i)=>{
    const x=((win-(now-pt.t))/win)*w;
    const y=h-((pt.v/(fMax*1.2))*(h/2)+h/2);
    if(i===0) g.moveTo(x,y); else g.lineTo(x,y);
  });
  g.stroke();

  g.strokeStyle="#ef4444"; g.lineWidth=2; g.beginPath();
  mData.forEach((pt,i)=>{
    const x=((win-(now-pt.t))/win)*w;
    const y=h-((pt.v/(mMax*1.2))*(h/2)+h/2);
    if(i===0) g.moveTo(x,y); else g.lineTo(x,y);
  });
  g.stroke();

  g.fillStyle="#666";
  g.font="12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
  g.fillText("Force [N] (left)", 10, 14);
  const txt="Moment [Nm] (right)";
  const tw=g.measureText(txt).width;
  g.fillText(txt, w - tw - 10, 14);
}

/* =========================
   UI metric selection
========================= */
function addMetric(){
  const type=document.getElementById('metricType').value;
  const joint=document.getElementById('metricJoint').value;
  const side=document.getElementById('metricSide').value;
  const id=`${type}_${joint}_${side}`;
  if(!selectedMetrics.find(m=>m.id===id)){
    selectedMetrics.push({id,type,joint,side});
    renderMetricChips();
  }
}
function removeMetric(id){ selectedMetrics=selectedMetrics.filter(m=>m.id!==id); renderMetricChips(); }
function clearMetrics(){ selectedMetrics=[]; renderMetricChips(); }

function renderMetricChips(){
  const chips=document.getElementById('metricChips');
  const panel=document.getElementById('selectedMetricsPanel');
  chips.innerHTML=""; panel.innerHTML="";
  selectedMetrics.forEach(m=>{
    const label = (m.type==="angVel") ? `${m.type} ${m.joint} ${m.side} [rad/s]`
                 : (m.type==="linVel") ? `${m.type} ${m.joint} ${m.side} [m/s]`
                 : `${m.type} ${m.joint} ${m.side} [deg]`;

    const chip=document.createElement('div');
    chip.className="chip";
    chip.innerHTML=`${label} <button onclick="removeMetric('${m.id}')">‚úï</button>`;
    chips.appendChild(chip);

    const card=document.createElement('div');
    card.className="metric";
    card.innerHTML=`
      <div class="t">${label}</div>
      <div class="v" id="val_${m.id}">--</div>
      <div class="s">${metricHint(m)}</div>
    `;
    panel.appendChild(card);
  });
}
function metricHint(m){
  if(m.type==="linVel") return "Linear velocity [m/s] from 2D displacement / dt.";
  if(m.type==="angVel") return "Angular velocity [rad/s] from ŒîŒ∏(rad)/dt.";
  if(m.type==="angle") return "Angle shown in [deg] live; exported as [rad] in XLSX.";
  return "";
}
function metricUnits(type){
  if(type==="linVel") return "m/s";
  if(type==="angVel") return "rad/s";
  if(type==="angle") return "deg";
  return "";
}

/* =========================
   Collapsible + PiP + status
========================= */
function toggleCollapse(id){
  const el=document.getElementById(id);
  el.classList.toggle('collapsed');
  document.getElementById(id+'_lbl').innerText = el.classList.contains('collapsed') ? "Expand" : "Collapse";
}
function togglePiP(){ document.body.classList.toggle('pip-on'); }

function showStatus(msg,type){
  const el=document.getElementById('statusMessage');
  el.innerText=msg;
  el.className=`status-message status-${type}`;
  el.style.display='block';
  setTimeout(()=>el.style.display='none', 3000);
}
function setStatusText(t){ document.getElementById('statusText').innerText=t; }
function setSourceText(t){ document.getElementById('sourceText').innerText=t; }

/* =========================
   Utils
========================= */
function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }
function clampInt(x,a,b){ return Math.max(a, Math.min(b, Math.round(x))); }
function round(x,dp){ if(!isFinite(x)) return 0; const p=Math.pow(10,dp); return Math.round(x*p)/p; }
function mean(arr){ if(!arr || !arr.length) return 0; return arr.reduce((s,x)=>s+(+x||0),0)/arr.length; }
function maxAbs(arr){ if(!arr || !arr.length) return 0; let m=0; arr.forEach(x=>{ const a=Math.abs(+x||0); if(a>m) m=a; }); return m; }
function argMaxAbs(arr){
  let best=0, bestV=-1;
  for(let i=0;i<(arr||[]).length;i++){
    const a=Math.abs(+arr[i]||0);
    if(a>bestV){ bestV=a; best=i; }
  }
  return best;
}
function argMaxAbsWhere(arr, mask){
  let best=-1, bestV=-1;
  for(let i=0;i<(arr||[]).length;i++){
    if((mask[i]||0)!==1) continue;
    const a=Math.abs(+arr[i]||0);
    if(a>bestV){ bestV=a; best=i; }
  }
  return best;
}
function maxAbsWhere(arr, mask){
  let m=0;
  for(let i=0;i<(arr||[]).length;i++){
    if((mask[i]||0)!==1) continue;
    m=Math.max(m, Math.abs(arr[i]||0));
  }
  return m;
}
function mode(arr){
  const f=new Map();
  (arr||[]).forEach(x=>{
    const k=(x||"").toString();
    f.set(k,(f.get(k)||0)+1);
  });
  let best=""; let bestC=-1;
  f.forEach((c,k)=>{ if(c>bestC){ bestC=c; best=k; } });
  return best || "Unknown";
}
</script>
</body>
</html>
