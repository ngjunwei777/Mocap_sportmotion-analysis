<!--
¬© 2025 Ng Jun Wei
All rights reserved.

This source code and associated assets are proprietary.
Unauthorized copying, modification, distribution, or use is prohibited
without prior written permission from Ng Jun Wei.
-->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <meta name="author" content="Ng Jun Wei">
  <meta name="copyright" content="¬© 2025 Ng Jun Wei. All rights reserved.">
  <title>Sport Performance Analyzer (iOS) + Joint-Driven Kinetics</title>

  <!-- TFJS + Pose -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.11.0"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@2.1.0"></script>

  <!-- Projectile detector -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.3"></script>

  <!-- XLSX export -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

  <style>
    * { margin:0; padding:0; box-sizing:border-box; }
    body{
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 14px;
    }
    .container{
      max-width: 1400px;
      margin: 0 auto;
      background:#fff;
      border-radius: 18px;
      padding: 16px;
      box-shadow: 0 18px 55px rgba(0,0,0,0.22);
    }
    h1 { text-align:center; color:#667eea; margin-bottom:6px; font-size:2.05em; }
    .subtitle{ text-align:center; color:#666; margin-bottom:14px; font-size:1.02em; }

    .layout{
      display:grid;
      grid-template-columns: 1.08fr 0.92fr;
      gap: 14px;
      align-items:start;
    }
    @media (max-width: 980px){ .layout{ grid-template-columns: 1fr; } }

    .card{ background:#f8f9fa; border-radius: 14px; padding: 14px; }
    .form-grid{
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(190px, 1fr));
      gap: 10px;
      margin-top: 10px;
    }
    label{ font-weight: 850; margin-bottom: 6px; color:#333; display:block; }
    input, select{
      width:100%;
      padding: 10px;
      border: 2px solid #ddd;
      border-radius: 12px;
      font-size: 14px;
      background:#fff;
    }
    input:focus, select:focus{ outline:none; border-color:#667eea; }

    .btn{
      padding: 11px 14px;
      border: none;
      border-radius: 12px;
      font-size: 14px;
      font-weight: 900;
      cursor:pointer;
      margin: 8px 8px 0 0;
      transition: transform .15s, opacity .15s;
    }
    .btn:hover{ transform: translateY(-1px); }
    .btn:disabled{ background:#cfcfcf !important; cursor:not-allowed; opacity:.85; transform:none; }
    .btn-primary{ background:#667eea; color:#fff; }
    .btn-success{ background:#10b981; color:#fff; }
    .btn-danger { background:#ef4444; color:#fff; }

    .status-message{
      display:none;
      text-align:center;
      padding: 10px 12px;
      border-radius: 12px;
      font-weight: 950;
      margin: 10px 0 14px 0;
    }
    .status-success{ background:#d1fae5; color:#065f46; }
    .status-error{ background:#fee2e2; color:#991b1b; }
    .status-info{ background:#dbeafe; color:#1e40af; }

    /* Desktop sticky */
    .sticky{ position: sticky; top: 8px; }
    @media (max-width: 980px){ .sticky{ top: 0; z-index: 50; } }

    .video-wrap{ position:relative; background:#000; border-radius: 14px; overflow:hidden; }
    video{
      width:100%;
      height:auto;
      display:block;
      position:relative;
      z-index:1;
      transform: translateZ(0);
      -webkit-transform: translateZ(0);
    }
    canvas#overlay{
      width:100%;
      height:auto;
      display:block;
      position:absolute;
      left:0; top:0;
      z-index:5;
      pointer-events:none;
    }
    .hud{
      position:absolute;
      top: 10px; right: 10px;
      z-index: 10;
      background: rgba(0,0,0,0.72);
      color:#fff;
      padding: 6px 10px;
      border-radius: 12px;
      font-size: 13px;
      font-weight: 950;
      display:flex;
      flex-direction: column;
      gap:6px;
      align-items:flex-end;
      max-width: 95%;
    }
    .hud small{ font-weight: 850; opacity: .92; }

    .divider{ height:1px; background:#e9e9e9; margin: 12px 0; }
    .mini{ color:#666; font-size: .88em; line-height: 1.35; margin-top: 8px; }

    .metrics-grid{
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 10px;
      margin-top: 10px;
    }
    .metric{
      background:#fff;
      border-radius: 14px;
      padding: 12px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.06);
    }
    .metric .t{ color:#666; font-weight:850; font-size:.92em; margin-bottom: 6px; }
    .metric .v{ color:#667eea; font-weight: 1000; font-size: 1.55em; }
    .unit{ color:#999; font-weight: 900; font-size: .75em; margin-left: 6px; }

    .chiplist{ margin-top: 10px; display:flex; flex-wrap:wrap; gap: 8px; }
    .chip{
      background:#fff;
      border-radius: 999px;
      padding: 8px 10px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.06);
      display:flex;
      align-items:center;
      gap: 10px;
      font-weight: 900;
      color:#333;
      font-size: 13px;
    }
    .chip button{
      border:none;
      background: rgba(239,68,68,0.12);
      color:#ef4444;
      font-weight: 1000;
      border-radius: 999px;
      padding: 4px 8px;
      cursor:pointer;
    }

    .charts-grid{ display:grid; grid-template-columns: 1fr; gap: 12px; margin-top: 10px; }
    .chart-card{
      background:#fff;
      border-radius: 14px;
      padding: 12px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.06);
    }
    .chart-title{
      display:flex;
      justify-content: space-between;
      align-items:center;
      gap: 10px;
      margin-bottom: 8px;
    }
    .chart-title b{ color:#222; }
    .chart-title span{ color:#666; font-weight: 850; font-size: .9em; }
    canvas.chart{
      width: 100%;
      height: 150px;
      display:block;
      border-radius: 12px;
      background: #fafafa;
    }

    .participants-list .item{
      background:#fff;
      border-radius: 14px;
      padding: 12px;
      margin-top: 10px;
      display:flex;
      justify-content: space-between;
      gap: 12px;
      align-items:center;
      box-shadow: 0 2px 10px rgba(0,0,0,0.06);
    }

    footer{
      margin-top: 14px;
      text-align:center;
      color:#666;
      font-weight: 850;
      font-size: 0.92em;
    }

    /* ========= Mobile PiP (Always Visible Video) ========= */
    .pip-toggle{ display:none; margin-top: 10px; }

    @media (max-width: 980px) {
      /* sticky is unreliable on iOS inside grids; use PiP */
      .sticky{ position: static; }
      .pip-toggle{ display:inline-block; }

      body.pip-on .sticky .card{
        position: fixed;
        left: 12px;
        right: 12px;
        bottom: 12px;
        z-index: 9999;
        padding: 10px;
        box-shadow: 0 18px 55px rgba(0,0,0,0.35);
        max-width: 520px;
        margin: 0 auto;
      }

      body.pip-on .container{
        padding-bottom: 260px; /* space so PiP doesn't hide content */
      }
    }

    @supports (padding: max(0px)) {
      @media (max-width: 980px) {
        body.pip-on .sticky .card{
          bottom: max(12px, env(safe-area-inset-bottom));
          left: max(12px, env(safe-area-inset-left));
          right: max(12px, env(safe-area-inset-right));
        }
      }
    }
  </style>
</head>

<body>
<div class="container">
  <h1>üèÉ‚Äç‚ôÇÔ∏è Mocap Sport Analysis</h1>
  <p class="subtitle">iOS-safe overlay ‚Ä¢ selectable metrics ‚Ä¢ joint-driven Force‚ÄìTime & Moment‚ÄìTime ‚Ä¢ projectile tracking</p>

  <div id="statusMessage" class="status-message"></div>

  <div class="layout">
    <!-- LEFT -->
    <div>
      <div class="card">
        <h3>Participant</h3>

        <div class="form-grid">
          <div>
            <label for="participantName">Name *</label>
            <input id="participantName" placeholder="Enter name">
          </div>
          <div>
            <label for="participantSex">Sex *</label>
            <select id="participantSex">
              <option value="">Select</option>
              <option value="male">Male</option>
              <option value="female">Female</option>
              <option value="other">Other</option>
            </select>
          </div>
          <div>
            <label for="participantAge">Age *</label>
            <input id="participantAge" type="number" min="5" max="120" placeholder="Age">
          </div>
          <div>
            <label for="participantMass">Mass (kg) *</label>
            <input id="participantMass" type="number" min="20" max="300" step="0.1" placeholder="kg">
          </div>
          <div>
            <label for="participantHeight">Height (cm) *</label>
            <input id="participantHeight" type="number" min="50" max="250" step="0.1" placeholder="cm">
          </div>
        </div>

        <button class="btn btn-success" onclick="addParticipant()">Add Participant</button>

        <div class="divider"></div>

        <label for="selectedParticipant">Select Participant for Recording</label>
        <select id="selectedParticipant"></select>

        <div class="form-grid">
          <div>
            <label for="fpsSelection">Requested FPS</label>
            <select id="fpsSelection">
              <option value="30">30 FPS</option>
              <option value="60">60 FPS</option>
              <option value="120">120 FPS</option>
              <option value="240">240 FPS</option>
            </select>
          </div>
          <div>
            <label for="cameraFacing">Camera</label>
            <select id="cameraFacing">
              <option value="environment">Back</option>
              <option value="user">Front</option>
            </select>
          </div>
          <div>
            <label for="planeSelection">Plane</label>
            <select id="planeSelection">
              <option value="sagittal">Sagittal</option>
              <option value="frontal">Frontal</option>
              <option value="transverse">Transverse (2D proxy)</option>
            </select>
          </div>
          <div>
            <label for="windowSeconds">Chart Window</label>
            <select id="windowSeconds">
              <option value="5">5s</option>
              <option value="10" selected>10s</option>
              <option value="15">15s</option>
              <option value="20">20s</option>
            </select>
          </div>
          <div>
            <label for="cutoffHz">Low-pass Cutoff (Hz)</label>
            <select id="cutoffHz">
              <option value="2">2 Hz (very smooth)</option>
              <option value="4">4 Hz</option>
              <option value="6" selected>6 Hz (balanced)</option>
              <option value="8">8 Hz</option>
              <option value="12">12 Hz (less smooth)</option>
            </select>
          </div>
        </div>

        <div class="divider"></div>

        <h3>Kinetics Driver (Selected Joint Kinematics)</h3>
        <div class="form-grid">
          <div>
            <label for="kinJoint">Joint</label>
            <select id="kinJoint">
              <option value="shoulder">Shoulder</option>
              <option value="elbow">Elbow</option>
              <option value="wrist">Wrist</option>
              <option value="hip" selected>Hip</option>
              <option value="knee">Knee</option>
              <option value="ankle">Ankle</option>
              <option value="neck">Neck</option>
            </select>
          </div>
          <div>
            <label for="kinSide">Side</label>
            <select id="kinSide">
              <option value="R" selected>Right (R)</option>
              <option value="L">Left (L)</option>
            </select>
          </div>
          <div>
            <label for="kinMode">Kinetics Model</label>
            <select id="kinMode">
              <option value="jointAccel" selected>Force from joint acceleration + Moment from segment Œ±</option>
            </select>
          </div>
        </div>

        <div class="mini">
          Force‚ÄìTime uses the selected joint‚Äôs <b>linear acceleration</b> with an effective segment mass fraction.
          Moment‚ÄìTime uses <b>segment inertia √ó angular acceleration</b>. (2D proxy, filtered.)
        </div>

        <div class="divider"></div>

        <h3>Projectile Tracking</h3>
        <div class="form-grid">
          <div>
            <label for="projMode">Mode</label>
            <select id="projMode">
              <option value="off" selected>Off</option>
              <option value="auto">Auto (COCO ‚Üí fallback)</option>
              <option value="coco">Object Detect (COCO-SSD)</option>
              <option value="motion">Motion Tracker (fallback)</option>
            </select>
          </div>
          <div>
            <label for="projClassHint">Class Hint</label>
            <select id="projClassHint">
              <option value="sports ball" selected>Sports ball</option>
              <option value="any">Any object (largest moving)</option>
            </select>
          </div>
          <div>
            <label for="projTrail">Trail length (frames)</label>
            <select id="projTrail">
              <option value="10">10</option>
              <option value="20" selected>20</option>
              <option value="30">30</option>
              <option value="50">50</option>
            </select>
          </div>
        </div>

        <button class="btn btn-primary" onclick="startCamera()">Start Camera</button>
        <button class="btn btn-primary" onclick="stopCamera()">Stop Camera</button>
        <button class="btn btn-success" id="recordBtn" onclick="startRecording()" disabled>Start Recording</button>
        <button class="btn btn-danger" id="stopBtn" onclick="stopRecording()" disabled>Stop Recording</button>

        <!-- Mobile PiP toggle -->
        <button class="btn btn-primary pip-toggle" onclick="togglePiP()">üìå Pin Video (PiP)</button>
      </div>

      <div class="card" style="margin-top: 12px;">
        <h3>Display Selector (Angles & Velocities)</h3>
        <div class="form-grid">
          <div>
            <label for="metricType">Metric</label>
            <select id="metricType">
              <option value="angle">Angle (¬∞)</option>
              <option value="angVel">Angular Velocity (¬∞/s)</option>
              <option value="linVel">Linear Velocity (m/s)</option>
            </select>
          </div>
          <div>
            <label for="metricJoint">Joint</label>
            <select id="metricJoint">
              <option value="shoulder">Shoulder</option>
              <option value="elbow">Elbow</option>
              <option value="wrist">Wrist</option>
              <option value="hip">Hip</option>
              <option value="knee">Knee</option>
              <option value="ankle">Ankle</option>
              <option value="neck">Neck</option>
            </select>
          </div>
          <div>
            <label for="metricSide">Side</label>
            <select id="metricSide">
              <option value="R">Right (R)</option>
              <option value="L">Left (L)</option>
            </select>
          </div>
        </div>
        <button class="btn btn-primary" onclick="addMetric()">Add to Display</button>
        <button class="btn btn-danger" onclick="clearMetrics()">Clear</button>

        <div class="chiplist" id="metricChips"></div>

        <div class="divider"></div>

        <h3>Selected Metrics (Real-time)</h3>
        <div class="metrics-grid" id="selectedMetricsPanel"></div>
      </div>

      <div class="card" style="margin-top: 12px;">
        <h3>Kinetics Charts (Real-time)</h3>
        <div class="charts-grid">
          <div class="chart-card">
            <div class="chart-title">
              <b>Force‚ÄìTime |F| (N)</b>
              <span id="lblForce">0.0 N</span>
            </div>
            <canvas id="chartForce" class="chart"></canvas>
          </div>

          <div class="chart-card">
            <div class="chart-title">
              <b>Moment‚ÄìTime œÑ (N¬∑m)</b>
              <span id="lblMoment">0.00 N¬∑m</span>
            </div>
            <canvas id="chartMoment" class="chart"></canvas>
          </div>
        </div>
      </div>

      <div class="card participants-list" style="margin-top: 12px;">
        <h3>Participants (<span id="participantCount">0</span>/10)</h3>
        <div id="participantsList"></div>
        <button class="btn btn-primary" onclick="downloadData()">üìä Download All Data (XLSX)</button>
      </div>
    </div>

    <!-- RIGHT -->
    <div class="sticky" id="stickyVideo">
      <div class="card">
        <h3>Video (Sticky/PiP)</h3>
        <div class="video-wrap">
          <video id="video" playsinline muted></video>
          <canvas id="overlay"></canvas>
          <div class="hud">
            <div><span id="fpsIndicator">FPS: 0</span></div>
            <small id="negotiatedInfo">‚Äî</small>
            <small id="projInfo">Projectile: ‚Äî</small>
            <small id="kinInfo">Kinetics: ‚Äî</small>
          </div>
        </div>
      </div>
    </div>
  </div>

  <footer>¬© 2025 Ng Jun Wei. All rights reserved.</footer>
</div>

<script>
  // ========= Globals =========
  let detector = null;
  let cocoModel = null;

  let video = null;
  let overlay = null;
  let ctx = null;
  let animationId = null;
  let streamRef = null;

  let isRecording = false;
  let recordingFrames = [];
  let participants = [];
  let currentParticipant = null;

  let detectedFPS = 0;
  let frameCount = 0;
  let lastFPSUpdate = Date.now();

  let prevFrame = null;

  // Impulse accumulators
  let impulse_Ns = 0;
  let angImpulse_Nms = 0;
  let lastImpulseT = null;

  // Selected metrics
  let selectedMetrics = [];

  // Angular velocity smoothing state
  const angState = { map: new Map() };
  const MAX_OMEGA_DEG_S = 900;
  const MAX_DTHETA_DEG = 45;

  // Kinetics state
  let kin = {
    vMagF: null, aMagF: null, omegaF: null, alphaF: null, forceF: null, momentF: null
  };

  // Projectile tracking state
  const proj = {
    px: null, m_prev: null, t_prev: null, speed: 0, trail: [],
    lastDetectT: 0, motionCanvas: null, motionCtx: null, prevGray: null
  };

  // MoveNet indices
  const KP = {
    shoulder_L: 5, shoulder_R: 6,
    elbow_L: 7, elbow_R: 8,
    wrist_L: 9, wrist_R: 10,
    hip_L: 11, hip_R: 12,
    knee_L: 13, knee_R: 14,
    ankle_L: 15, ankle_R: 16
  };

  const JOINT_LABELS = [
    "nose","left_eye","right_eye","left_ear","right_ear",
    "shoulder_L","shoulder_R","elbow_L","elbow_R","wrist_L","wrist_R",
    "hip_L","hip_R","knee_L","knee_R","ankle_L","ankle_R"
  ];

  const SKELETON = [
    [KP.shoulder_L, KP.shoulder_R],
    [KP.shoulder_L, KP.elbow_L],
    [KP.elbow_L, KP.wrist_L],
    [KP.shoulder_R, KP.elbow_R],
    [KP.elbow_R, KP.wrist_R],
    [KP.shoulder_L, KP.hip_L],
    [KP.shoulder_R, KP.hip_R],
    [KP.hip_L, KP.hip_R],
    [KP.hip_L, KP.knee_L],
    [KP.knee_L, KP.ankle_L],
    [KP.hip_R, KP.knee_R],
    [KP.knee_R, KP.ankle_R],
  ];

  // Segment mass fractions
  const SEG_MASS_FRAC = {
    upperArm: 0.028, forearm: 0.016, hand: 0.006,
    thigh: 0.105, shank: 0.0465, foot: 0.0145, trunk: 0.50
  };

  // ========= Mobile PiP Toggle =========
  function togglePiP() {
    document.body.classList.toggle("pip-on");
    const on = document.body.classList.contains("pip-on");
    showStatus(on ? "PiP enabled: video pinned ‚úÖ" : "PiP disabled", "info");
  }
  function ensurePiPOnMobileAuto() {
    if (window.matchMedia && window.matchMedia("(max-width: 980px)").matches) {
      document.body.classList.add("pip-on"); // auto-pin on phones
    }
  }

  // ========= Helpers =========
  function showStatus(message, type) {
    const el = document.getElementById('statusMessage');
    el.className = `status-message status-${type}`;
    el.textContent = message;
    el.style.display = 'block';
    setTimeout(() => { el.style.display = 'none'; }, 3200);
  }

  function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }
  function deg(rad){ return rad * 180 / Math.PI; }
  function clampScore(kp, thr=0.3) { return kp && typeof kp.score === "number" && kp.score >= thr; }

  function midpoint(a,b) { return { x:(a.x+b.x)/2, y:(a.y+b.y)/2, score: Math.min(a.score??0, b.score??0) }; }

  function calcAngle(p1,p2,p3) {
    const r = Math.atan2(p3.y-p2.y, p3.x-p2.x) - Math.atan2(p1.y-p2.y, p1.x-p2.x);
    let a = Math.abs(deg(r));
    if (a>180) a = 360-a;
    return a;
  }

  function segmentAngleDeg(a, b) { return deg(Math.atan2(b.y - a.y, b.x - a.x)); }
  function unwrapDeltaDeg(curr, prev) {
    let d = curr - prev;
    d = ((d + 180) % 360) - 180;
    return d;
  }

  function vecSub(a,b){ return {x:a.x-b.x, y:a.y-b.y}; }
  function vecMul(a,s){ return {x:a.x*s, y:a.y*s}; }
  function vecLen(a){ return Math.sqrt(a.x*a.x + a.y*a.y); }

  function drawText(text, x, y) {
    ctx.font = '14px system-ui, -apple-system, Segoe UI, Arial';
    ctx.fillStyle = 'rgba(0,0,0,0.65)';
    ctx.fillText(text, x+1, y+1);
    ctx.fillStyle = '#ffffff';
    ctx.fillText(text, x, y);
  }

  function pxToMetersScale() {
    const h_m = currentParticipant ? (currentParticipant.height / 100) : 1.70;
    const px = overlay ? overlay.height : 720;
    return h_m / px;
  }

  function resizeOverlayToVideo() {
    const vw = video.videoWidth || 0;
    const vh = video.videoHeight || 0;
    if (vw && vh) {
      if (overlay.width !== vw) overlay.width = vw;
      if (overlay.height !== vh) overlay.height = vh;
    }
  }

  function updateFPS() {
    frameCount++;
    const now = Date.now();
    if (now - lastFPSUpdate >= 1000) {
      detectedFPS = frameCount;
      document.getElementById('fpsIndicator').textContent = `FPS: ${detectedFPS}`;
      frameCount = 0;
      lastFPSUpdate = now;
    }
  }

  function getCutoffHz() { return parseFloat(document.getElementById("cutoffHz").value); }
  function getWindowSec() { return parseInt(document.getElementById("windowSeconds").value, 10); }
  function safeDt(dt){ return (dt && dt > 1e-4 && dt < 0.2) ? dt : null; }

  function lowPass(prevY, x, dt, fc) {
    if (prevY == null) return x;
    const RC = 1 / (2 * Math.PI * fc);
    const alpha = dt / (RC + dt);
    return prevY + alpha * (x - prevY);
  }

  function jointKey(joint, side){
    return (joint === "neck") ? "neck" : `${joint}_${side}`;
  }

  function getSegmentForJoint(joint){
    if (joint === "shoulder") return "upperArm";
    if (joint === "elbow")    return "forearm";
    if (joint === "wrist")    return "forearm";
    if (joint === "hip")      return "thigh";
    if (joint === "knee")     return "shank";
    if (joint === "ankle")    return "shank";
    if (joint === "neck")     return "trunk";
    return null;
  }

  function segConfidenceOK(jointsPx, side, segKey) {
    const s = side;
    const j = jointsPx;
    const has = (k) => j[k] && (j[k].score == null || j[k].score >= 0.30);

    if (segKey === "upperArm") return has(`shoulder_${s}`) && has(`elbow_${s}`);
    if (segKey === "forearm")  return has(`elbow_${s}`) && has(`wrist_${s}`);
    if (segKey === "thigh")    return has(`hip_${s}`) && has(`knee_${s}`);
    if (segKey === "shank")    return has(`knee_${s}`) && has(`ankle_${s}`);
    if (segKey === "trunk")    return has("neck") && has("hip_L") && has("hip_R");
    return false;
  }

  // ========= Metric selection UI =========
  function metricLabel(m) {
    const type = m.type === "angle" ? "Angle" : (m.type === "angVel" ? "AngVel" : "LinVel");
    const unit = m.type === "angle" ? "¬∞" : (m.type === "angVel" ? "¬∞/s" : "m/s");
    return `${type} ‚Ä¢ ${m.joint.toUpperCase()}_${m.side} (${unit})`;
  }

  function addMetric() {
    const type = document.getElementById("metricType").value;
    const joint = document.getElementById("metricJoint").value;
    const side = document.getElementById("metricSide").value;

    const id = `${type}:${joint}:${side}`;
    if (selectedMetrics.some(x => x.id === id)) {
      showStatus("That metric is already selected.", "info");
      return;
    }
    selectedMetrics.push({ id, type, joint, side });
    renderMetricUI();
  }

  function removeMetric(id) {
    selectedMetrics = selectedMetrics.filter(m => m.id !== id);
    renderMetricUI();
  }

  function clearMetrics() {
    selectedMetrics = [];
    renderMetricUI();
  }

  function renderMetricUI() {
    const chips = document.getElementById("metricChips");
    chips.innerHTML = selectedMetrics.map(m => `
      <div class="chip">
        <span>${metricLabel(m)}</span>
        <button onclick="removeMetric('${m.id}')">Remove</button>
      </div>
    `).join("");

    const panel = document.getElementById("selectedMetricsPanel");
    panel.innerHTML = selectedMetrics.map(m => `
      <div class="metric">
        <div class="t">${metricLabel(m)}</div>
        <div class="v" id="val_${m.id.replaceAll(':','_')}">0</div>
      </div>
    `).join("");

    if (!selectedMetrics.length) {
      panel.innerHTML = `<div class="mini">No metrics selected yet. Use the selector above to add angles/velocities.</div>`;
    }
  }

  // ========= Charts =========
  const chartSeries = { forceRaw: [], forceFilt: [], momentRaw: [], momentFilt: [] };

  function pushSeries(name, t, v) {
    const win = getWindowSec();
    const arr = chartSeries[name];
    arr.push({t, v});
    const tMin = t - win;
    while (arr.length && arr[0].t < tMin) arr.shift();
  }

  function sizeChartCanvas(c) {
    const dpr = window.devicePixelRatio || 1;
    const cssW = c.clientWidth;
    const cssH = c.clientHeight;
    const w = Math.floor(cssW * dpr);
    const h = Math.floor(cssH * dpr);
    if (c.width !== w || c.height !== h) { c.width = w; c.height = h; }
    return { w, h };
  }

  function drawDualLineChart(canvasId, rawName, filtName, yLabel) {
    const c = document.getElementById(canvasId);
    const g = c.getContext("2d");
    const {w,h} = sizeChartCanvas(c);

    g.clearRect(0,0,w,h);
    g.fillStyle = "#fafafa";
    g.fillRect(0,0,w,h);

    g.strokeStyle = "rgba(0,0,0,0.08)";
    g.lineWidth = 1;
    for (let i=1;i<=4;i++){
      const y = (h*i)/5;
      g.beginPath(); g.moveTo(0,y); g.lineTo(w,y); g.stroke();
    }

    const raw = chartSeries[rawName];
    const fil = chartSeries[filtName];
    if (!raw.length) return;

    const t0 = raw[0].t;
    const t1 = raw[raw.length-1].t;
    const dt = Math.max(1e-6, t1 - t0);

    let minV = raw[0].v, maxV = raw[0].v;
    for (const p of raw) { if (p.v < minV) minV = p.v; if (p.v > maxV) maxV = p.v; }
    for (const p of fil) { if (p.v < minV) minV = p.v; if (p.v > maxV) maxV = p.v; }
    if (minV === maxV) { minV -= 1; maxV += 1; }
    const pad = 0.08 * (maxV - minV);
    minV -= pad; maxV += pad;

    function mapX(t){ return ((t - t0) / dt) * w; }
    function mapY(v){ return h - ((v - minV) / (maxV - minV)) * h; }

    g.strokeStyle = "rgba(120,120,120,0.35)";
    g.lineWidth = 2;
    g.beginPath();
    for (let i=0;i<raw.length;i++){
      const x = mapX(raw[i].t);
      const y = mapY(raw[i].v);
      if (i===0) g.moveTo(x,y); else g.lineTo(x,y);
    }
    g.stroke();

    g.strokeStyle = (canvasId === "chartForce")
      ? "rgba(16,185,129,0.95)"
      : "rgba(239,68,68,0.95)";
    g.lineWidth = 3.5;
    g.beginPath();
    for (let i=0;i<fil.length;i++){
      const x = mapX(fil[i].t);
      const y = mapY(fil[i].v);
      if (i===0) g.moveTo(x,y); else g.lineTo(x,y);
    }
    g.stroke();

    g.fillStyle = "rgba(0,0,0,0.55)";
    g.font = "12px system-ui, -apple-system, Segoe UI, Arial";
    g.fillText(`${maxV.toFixed(2)}`, 8, 14);
    g.fillText(`${minV.toFixed(2)}`, 8, h - 6);
    g.fillText(yLabel, w - 70, 14);
  }

  let lastChartDrawT = 0;
  function throttleChartDraw(t) {
    if (t - lastChartDrawT < 1/15) return;
    lastChartDrawT = t;
    drawDualLineChart("chartForce", "forceRaw", "forceFilt", "N");
    drawDualLineChart("chartMoment", "momentRaw", "momentFilt", "N¬∑m");
  }

  // ========= Model init (iOS-safe) =========
  async function initializePoseDetection() {
    try { await tf.setBackend('webgl'); await tf.ready(); }
    catch (e) { try { await tf.setBackend('wasm'); await tf.ready(); } catch (_) {} }

    const model = window.poseDetection.SupportedModels.MoveNet;
    detector = await window.poseDetection.createDetector(model, {
      modelType: window.poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING
    });
  }

  async function initializeCoco() {
    if (cocoModel) return;
    showStatus("Loading projectile detector‚Ä¶", "info");
    cocoModel = await cocoSsd.load();
    showStatus("Projectile detector loaded ‚úÖ", "success");
  }

  // ========= Camera (iOS troubleshooting included) =========
  async function startCamera() {
    try {
      video = document.getElementById("video");
      overlay = document.getElementById("overlay");
      ctx = overlay.getContext("2d");

      // IMPORTANT iOS: must be started by a user gesture (button press). This function is called by button.
      const reqFps = parseInt(document.getElementById("fpsSelection").value, 10);
      const facingMode = document.getElementById("cameraFacing").value;

      video.setAttribute("playsinline", "");
      video.muted = true;
      video.autoplay = true;

      showStatus("Starting camera‚Ä¶", "info");

      // iOS Safari: request without frameRate first, then applyConstraints (more reliable)
      const stream = await navigator.mediaDevices.getUserMedia({
        audio: false,
        video: {
          facingMode: { ideal: facingMode },
          width: { ideal: 1280 },
          height: { ideal: 720 }
        }
      });

      streamRef = stream;
      video.srcObject = stream;

      await new Promise(res => (video.onloadedmetadata = () => res()));

      // try to set fps (may be ignored on iOS)
      const track = stream.getVideoTracks()[0];
      if (track && track.applyConstraints) {
        try {
          await track.applyConstraints({ frameRate: { ideal: reqFps, max: reqFps } });
        } catch (_) {}
      }

      // ensure play
      await video.play();

      // overlay sizing
      resizeOverlayToVideo();

      // show negotiated info
      const settings = track && track.getSettings ? track.getSettings() : {};
      document.getElementById("negotiatedInfo").textContent =
        `${settings.width || video.videoWidth}√ó${settings.height || video.videoHeight} ‚Ä¢ req ${reqFps}fps ‚Ä¢ got ${settings.frameRate || "?"}fps`;

      // init models
      if (!detector) {
        showStatus("Loading pose model‚Ä¶", "info");
        await initializePoseDetection();
      }

      const mode = document.getElementById("projMode").value;
      if (mode === "coco" || mode === "auto") await initializeCoco();
      ensureMotionTrackerInit();

      // enable record
      document.getElementById("recordBtn").disabled = false;

      // reset states
      prevFrame = null;
      impulse_Ns = 0; angImpulse_Nms = 0; lastImpulseT = null;
      kin = { vMagF:null, aMagF:null, omegaF:null, alphaF:null, forceF:null, momentF:null };
      for (const k of Object.keys(chartSeries)) chartSeries[k] = [];
      angState.map.clear();
      resetProjectileState();

      // Phone: auto-pin video so it stays visible while scrolling
      ensurePiPOnMobileAuto();

      showStatus("Ready ‚úÖ", "success");

      if (animationId) cancelAnimationFrame(animationId);
      loop();

    } catch (err) {
      console.error(err);
      showStatus("Camera error: " + (err.message || err), "error");
    }
  }

  function stopCamera() {
    if (animationId) cancelAnimationFrame(animationId);
    animationId = null;

    if (video) { video.pause(); video.srcObject = null; }
    if (streamRef) { streamRef.getTracks().forEach(t => t.stop()); streamRef = null; }

    document.getElementById("recordBtn").disabled = true;
    document.getElementById("stopBtn").disabled = true;

    isRecording = false;
    currentParticipant = null;

    showStatus("Camera stopped.", "info");
  }

  // ========= Overlay: always on =========
  function drawOverlayAlways(kps, neck) {
    // skeleton
    ctx.lineWidth = 4;
    ctx.strokeStyle = "rgba(255,0,0,0.95)";
    for (const [i,j] of SKELETON) {
      const a = kps[i], b = kps[j];
      if (clampScore(a) && clampScore(b)) {
        ctx.beginPath();
        ctx.moveTo(a.x, a.y);
        ctx.lineTo(b.x, b.y);
        ctx.stroke();
      }
    }
    // joints + labels
    for (let i=0;i<kps.length;i++){
      const kp = kps[i];
      if (!clampScore(kp)) continue;
      ctx.beginPath();
      ctx.arc(kp.x, kp.y, 6, 0, Math.PI*2);
      ctx.fillStyle = "rgba(0,255,0,0.95)";
      ctx.fill();
      drawText(JOINT_LABELS[i], kp.x + 8, kp.y - 8);
    }
    // neck
    if (neck) {
      ctx.beginPath();
      ctx.arc(neck.x, neck.y, 7, 0, Math.PI*2);
      ctx.fillStyle = "rgba(0,200,255,0.95)";
      ctx.fill();
      drawText("neck", neck.x + 8, neck.y - 8);
    }
  }

  // ========= Pose mapping =========
  function buildJointsPx(kps, neck) {
    const pick = (idx) => {
      const kp = kps[idx];
      return clampScore(kp) ? {x:kp.x, y:kp.y, score:kp.score} : null;
    };
    return {
      shoulder_R: pick(KP.shoulder_R),
      shoulder_L: pick(KP.shoulder_L),
      elbow_R: pick(KP.elbow_R),
      elbow_L: pick(KP.elbow_L),
      wrist_R: pick(KP.wrist_R),
      wrist_L: pick(KP.wrist_L),
      hip_R: pick(KP.hip_R),
      hip_L: pick(KP.hip_L),
      knee_R: pick(KP.knee_R),
      knee_L: pick(KP.knee_L),
      ankle_R: pick(KP.ankle_R),
      ankle_L: pick(KP.ankle_L),
      neck: neck ? {x:neck.x, y:neck.y, score: neck.score ?? 0.5} : null
    };
  }

  function computeAngles(jpx, side) {
    const s = side;
    const sh = jpx[`shoulder_${s}`], el = jpx[`elbow_${s}`], wr = jpx[`wrist_${s}`];
    const hp = jpx[`hip_${s}`], kn = jpx[`knee_${s}`], an = jpx[`ankle_${s}`];
    const neck = jpx.neck;

    const out = { shoulder:null, elbow:null, wrist:null, hip:null, knee:null, ankle:null, neck:null };

    if (el && sh && hp) out.shoulder = calcAngle(el, sh, hp);
    if (sh && el && wr) out.elbow = calcAngle(sh, el, wr);

    if (el && wr) {
      const a = Math.abs(segmentAngleDeg(el, wr));
      out.wrist = a > 180 ? 360 - a : a;
    }

    if (sh && hp && kn) out.hip = calcAngle(sh, hp, kn);
    if (hp && kn && an) out.knee = calcAngle(hp, kn, an);

    if (kn && an) {
      const a = Math.abs(segmentAngleDeg(kn, an));
      out.ankle = a > 180 ? 360 - a : a;
    }

    if (neck && jpx.hip_L && jpx.hip_R) {
      const hpMid = midpoint(jpx.hip_L, jpx.hip_R);
      const torso = { x: hpMid.x - neck.x, y: hpMid.y - neck.y };
      const ang = Math.abs(deg(Math.atan2(torso.x, torso.y)));
      out.neck = ang;
    }

    return out;
  }

  function computeSegmentAnglesForAngVel(jpx, side) {
    const s = side;
    const sh = jpx[`shoulder_${s}`], el = jpx[`elbow_${s}`], wr = jpx[`wrist_${s}`];
    const hp = jpx[`hip_${s}`], kn = jpx[`knee_${s}`], an = jpx[`ankle_${s}`];
    const neck = jpx.neck;

    return {
      upperArm: (sh && el) ? segmentAngleDeg(sh, el) : null,
      forearm:  (el && wr) ? segmentAngleDeg(el, wr) : null,
      thigh:    (hp && kn) ? segmentAngleDeg(hp, kn) : null,
      shank:    (kn && an) ? segmentAngleDeg(kn, an) : null,
      trunk:    (neck && jpx.hip_L && jpx.hip_R) ? segmentAngleDeg(neck, midpoint(jpx.hip_L, jpx.hip_R)) : null
    };
  }

  function computeJointLinearVel_mps(joints_m, prevJoints_m, dt, key) {
    const a = joints_m[key], b = prevJoints_m[key];
    if (!a || !b || dt <= 0) return null;
    const v = vecMul(vecSub(a,b), 1/dt);
    return vecLen(v); // m/s only
  }

  // ========= Projectile tracking =========
  function resetProjectileState() {
    proj.px = null; proj.m_prev = null; proj.t_prev = null;
    proj.speed = 0; proj.trail = []; proj.lastDetectT = 0; proj.prevGray = null;
    document.getElementById("projInfo").textContent = "Projectile: ‚Äî";
  }

  function ensureMotionTrackerInit() {
    if (proj.motionCanvas) return;
    proj.motionCanvas = document.createElement("canvas");
    proj.motionCtx = proj.motionCanvas.getContext("2d", { willReadFrequently: true });
  }

  async function detectProjectileCOCO(t) {
    if (!cocoModel) return null;
    if (t - proj.lastDetectT < 0.2) return null;
    proj.lastDetectT = t;

    const preds = await cocoModel.detect(video);
    if (!preds || !preds.length) return null;

    const hint = document.getElementById("projClassHint").value;
    let cand = preds;

    if (hint !== "any") cand = preds.filter(p => p.class === hint);
    if (!cand.length) cand = preds;

    let best = null, bestScore = -Infinity;
    for (const p of cand) {
      const [x,y,w,h] = p.bbox;
      const score = (p.score ?? 0) * Math.sqrt(Math.max(1, w*h));
      if (score > bestScore) { bestScore = score; best = p; }
    }
    if (!best || best.score < 0.35) return null;

    const [x,y,w,h] = best.bbox;
    return { x: x + w/2, y: y + h/2 };
  }

  function trackProjectileMotion() {
    ensureMotionTrackerInit();
    const mc = proj.motionCanvas;
    const mctx = proj.motionCtx;

    const w = video.videoWidth || 0;
    const h = video.videoHeight || 0;
    if (!w || !h) return null;

    const dw = 320;
    const dh = Math.round((h / w) * dw);
    mc.width = dw;
    mc.height = dh;

    mctx.drawImage(video, 0, 0, dw, dh);
    const img = mctx.getImageData(0, 0, dw, dh);
    const data = img.data;

    const gray = new Uint8Array(dw * dh);
    for (let i=0, j=0; i<data.length; i+=4, j++){
      const r=data[i], g=data[i+1], b=data[i+2];
      gray[j] = (0.299*r + 0.587*g + 0.114*b) | 0;
    }

    if (!proj.prevGray) { proj.prevGray = gray; return null; }

    const thr = 22;
    let sumX=0, sumY=0, count=0;
    for (let y=0; y<dh; y++){
      const row = y*dw;
      for (let x=0; x<dw; x++){
        const idx = row + x;
        const d = Math.abs(gray[idx] - proj.prevGray[idx]);
        if (d > thr) { sumX += x; sumY += y; count++; }
      }
    }
    proj.prevGray = gray;
    if (count < 120) return null;

    const cx = sumX / count;
    const cy = sumY / count;

    const px = cx * (w / dw);
    const py = cy * (h / dh);
    return { x: px, y: py };
  }

  function updateProjectileKinematics(t, posPx, scale_m_per_px) {
    if (!posPx) return;

    const maxTrail = parseInt(document.getElementById("projTrail").value, 10);
    proj.trail.push({x: posPx.x, y: posPx.y});
    while (proj.trail.length > maxTrail) proj.trail.shift();

    const m = { x: posPx.x * scale_m_per_px, y: posPx.y * scale_m_per_px };

    if (proj.m_prev && proj.t_prev != null) {
      const dt = t - proj.t_prev;
      if (dt > 1e-4 && dt < 0.5) {
        const v = vecMul(vecSub(m, proj.m_prev), 1/dt);
        proj.speed = vecLen(v);
      }
    }

    proj.px = posPx;
    proj.m_prev = m;
    proj.t_prev = t;
  }

  function drawProjectileOverlay() {
    if (!proj.px) return;

    ctx.lineWidth = 3;
    ctx.strokeStyle = "rgba(255,255,255,0.65)";
    ctx.beginPath();
    for (let i=0; i<proj.trail.length; i++){
      const p = proj.trail[i];
      if (i===0) ctx.moveTo(p.x, p.y);
      else ctx.lineTo(p.x, p.y);
    }
    ctx.stroke();

    ctx.beginPath();
    ctx.arc(proj.px.x, proj.px.y, 8, 0, Math.PI*2);
    ctx.fillStyle = "rgba(255, 165, 0, 0.95)";
    ctx.fill();

    drawText(`Projectile v ${proj.speed.toFixed(2)} m/s`, proj.px.x + 12, proj.px.y - 10);
    document.getElementById("projInfo").textContent = `Projectile: ${proj.speed.toFixed(2)} m/s`;
  }

  // ========= Selected metrics computation =========
  function computeSelectedMetricValues({dt, jointsPx, joints_m, angR, angL, segR, segL, prevFrame}) {
    const out = {};
    for (const m of selectedMetrics) {
      const side = m.side;
      const sideAngles = (side === "R") ? angR : angL;
      const sideSeg = (side === "R") ? segR : segL;

      let val = null;

      if (m.type === "angle") {
        val = sideAngles[m.joint] ?? null;

      } else if (m.type === "angVel") {
        if (!prevFrame || !dt || dt <= 0.005 || dt > 0.08) {
          val = null;
        } else {
          const map = { shoulder:"upperArm", elbow:"forearm", wrist:"forearm", hip:"thigh", knee:"shank", ankle:"shank", neck:"trunk" };
          const segKey = map[m.joint];

          if (!segConfidenceOK(jointsPx, m.side, segKey)) {
            val = null;
          } else {
            const currTheta = sideSeg[segKey];
            const prevTheta = (side === "R")
              ? (prevFrame.segAnglesR ? prevFrame.segAnglesR[segKey] : null)
              : (prevFrame.segAnglesL ? prevFrame.segAnglesL[segKey] : null);

            if (currTheta == null || prevTheta == null) {
              val = null;
            } else {
              let dTheta = unwrapDeltaDeg(currTheta, prevTheta);
              dTheta = clamp(dTheta, -MAX_DTHETA_DEG, MAX_DTHETA_DEG);

              const st = angState.map.get(m.id) || { prevThetaF: null, omegaF: null };
              const fcTheta = getCutoffHz();

              const thetaPred = (st.prevThetaF == null) ? currTheta : (st.prevThetaF + dTheta);
              const thetaF = lowPass(st.prevThetaF, thetaPred, dt, fcTheta);

              let omega = 0;
              if (st.prevThetaF != null) omega = (thetaF - st.prevThetaF) / dt;
              omega = clamp(omega, -MAX_OMEGA_DEG_S, MAX_OMEGA_DEG_S);

              const fcOmega = Math.max(2, fcTheta * 0.6);
              const omegaF = lowPass(st.omegaF, omega, dt, fcOmega);

              angState.map.set(m.id, { prevThetaF: thetaF, omegaF });
              val = omegaF;
            }
          }
        }

      } else if (m.type === "linVel") {
        const dtSafe = safeDt(dt);
        if (!prevFrame || !dtSafe) val = null;
        else {
          const key = jointKey(m.joint, m.side);
          val = computeJointLinearVel_mps(joints_m, prevFrame.joints_m, dtSafe, key);
        }
      }

      out[m.id] = val;
    }
    return out;
  }

  function drawSelectedLabels(values, jointsPx) {
    let count = 0;
    for (const m of selectedMetrics) {
      if (count > 8) break;
      const v = values[m.id];
      if (v == null) continue;

      const unit = (m.type === "angle") ? "¬∞" : (m.type === "angVel") ? "¬∞/s" : "m/s";
      const symbol = (m.type === "angle") ? "A" : (m.type === "angVel") ? "œâ" : "v";

      const anchor = (m.joint === "neck") ? jointsPx.neck : jointsPx[`${m.joint}_${m.side}`];
      if (!anchor) continue;

      drawText(`${m.joint.toUpperCase()}_${m.side} ${symbol} ${v.toFixed(2)} ${unit}`, anchor.x + 10, anchor.y + 18);
      count++;
    }
  }

  // ========= Joint-driven kinetics =========
  function computeKineticsFromSelectedJoint({t, dt, joints_m, segR, segL, mass}) {
    const dtSafe = safeDt(dt);
    if (!prevFrame || !dtSafe) return { forceMag: 0, moment: 0, driverLabel: "‚Äî" };

    const joint = document.getElementById("kinJoint").value;
    const side = document.getElementById("kinSide").value;

    const key = jointKey(joint, side);
    const j_m = joints_m[key];
    const prevJ_m = prevFrame.joints_m ? prevFrame.joints_m[key] : null;
    if (!j_m || !prevJ_m) return { forceMag: 0, moment: 0, driverLabel: `${joint.toUpperCase()}_${side} (no data)` };

    const v = vecMul(vecSub(j_m, prevJ_m), 1/dtSafe);
    const vMag = vecLen(v);

    let aMag = 0;
    const prevV = prevFrame.v_joint ? prevFrame.v_joint[key] : null;
    if (prevV) {
      const dv = vecSub(v, prevV);
      const a = vecMul(dv, 1/dtSafe);
      aMag = vecLen(a);
    }

    const fc = getCutoffHz();
    kin.vMagF = lowPass(kin.vMagF, vMag, dtSafe, fc);
    kin.aMagF = lowPass(kin.aMagF, aMag, dtSafe, fc);

    const seg = getSegmentForJoint(joint);
    const mEff = seg ? (SEG_MASS_FRAC[seg] * mass) : (0.10 * mass);
    const Fraw = mEff * (kin.aMagF ?? 0);
    kin.forceF = lowPass(kin.forceF, Fraw, dtSafe, fc);
    const forceMag = kin.forceF ?? 0;

    let moment = 0;
    if (seg) {
      const segAngles = (side === "R") ? segR : segL;
      const segKeyMap = { upperArm:"upperArm", forearm:"forearm", thigh:"thigh", shank:"shank", trunk:"trunk" };
      const segKey = segKeyMap[seg];

      if (segKey && segAngles[segKey] != null) {
        const theta = segAngles[segKey];
        const prevTheta = prevFrame.segAngles ? prevFrame.segAngles[segKey] : null;

        if (prevTheta != null) {
          let dTheta = unwrapDeltaDeg(theta, prevTheta);
          dTheta = clamp(dTheta, -MAX_DTHETA_DEG, MAX_DTHETA_DEG);
          const omega = dTheta / dtSafe; // deg/s

          kin.omegaF = lowPass(kin.omegaF, omega, dtSafe, Math.max(2, fc*0.6));

          let alpha = 0;
          if (prevFrame.omega != null) alpha = (kin.omegaF - prevFrame.omega) / dtSafe; // deg/s^2
          kin.alphaF = lowPass(kin.alphaF, alpha, dtSafe, Math.max(2, fc*0.6));

          let L = 0.3;
          if (seg === "upperArm") {
            const a = joints_m[`shoulder_${side}`], b = joints_m[`elbow_${side}`];
            if (a && b) L = vecLen(vecSub(b,a));
          } else if (seg === "forearm") {
            const a = joints_m[`elbow_${side}`], b = joints_m[`wrist_${side}`];
            if (a && b) L = vecLen(vecSub(b,a));
          } else if (seg === "thigh") {
            const a = joints_m[`hip_${side}`], b = joints_m[`knee_${side}`];
            if (a && b) L = vecLen(vecSub(b,a));
          } else if (seg === "shank") {
            const a = joints_m[`knee_${side}`], b = joints_m[`ankle_${side}`];
            if (a && b) L = vecLen(vecSub(b,a));
          } else if (seg === "trunk") {
            const n = joints_m.neck, hl = joints_m.hip_L, hr = joints_m.hip_R;
            if (n && hl && hr) {
              const hm = { x:(hl.x+hr.x)/2, y:(hl.y+hr.y)/2 };
              L = vecLen(vecSub(hm,n));
            }
          }

          const mSeg = SEG_MASS_FRAC[seg] * mass;
          const I = (1/12) * mSeg * L * L;

          const alpha_rad = (kin.alphaF ?? 0) * (Math.PI/180);
          const tauRaw = I * alpha_rad;

          kin.momentF = lowPass(kin.momentF, tauRaw, dtSafe, fc);
          moment = kin.momentF ?? 0;
        }
      }
    }

    return { forceMag, moment, driverLabel: `${joint.toUpperCase()}_${side}` };
  }

  // ========= Main loop =========
  async function loop() {
    try {
      if (!video || video.readyState < 2 || !detector) {
        animationId = requestAnimationFrame(loop);
        return;
      }

      resizeOverlayToVideo();
      ctx.clearRect(0,0,overlay.width, overlay.height);

      const poses = await detector.estimatePoses(video);
      const t = performance.now() / 1000;
      const scale = pxToMetersScale();
      const mass = currentParticipant ? currentParticipant.mass : 70;

      // Projectile update
      const projMode = document.getElementById("projMode").value;
      let projPos = null;

      if (projMode !== "off") {
        if ((projMode === "coco" || projMode === "auto") && cocoSsd) {
          if (!cocoModel && (projMode === "coco" || projMode === "auto")) {
            // lazy load if user turned on while running
            initializeCoco().catch(()=>{});
          }
          if (cocoModel) projPos = await detectProjectileCOCO(t);
        }
        if (!projPos && (projMode === "motion" || projMode === "auto")) projPos = trackProjectileMotion();
        if (projPos) updateProjectileKinematics(t, projPos, scale);
      }

      if (poses && poses.length) {
        const kps = poses[0].keypoints;

        const shL = kps[KP.shoulder_L], shR = kps[KP.shoulder_R];
        const neck = (clampScore(shL) && clampScore(shR)) ? midpoint(shL, shR) : null;

        drawOverlayAlways(kps, neck);

        const jointsPx = buildJointsPx(kps, neck);

        const joints_m = {};
        for (const k of Object.keys(jointsPx)) {
          const p = jointsPx[k];
          joints_m[k] = p ? { x: p.x * scale, y: p.y * scale } : null;
        }

        const angR = computeAngles(jointsPx, "R");
        const angL = computeAngles(jointsPx, "L");
        const segR = computeSegmentAnglesForAngVel(jointsPx, "R");
        const segL = computeSegmentAnglesForAngVel(jointsPx, "L");

        const dt = prevFrame ? (t - prevFrame.t) : 0;

        const v_joint = {};
        const dtSafeNow = safeDt(dt);
        if (prevFrame && prevFrame.joints_m && dtSafeNow) {
          for (const key of Object.keys(joints_m)) {
            if (joints_m[key] && prevFrame.joints_m[key]) {
              v_joint[key] = vecMul(vecSub(joints_m[key], prevFrame.joints_m[key]), 1/dtSafeNow);
            }
          }
        }

        const kinOut = computeKineticsFromSelectedJoint({ t, dt, joints_m, segR, segL, mass });
        const forceMag = kinOut.forceMag;
        const moment = kinOut.moment;

        document.getElementById("lblForce").textContent = `${forceMag.toFixed(1)} N`;
        document.getElementById("lblMoment").textContent = `${moment.toFixed(2)} N¬∑m`;
        document.getElementById("kinInfo").textContent = `Kinetics: ${kinOut.driverLabel}`;

        pushSeries("forceRaw", t, forceMag);
        pushSeries("forceFilt", t, forceMag);
        pushSeries("momentRaw", t, moment);
        pushSeries("momentFilt", t, moment);
        throttleChartDraw(t);

        if (isRecording) {
          if (lastImpulseT != null) {
            const dtI = t - lastImpulseT;
            if (dtI > 1e-4 && dtI < 0.2) {
              impulse_Ns += forceMag * dtI;
              angImpulse_Nms += moment * dtI;
            }
          }
          lastImpulseT = t;
        }

        const values = computeSelectedMetricValues({ dt, jointsPx, joints_m, angR, angL, segR, segL, prevFrame });

        for (const m of selectedMetrics) {
          const elId = "val_" + m.id.replaceAll(":","_");
          const el = document.getElementById(elId);
          if (!el) continue;
          const v = values[m.id];
          const unit = (m.type === "angle") ? "¬∞" : (m.type === "angVel") ? "¬∞/s" : "m/s";
          el.innerHTML = (v == null ? "N/A" : `${v.toFixed(2)}<span class="unit">${unit}</span>`);
        }

        drawSelectedLabels(values, jointsPx);

        if (projMode !== "off") drawProjectileOverlay();

        if (isRecording && currentParticipant) {
          recordingFrames.push({
            t_ms: Date.now(),
            t_s: t,
            fpsDetected: detectedFPS,
            plane: document.getElementById("planeSelection").value,
            cutoffHz: getCutoffHz(),
            force_N: forceMag,
            moment_Nm: moment,
            impulse_Ns,
            angImpulse_Nms,
            projectile_px: proj.px ? {x: proj.px.x, y: proj.px.y} : null,
            projectile_speed_mps: projMode !== "off" ? proj.speed : 0,
            selected: values,
            joints: jointsPx,
            kineticsDriver: { joint: document.getElementById("kinJoint").value, side: document.getElementById("kinSide").value }
          });
        }

        const kinJoint = document.getElementById("kinJoint").value;
        const kinSide = document.getElementById("kinSide").value;
        const seg = getSegmentForJoint(kinJoint);
        const segAnglesForDriver = seg ? ((kinSide === "R") ? segR : segL) : null;

        prevFrame = {
          t,
          joints_m,
          v_joint,
          segAnglesR: segR,
          segAnglesL: segL,
          segAngles: segAnglesForDriver,
          omega: kin.omegaF
        };

      } else {
        if (projMode !== "off") drawProjectileOverlay();
      }

      updateFPS();
      animationId = requestAnimationFrame(loop);

    } catch (e) {
      console.error("Loop error:", e);
      showStatus("Runtime error (recovering)‚Ä¶", "error");
      animationId = requestAnimationFrame(loop);
    }
  }

  // ========= Recording =========
  function startRecording() {
    const selectedId = document.getElementById("selectedParticipant").value;
    if (!selectedId) { showStatus("Select a participant first!", "error"); return; }
    currentParticipant = participants.find(p => String(p.id) === String(selectedId));
    if (!currentParticipant) { showStatus("Participant not found.", "error"); return; }

    isRecording = true;
    recordingFrames = [];

    impulse_Ns = 0; angImpulse_Nms = 0; lastImpulseT = null;

    angState.map.clear();
    kin = { vMagF:null, aMagF:null, omegaF:null, alphaF:null, forceF:null, momentF:null };

    document.getElementById("recordBtn").disabled = true;
    document.getElementById("stopBtn").disabled = false;

    showStatus(`Recording for ${currentParticipant.name}‚Ä¶`, "info");
  }

  function stopRecording() {
    if (isRecording && currentParticipant && recordingFrames.length) {
      currentParticipant.recordings.push({
        timestamp: new Date().toISOString(),
        fpsDetected: detectedFPS,
        plane: document.getElementById("planeSelection").value,
        cutoffHz: getCutoffHz(),
        windowSec: getWindowSec(),
        projMode: document.getElementById("projMode").value,
        projHint: document.getElementById("projClassHint").value,
        selectedMetrics: [...selectedMetrics],
        kineticsDriver: { joint: document.getElementById("kinJoint").value, side: document.getElementById("kinSide").value },
        frames: recordingFrames
      });
      updateParticipantsList();
      showStatus(`Saved ‚úÖ ${recordingFrames.length} frames`, "success");
    } else {
      showStatus("Stopped (no frames saved).", "info");
    }

    isRecording = false;
    recordingFrames = [];
    currentParticipant = null;

    document.getElementById("recordBtn").disabled = false;
    document.getElementById("stopBtn").disabled = true;
  }

  // ========= Participants =========
  function addParticipant() {
    if (participants.length >= 10) { showStatus("Max 10 participants.", "error"); return; }
    const name = document.getElementById('participantName').value.trim();
    const sex = document.getElementById('participantSex').value;
    const age = document.getElementById('participantAge').value;
    const mass = document.getElementById('participantMass').value;
    const height = document.getElementById('participantHeight').value;

    if (!name || !sex || !age || !mass || !height) { showStatus("Fill all participant fields.", "error"); return; }

    participants.push({
      id: Date.now(),
      name, sex,
      age: parseInt(age,10),
      mass: parseFloat(mass),
      height: parseFloat(height),
      recordings: []
    });

    clearParticipantForm();
    updateParticipantsList();
    showStatus(`Added "${name}" ‚úÖ`, "success");
  }

  function clearParticipantForm() {
    document.getElementById('participantName').value = '';
    document.getElementById('participantSex').value = '';
    document.getElementById('participantAge').value = '';
    document.getElementById('participantMass').value = '';
    document.getElementById('participantHeight').value = '';
  }

  function updateParticipantsList() {
    document.getElementById("participantCount").textContent = participants.length;

    const list = document.getElementById("participantsList");
    list.innerHTML = participants.map(p => `
      <div class="item">
        <div>
          <b>${p.name}</b> ‚Äî ${p.sex}, ${p.age}y, ${p.mass}kg, ${p.height}cm
          <div style="color:#666; font-weight:850; font-size:.88em; margin-top:4px;">
            Recordings: ${p.recordings.length}
          </div>
        </div>
        <button class="btn btn-danger" onclick="removeParticipant(${p.id})">Remove</button>
      </div>
    `).join("");

    const sel = document.getElementById("selectedParticipant");
    sel.innerHTML = `<option value="">Select a participant</option>` +
      participants.map(p => `<option value="${p.id}">${p.name}</option>`).join('');
  }

  function removeParticipant(id) {
    participants = participants.filter(p => p.id !== id);
    updateParticipantsList();
    showStatus("Participant removed.", "info");
  }

  // ========= XLSX Export =========
  function avg(arr) { return arr.length ? arr.reduce((a,b)=>a+b,0)/arr.length : 0; }
  function max(arr) { return arr.length ? Math.max(...arr) : 0; }

  function downloadData() {
    if (!participants.length) { showStatus("No participants to export!", "error"); return; }
    const wb = XLSX.utils.book_new();

    participants.forEach(p => {
      const rows = [];
      rows.push(["Participant Information"]);
      rows.push(["Name", p.name]);
      rows.push(["Sex", p.sex]);
      rows.push(["Age", p.age]);
      rows.push(["Mass (kg)", p.mass]);
      rows.push(["Height (cm)", p.height]);
      rows.push([]);
      rows.push(["Recordings", p.recordings.length]);

      p.recordings.forEach((rec, ridx) => {
        rows.push([]);
        rows.push([`Recording ${ridx+1}`, rec.timestamp]);
        rows.push(["Plane", rec.plane]);
        rows.push(["Detected FPS", rec.fpsDetected]);
        rows.push(["Low-pass cutoff (Hz)", rec.cutoffHz]);
        rows.push(["Projectile Mode", rec.projMode]);
        rows.push(["Projectile Hint", rec.projHint]);
        rows.push(["Kinetics Driver", `${rec.kineticsDriver?.joint?.toUpperCase() || "‚Äî"}_${rec.kineticsDriver?.side || "‚Äî"}`]);

        const F = rec.frames.map(f => f.force_N ?? 0);
        const M = rec.frames.map(f => f.moment_Nm ?? 0);

        const avgForce = avg(F);
        const avgMoment = avg(M);

        const finalImpulse = rec.frames.length ? (rec.frames[rec.frames.length-1].impulse_Ns ?? 0) : 0;
        const finalAngImpulse = rec.frames.length ? (rec.frames[rec.frames.length-1].angImpulse_Nms ?? 0) : 0;

        const projSpeeds = rec.frames.map(f => f.projectile_speed_mps ?? 0).filter(v => v > 0);
        const avgProj = avg(projSpeeds);
        const maxProj = max(projSpeeds);

        rows.push(["Average Force (N)", Number(avgForce.toFixed(3))]);
        rows.push(["Average Moment (N¬∑m)", Number(avgMoment.toFixed(3))]);
        rows.push(["Total Impulse ‚à´|F|dt (N¬∑s)", Number(finalImpulse.toFixed(3))]);
        rows.push(["Total Angular Impulse ‚à´œÑdt (N¬∑m¬∑s)", Number(finalAngImpulse.toFixed(3))]);
        rows.push(["Projectile Avg Speed (m/s)", Number(avgProj.toFixed(3))]);
        rows.push(["Projectile Max Speed (m/s)", Number(maxProj.toFixed(3))]);

        rows.push([]);
        rows.push(["Calculation Used"]);
        rows.push(["Force (joint-driven proxy)", "|F| = m_eff ¬∑ |a_joint|,  m_eff = segment_mass_fraction ¬∑ body_mass"]);
        rows.push(["Impulse", "Impulse = Œ£ |F|¬∑dt"]);
        rows.push(["Moment (proxy)", "œÑ = I ¬∑ Œ±,  I = (1/12) m_seg L^2,  Œ± from filtered segment angle"]);
        rows.push(["Angular Impulse", "Angular Impulse = Œ£ œÑ¬∑dt"]);
        rows.push(["Projectile Speed", "v = |Œîx|/Œît (meters via scale = height_m / video_px_height)"]);

        rows.push([]);
        rows.push(["Selected Metrics"]);
        (rec.selectedMetrics || []).forEach(m => rows.push([`${m.type}:${m.joint}:${m.side}`]));
        rows.push([]);

        const header = [
          "Frame","t_ms","t_s","fpsDetected","plane",
          "force_N","moment_Nm",
          "impulse_Ns","angImpulse_Nms",
          "projectile_x_px","projectile_y_px","projectile_speed_mps",
          "kinDriver_joint","kinDriver_side",
          "selectedMetrics_JSON"
        ];
        rows.push(header);

        rec.frames.forEach((f, i) => {
          rows.push([
            i, f.t_ms, Number((f.t_s ?? 0).toFixed(4)), f.fpsDetected, f.plane,
            Number((f.force_N ?? 0).toFixed(4)),
            Number((f.moment_Nm ?? 0).toFixed(4)),
            Number((f.impulse_Ns ?? 0).toFixed(4)),
            Number((f.angImpulse_Nms ?? 0).toFixed(4)),
            f.projectile_px ? Number(f.projectile_px.x.toFixed(2)) : "N/A",
            f.projectile_px ? Number(f.projectile_px.y.toFixed(2)) : "N/A",
            Number((f.projectile_speed_mps ?? 0).toFixed(4)),
            f.kineticsDriver?.joint || "",
            f.kineticsDriver?.side || "",
            JSON.stringify(f.selected || {})
          ]);
        });
      });

      const ws = XLSX.utils.aoa_to_sheet(rows);
      XLSX.utils.book_append_sheet(wb, ws, p.name.substring(0,31));
    });

    XLSX.writeFile(wb, `sport_performance_${new Date().toISOString().split("T")[0]}.xlsx`);
    showStatus("Exported XLSX ‚úÖ", "success");
  }

  // ========= Boot =========
  window.addEventListener("load", () => {
    renderMetricUI();
    updateParticipantsList();
    showStatus("Ready. Add participant ‚Üí set kinetics driver ‚Üí select metrics ‚Üí Start Camera.", "info");

    // redraw charts on resize
    window.addEventListener("resize", () => {
      const t = performance.now() / 1000;
      throttleChartDraw(t);
    });
  });
</script>
</body>
</html>
